#!/usr/bin/env python3
"""
Claude MPM MCP Server Entry Point
==================================

This script is the entry point for the Claude MPM MCP server when spawned
by Claude Desktop/Code. It runs as a stdio-based JSON-RPC server with full
tool support including ticket management.

WHY: Claude Desktop needs a simple executable to spawn MCP servers.
This script provides that entry point with all available tools registered.

DESIGN DECISION: We use the proper MCPGateway class which implements the
official MCP Server protocol from the Anthropic MCP package, ensuring
full protocol compliance and compatibility with Claude Desktop.

Usage in Claude Desktop config:
{
  "mcpServers": {
    "claude-mpm": {
      "command": "claude-mpm-mcp"
    }
  }
}
"""

import sys
import asyncio
import logging
from pathlib import Path

# Add the project root to Python path if needed
project_root = Path(__file__).parent.parent
if str(project_root) not in sys.path:
    sys.path.insert(0, str(project_root))

# Import the proper MCP Gateway components
from src.claude_mpm.services.mcp_gateway.server.mcp_gateway import MCPGateway
from src.claude_mpm.services.mcp_gateway.registry.tool_registry import ToolRegistry

# Import tools to register
from src.claude_mpm.services.mcp_gateway.tools.base_adapter import (
    CalculatorToolAdapter,
    EchoToolAdapter,
    SystemInfoToolAdapter,
)
from src.claude_mpm.services.mcp_gateway.tools.document_summarizer import DocumentSummarizerTool
from src.claude_mpm.services.mcp_gateway.tools.unified_ticket_tool import UnifiedTicketTool


async def main():
    """
    Main entry point for the MCP server.
    
    WHY: This function sets up and runs the proper MCPGateway with the
    official MCP protocol implementation and all available tools.
    
    DESIGN DECISIONS:
    - Use MCPGateway for official MCP protocol compliance
    - Register all available tools through the ToolRegistry
    - Handle errors gracefully without interfering with stdio
    """
    # Configure logging to stderr so it doesn't interfere with stdio protocol
    logging.basicConfig(
        level=logging.INFO,
        format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
        stream=sys.stderr
    )
    
    logger = logging.getLogger("MCPGatewayMain")
    
    try:
        # Create the tool registry
        registry = ToolRegistry()
        if not await registry.initialize():
            logger.warning("Failed to fully initialize tool registry")
        
        # Register all available tools
        tools = [
            # Basic tools
            EchoToolAdapter(),
            CalculatorToolAdapter(),
            SystemInfoToolAdapter(),
            # Document summarizer
            DocumentSummarizerTool(),
            # Unified ticket management tool
            UnifiedTicketTool(),
        ]
        
        # Initialize and register each tool
        for tool in tools:
            try:
                if await tool.initialize():
                    if registry.register_tool(tool, category="builtin"):
                        logger.info(f"Registered tool: {tool.get_definition().name}")
                    else:
                        logger.warning(f"Failed to register tool: {tool.get_definition().name}")
                else:
                    logger.warning(f"Failed to initialize tool: {tool.get_definition().name}")
            except Exception as e:
                logger.error(f"Error with tool {type(tool).__name__}: {e}")
        
        # Create the MCP Gateway server with official MCP protocol
        server = MCPGateway(
            gateway_name="claude-mpm-gateway",
            version="1.0.0"
        )
        
        # Set the tool registry
        server.set_tool_registry(registry)
        
        # Initialize the server
        if not await server.initialize():
            logger.error("Failed to initialize MCP server")
            sys.exit(1)
        
        # Run the server (this handles stdio communication)
        logger.info("Starting MCP Gateway with official protocol")
        await server.run()
        
    except KeyboardInterrupt:
        # Handle graceful shutdown
        logger.info("Received interrupt, shutting down")
        pass
    except Exception as e:
        logger.error(f"Server error: {e}")
        sys.exit(1)


if __name__ == "__main__":
    asyncio.run(main())