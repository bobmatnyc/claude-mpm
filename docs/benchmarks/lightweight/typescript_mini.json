{
  "agent_id": "typescript_engineer",
  "language": "typescript",
  "suite_type": "lightweight",
  "total_tests": 12,
  "difficulty_distribution": {
    "easy": 4,
    "medium": 5,
    "hard": 3
  },
  "category_coverage": [
    "real_world",
    "functional_programming",
    "type_safety",
    "design_patterns",
    "type_system",
    "data_structures",
    "algorithms"
  ],
  "source_suite": "expanded_v1",
  "version": "1.0.0",
  "tests": [
    {
      "id": "typescript_easy_01",
      "name": "Type-Safe Two Sum",
      "difficulty": "easy",
      "category": "algorithms",
      "description": "Implement two sum with strict type safety using TypeScript generics and branded types for array indices.",
      "signature": "function twoSum<T extends number>(nums: readonly T[], target: T): readonly [number, number] | null",
      "test_cases": [
        {
          "input": "([2, 7, 11, 15], 9)",
          "expected": "[0, 1]"
        },
        {
          "input": "([3, 2, 4], 6)",
          "expected": "[1, 2]"
        }
      ],
      "constraints": [
        "Must use readonly arrays",
        "Must use branded types for indices"
      ],
      "hints": [
        "Use Map for O(n) lookup",
        "Leverage TypeScript's type system"
      ],
      "solution_approach": "Hash map with branded type indices",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "typescript_easy_02",
      "name": "Generic Stack Implementation",
      "difficulty": "easy",
      "category": "data_structures",
      "description": "Implement a type-safe generic stack with push, pop, and peek operations.",
      "signature": "class Stack<T> {\n  push(item: T): void\n  pop(): T | undefined\n  peek(): T | undefined\n  isEmpty(): boolean\n}",
      "test_cases": [
        {
          "input": "const s = new Stack<number>(); s.push(1); s.push(2); s.pop()",
          "expected": "2"
        }
      ],
      "constraints": [
        "Must use generics",
        "Type-safe operations"
      ],
      "hints": [
        "Use private array for storage",
        "Leverage TypeScript's type inference"
      ],
      "solution_approach": "Generic array-based stack",
      "time_complexity": "O(1) for all operations",
      "space_complexity": "O(n)"
    },
    {
      "id": "typescript_easy_03",
      "name": "Type Predicate for User Validation",
      "difficulty": "easy",
      "category": "type_safety",
      "description": "Create a type predicate function to validate user objects at runtime with type narrowing.",
      "signature": "function isValidUser(obj: unknown): obj is User",
      "test_cases": [
        {
          "input": "{ name: 'Alice', age: 30, email: 'alice@example.com' }",
          "expected": "true"
        },
        {
          "input": "{ name: 'Bob', age: 'thirty' }",
          "expected": "false"
        }
      ],
      "constraints": [
        "Must use type predicate",
        "Type narrowing must work"
      ],
      "hints": [
        "Use 'is' keyword in return type",
        "Check all required properties"
      ],
      "solution_approach": "Runtime validation with type guards",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "typescript_easy_04",
      "name": "Mapped Type Utility",
      "difficulty": "easy",
      "category": "type_system",
      "description": "Create a utility type that makes all properties of an object optional and nullable.",
      "signature": "type Nullable<T> = { [K in keyof T]?: T[K] | null }",
      "test_cases": [
        {
          "input": "type User = { name: string; age: number }",
          "expected": "type NullableUser = { name?: string | null; age?: number | null }"
        }
      ],
      "constraints": [
        "Must use mapped types",
        "Must preserve property types"
      ],
      "hints": [
        "Use keyof and indexed access",
        "Combine with optional modifier"
      ],
      "solution_approach": "Mapped type with optional and union",
      "time_complexity": "N/A (compile-time)",
      "space_complexity": "N/A (compile-time)"
    },
    {
      "id": "typescript_medium_05",
      "name": "State Machine with Types",
      "difficulty": "medium",
      "category": "design_patterns",
      "description": "Implement a type-safe finite state machine where valid transitions are enforced at compile-time.",
      "signature": "class StateMachine<States extends string, Events extends Record<string, States>>",
      "test_cases": [
        {
          "input": "type States = 'idle' | 'loading' | 'success' | 'error'",
          "expected": "Only valid transitions compile"
        }
      ],
      "constraints": [
        "Invalid transitions must fail at compile-time",
        "State and event types must be preserved"
      ],
      "hints": [
        "Use mapped types for transitions",
        "Use literal types for states"
      ],
      "solution_approach": "Generic FSM with literal types",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "typescript_medium_03",
      "name": "Async Pipeline with Types",
      "difficulty": "medium",
      "category": "functional_programming",
      "description": "Create a type-safe async pipeline that composes functions with automatic type inference.",
      "signature": "function pipeline<A, B, C>(f1: (a: A) => Promise<B>, f2: (b: B) => Promise<C>): (a: A) => Promise<C>",
      "test_cases": [
        {
          "input": "pipeline(async (x: number) => x * 2, async (x: number) => x.toString())",
          "expected": "Function that takes number and returns Promise<string>"
        }
      ],
      "constraints": [
        "Must infer types automatically",
        "Must compose async functions"
      ],
      "hints": [
        "Use function overloads",
        "Chain promises properly"
      ],
      "solution_approach": "Generic function composition",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "typescript_medium_09",
      "name": "Type-Safe Query Builder",
      "difficulty": "medium",
      "category": "real_world",
      "description": "Implement a type-safe SQL query builder where column names and types are validated at compile-time.",
      "signature": "class QueryBuilder<T extends object> { select<K extends keyof T>(...keys: K[]): QueryBuilder<Pick<T, K>> }",
      "test_cases": [
        {
          "input": "db.select('name', 'age').where('age', '>', 18)",
          "expected": "Only valid columns allowed"
        }
      ],
      "constraints": [
        "Column names must be type-checked",
        "Return types must reflect selections"
      ],
      "hints": [
        "Use keyof for column validation",
        "Use Pick for projection"
      ],
      "solution_approach": "Generic query builder with constraints",
      "time_complexity": "O(1) per operation",
      "space_complexity": "O(n)"
    },
    {
      "id": "typescript_medium_06",
      "name": "Branded ID Types",
      "difficulty": "medium",
      "category": "type_safety",
      "description": "Create a system of branded ID types for different entities that prevent mixing.",
      "signature": "type UserId = string & { readonly __brand: 'UserId' }\\ntype PostId = string & { readonly __brand: 'PostId' }",
      "test_cases": [
        {
          "input": "function getUser(id: UserId): User",
          "expected": "Cannot pass PostId where UserId expected"
        }
      ],
      "constraints": [
        "Different ID types must be incompatible",
        "Runtime values should be strings"
      ],
      "hints": [
        "Use intersection types",
        "Create factory functions"
      ],
      "solution_approach": "Branded types for domain safety",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "typescript_medium_01",
      "name": "Advanced Generic Constraints",
      "difficulty": "medium",
      "category": "type_system",
      "description": "Create a type-safe builder pattern with method chaining and compile-time validation.",
      "signature": "class Builder<T extends object> { set<K extends keyof T>(key: K, value: T[K]): Builder<T>; build(): T }",
      "test_cases": [
        {
          "input": "new Builder<User>().set('name', 'Alice').set('age', 30).build()",
          "expected": "{ name: 'Alice', age: 30 }"
        }
      ],
      "constraints": [
        "Must validate property names at compile-time",
        "Must validate property types"
      ],
      "hints": [
        "Use generic constraints with keyof",
        "Return this for chaining"
      ],
      "solution_approach": "Generic builder with constraints",
      "time_complexity": "O(1) per operation",
      "space_complexity": "O(n)"
    },
    {
      "id": "typescript_hard_04",
      "name": "Type-Safe Event Sourcing",
      "difficulty": "hard",
      "category": "design_patterns",
      "description": "Implement a type-safe event sourcing system where state transitions are validated at compile-time.",
      "signature": "class EventStore<State, Events extends Record<string, (state: State) => State>>",
      "test_cases": [
        {
          "input": "Events for counter: increment, decrement, reset",
          "expected": "Only valid events accepted, state properly typed"
        }
      ],
      "constraints": [
        "Event handlers must return valid state",
        "Event types must be discriminated"
      ],
      "hints": [
        "Use mapped types for handlers",
        "Validate state transitions"
      ],
      "solution_approach": "Generic event store with constraints",
      "time_complexity": "O(1) per event",
      "space_complexity": "O(n) for history"
    },
    {
      "id": "typescript_hard_01",
      "name": "Advanced Mapped Types",
      "difficulty": "hard",
      "category": "type_system",
      "description": "Create a utility type that converts all function properties to their return types while preserving other properties.",
      "signature": "type UnwrapFunctions<T> = { [K in keyof T]: T[K] extends (...args: any[]) => infer R ? R : T[K] }",
      "test_cases": [
        {
          "input": "type User = { name: string; getName: () => string; age: number }",
          "expected": "type Unwrapped = { name: string; getName: string; age: number }"
        }
      ],
      "constraints": [
        "Must use conditional types",
        "Must preserve non-function properties"
      ],
      "hints": [
        "Use infer keyword",
        "Check if property extends function"
      ],
      "solution_approach": "Conditional mapped type with infer",
      "time_complexity": "N/A (compile-time)",
      "space_complexity": "N/A (compile-time)"
    },
    {
      "id": "typescript_hard_02",
      "name": "Type-Level String Manipulation",
      "difficulty": "hard",
      "category": "type_system",
      "description": "Create type utilities that manipulate strings at the type level (camelCase to snake_case).",
      "signature": "type CamelToSnake<S extends string> = S extends `${infer T}${infer U}` ? `${T extends Capitalize<T> ? '_' : ''}${Lowercase<T>}${CamelToSnake<U>}` : S",
      "test_cases": [
        {
          "input": "type Test = CamelToSnake<'userId'>",
          "expected": "type Test = 'user_id'"
        }
      ],
      "constraints": [
        "Must work recursively",
        "Must handle capitalization"
      ],
      "hints": [
        "Use template literal types",
        "Use recursive conditional types"
      ],
      "solution_approach": "Recursive template literal type",
      "time_complexity": "N/A (compile-time)",
      "space_complexity": "N/A (compile-time)"
    }
  ]
}