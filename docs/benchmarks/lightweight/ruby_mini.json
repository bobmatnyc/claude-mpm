{
  "agent_id": "ruby_engineer",
  "language": "ruby",
  "suite_type": "lightweight",
  "total_tests": 12,
  "difficulty_distribution": {
    "easy": 4,
    "medium": 5,
    "hard": 3
  },
  "category_coverage": [
    "performance",
    "functions",
    "string_manipulation",
    "metaprogramming",
    "testing",
    "idioms",
    "oop",
    "design_patterns",
    "rails",
    "algorithms"
  ],
  "source_suite": "expanded_v1",
  "version": "1.0.0",
  "tests": [
    {
      "id": "ruby_easy_01",
      "name": "Array Sum with Inject",
      "difficulty": "easy",
      "category": "algorithms",
      "description": "Calculate sum of array using Ruby's inject method.",
      "signature": "def array_sum(numbers)\n  # Return sum of array\nend",
      "test_cases": [
        {
          "input": "[1, 2, 3, 4, 5]",
          "expected": "15"
        },
        {
          "input": "[]",
          "expected": "0"
        }
      ],
      "constraints": [
        "Use inject/reduce",
        "Handle empty array"
      ],
      "hints": [
        "Use inject(:+) for concise sum",
        "Provide initial value for empty case"
      ],
      "solution_approach": "Functional reduction",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_easy_09",
      "name": "Default Parameter Values",
      "difficulty": "easy",
      "category": "functions",
      "description": "Create method with default parameter values.",
      "signature": "def repeat_string(str, times = 1)\n  # Repeat string specified times\nend",
      "test_cases": [
        {
          "input": "('hello', 3)",
          "expected": "hellohellohello"
        },
        {
          "input": "('hi')",
          "expected": "hi"
        }
      ],
      "constraints": [
        "Default times = 1",
        "Use string multiplication"
      ],
      "hints": [
        "Use default parameter syntax",
        "Use str * times"
      ],
      "solution_approach": "Default parameters",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "ruby_easy_10",
      "name": "Truthiness Check",
      "difficulty": "easy",
      "category": "idioms",
      "description": "Demonstrate Ruby's truthiness rules (only false and nil are falsy).",
      "signature": "def truthy?(value)\n  # Return if value is truthy in Ruby\nend",
      "test_cases": [
        {
          "input": "0",
          "expected": "true (0 is truthy in Ruby)"
        },
        {
          "input": "false",
          "expected": "false"
        },
        {
          "input": "nil",
          "expected": "false"
        }
      ],
      "constraints": [
        "Only false and nil are falsy",
        "Everything else is truthy"
      ],
      "hints": [
        "Use !! to convert to boolean",
        "Or use if/else"
      ],
      "solution_approach": "Ruby truthiness",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_easy_03",
      "name": "String Palindrome",
      "difficulty": "easy",
      "category": "string_manipulation",
      "description": "Check if string is palindrome using Ruby idioms.",
      "signature": "def palindrome?(str)\n  # Return true if palindrome\nend",
      "test_cases": [
        {
          "input": "racecar",
          "expected": "true"
        },
        {
          "input": "hello",
          "expected": "false"
        }
      ],
      "constraints": [
        "Case insensitive",
        "Ignore spaces"
      ],
      "hints": [
        "Use downcase and gsub",
        "Compare with reverse"
      ],
      "solution_approach": "String comparison",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "ruby_medium_06",
      "name": "Service Object Pattern",
      "difficulty": "medium",
      "category": "design_patterns",
      "description": "Create service object for complex business logic.",
      "signature": "class UserRegistrationService\n  def initialize(params)\n    @params = params\n  end\n  \n  def call\n    # Multi-step registration process\n  end\nend",
      "test_cases": [
        {
          "input": "UserRegistrationService.new(params).call",
          "expected": "User created, email sent, analytics tracked"
        }
      ],
      "constraints": [
        "Single responsibility",
        "Return result object"
      ],
      "hints": [
        "Use call method convention",
        "Wrap in transaction"
      ],
      "solution_approach": "Service object pattern",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_medium_01",
      "name": "Metaprogramming with Define Method",
      "difficulty": "medium",
      "category": "metaprogramming",
      "description": "Dynamically define methods using define_method.",
      "signature": "class DynamicMethods\n  [:first, :second, :third].each do |name|\n    # Define getter and setter for each\n  end\nend",
      "test_cases": [
        {
          "input": "obj.first = 'value'",
          "expected": "Dynamically created methods work"
        }
      ],
      "constraints": [
        "Use define_method",
        "Create getters and setters"
      ],
      "hints": [
        "Use define_method in loop",
        "Use instance variables"
      ],
      "solution_approach": "Dynamic method definition",
      "time_complexity": "O(1) per method",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_medium_03",
      "name": "Module Mixins",
      "difficulty": "medium",
      "category": "oop",
      "description": "Create module with both instance and class methods.",
      "signature": "module Timestampable\n  def self.included(base)\n    base.extend(ClassMethods)\n  end\n  module ClassMethods\n  end\nend",
      "test_cases": [
        {
          "input": "class Post; include Timestampable; end",
          "expected": "Both instance and class methods available"
        }
      ],
      "constraints": [
        "Use included hook",
        "Extend with ClassMethods"
      ],
      "hints": [
        "Use self.included callback",
        "Use extend for class methods"
      ],
      "solution_approach": "Module composition",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_medium_04",
      "name": "ActiveRecord Scope",
      "difficulty": "medium",
      "category": "rails",
      "description": "Create reusable ActiveRecord scopes for common queries.",
      "signature": "class User < ApplicationRecord\n  scope :active, -> { where(status: 'active') }\n  scope :recent, ->(days = 7) { where('created_at > ?', days.days.ago) }\nend",
      "test_cases": [
        {
          "input": "User.active.recent(30)",
          "expected": "Active users from last 30 days"
        }
      ],
      "constraints": [
        "Use scope method",
        "Chainable scopes"
      ],
      "hints": [
        "Use lambda for scope",
        "Scopes are chainable"
      ],
      "solution_approach": "ActiveRecord scopes",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "ruby_medium_07",
      "name": "RSpec Shared Examples",
      "difficulty": "medium",
      "category": "testing",
      "description": "Create shared examples for common behavior testing.",
      "signature": "RSpec.shared_examples 'a timestampable model' do\n  it 'has created_at' do\n    expect(subject).to respond_to(:created_at)\n  end\nend\n\nRSpec.describe User do\n  it_behaves_like 'a timestampable model'\nend",
      "test_cases": [
        {
          "input": "Multiple models with timestamps",
          "expected": "Shared tests reused"
        }
      ],
      "constraints": [
        "Use shared_examples",
        "Reusable test patterns"
      ],
      "hints": [
        "Define with shared_examples",
        "Include with it_behaves_like"
      ],
      "solution_approach": "Shared test patterns",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_hard_02",
      "name": "Decorator Pattern",
      "difficulty": "hard",
      "category": "design_patterns",
      "description": "Implement decorator pattern using SimpleDelegator or Forwardable.",
      "signature": "class UserDecorator < SimpleDelegator\n  def full_name\n    \"#{first_name} #{last_name}\"\n  end\n  \n  def formatted_created_at\n    created_at.strftime('%Y-%m-%d')\n  end\nend",
      "test_cases": [
        {
          "input": "UserDecorator.new(user).full_name",
          "expected": "Decorated methods available, original methods delegated"
        }
      ],
      "constraints": [
        "Use SimpleDelegator or Forwardable",
        "Transparent delegation"
      ],
      "hints": [
        "Inherit from SimpleDelegator",
        "Add presentation logic only"
      ],
      "solution_approach": "Decorator with delegation",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "ruby_hard_01",
      "name": "DSL Creation",
      "difficulty": "hard",
      "category": "metaprogramming",
      "description": "Create domain-specific language using metaprogramming.",
      "signature": "class Router\n  def self.route(&block)\n    instance_eval(&block)\n  end\n  \n  def self.get(path, &handler)\n    # Register GET route\n  end\nend\n\nRouter.route do\n  get '/users' do\n    # Handler code\n  end\nend",
      "test_cases": [
        {
          "input": "Define routes with DSL",
          "expected": "Routes registered and callable"
        }
      ],
      "constraints": [
        "Use instance_eval",
        "Clean DSL syntax"
      ],
      "hints": [
        "Use instance_eval for context",
        "Store routes in class variable"
      ],
      "solution_approach": "DSL with metaprogramming",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "id": "ruby_hard_05",
      "name": "YJIT Optimization Pattern",
      "difficulty": "hard",
      "category": "performance",
      "description": "Write code optimized for YJIT JIT compiler with consistent types and method shapes.",
      "signature": "class OptimizedCalculator\n  def calculate(x, y)\n    # Consistently typed method for YJIT\n    result = 0\n    100_000.times do\n      result += x * y\n    end\n    result\n  end\nend",
      "test_cases": [
        {
          "input": "Run with YJIT enabled",
          "expected": "Significant performance improvement"
        }
      ],
      "constraints": [
        "Consistent types",
        "Avoid megamorphic calls",
        "Hot path optimization"
      ],
      "hints": [
        "Keep method shapes consistent",
        "Avoid dynamic type changes",
        "Use local variables"
      ],
      "solution_approach": "YJIT-friendly code patterns",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    }
  ]
}