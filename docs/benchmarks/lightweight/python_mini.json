{
  "agent_id": "python_engineer",
  "language": "python",
  "suite_type": "lightweight",
  "total_tests": 12,
  "difficulty_distribution": {
    "easy": 4,
    "medium": 5,
    "hard": 3
  },
  "category_coverage": [
    "real_world",
    "string_manipulation",
    "data_structures",
    "algorithms",
    "async_programming"
  ],
  "source_suite": "expanded_v1",
  "version": "1.0.0",
  "tests": [
    {
      "id": "python_easy_01",
      "name": "Two Sum",
      "difficulty": "easy",
      "category": "algorithms",
      "description": "Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.",
      "signature": "def two_sum(nums: List[int], target: int) -> List[int]:",
      "test_cases": [
        {
          "input": "([2,7,11,15], 9)",
          "expected": "[0,1]",
          "explanation": "nums[0] + nums[1] == 9"
        },
        {
          "input": "([3,2,4], 6)",
          "expected": "[1,2]"
        },
        {
          "input": "([3,3], 6)",
          "expected": "[0,1]"
        }
      ],
      "constraints": [
        "2 <= nums.length <= 10^4",
        "Each input has exactly one solution"
      ],
      "hints": [
        "Use a hash map for O(n) solution",
        "Store seen numbers with indices"
      ],
      "solution_approach": "Hash map to track seen numbers",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "python_easy_02",
      "name": "Valid Parentheses",
      "difficulty": "easy",
      "category": "data_structures",
      "description": "Given a string containing just the characters '(', ')', '{', '}', '[' and ']', determine if the input string is valid. Brackets must close in correct order.",
      "signature": "def is_valid(s: str) -> bool:",
      "test_cases": [
        {
          "input": "()",
          "expected": "True"
        },
        {
          "input": "()[]{}",
          "expected": "True"
        },
        {
          "input": "(]",
          "expected": "False"
        },
        {
          "input": "([)]",
          "expected": "False"
        }
      ],
      "constraints": [
        "1 <= s.length <= 10^4"
      ],
      "hints": [
        "Use a stack data structure",
        "Match opening brackets with closing ones"
      ],
      "solution_approach": "Stack-based validation",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "python_easy_09",
      "name": "FizzBuzz",
      "difficulty": "easy",
      "category": "real_world",
      "description": "Given an integer n, return a string array where for multiples of 3 print 'Fizz', for multiples of 5 print 'Buzz', and for multiples of both print 'FizzBuzz'.",
      "signature": "def fizzbuzz(n: int) -> List[str]:",
      "test_cases": [
        {
          "input": "3",
          "expected": "['1','2','Fizz']"
        },
        {
          "input": "5",
          "expected": "['1','2','Fizz','4','Buzz']"
        },
        {
          "input": "15",
          "expected": "['1','2','Fizz','4','Buzz','Fizz','7','8','Fizz','Buzz','11','Fizz','13','14','FizzBuzz']"
        }
      ],
      "constraints": [
        "1 <= n <= 10^4"
      ],
      "hints": [
        "Check divisibility by 15 first",
        "Use modulo operator"
      ],
      "solution_approach": "Conditional checks with modulo",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "python_easy_05",
      "name": "Find First Palindromic String",
      "difficulty": "easy",
      "category": "string_manipulation",
      "description": "Given an array of strings words, return the first palindromic string in the array. If no such string exists, return an empty string.",
      "signature": "def first_palindrome(words: List[str]) -> str:",
      "test_cases": [
        {
          "input": "['abc','car','ada','racecar','cool']",
          "expected": "'ada'"
        },
        {
          "input": "['notapalindrome','racecar']",
          "expected": "'racecar'"
        },
        {
          "input": "['def','ghi']",
          "expected": "''"
        }
      ],
      "constraints": [
        "1 <= words.length <= 100",
        "1 <= words[i].length <= 100"
      ],
      "hints": [
        "Check if string equals its reverse",
        "Return immediately when found"
      ],
      "solution_approach": "Linear search with palindrome check",
      "time_complexity": "O(n * m)",
      "space_complexity": "O(1)"
    },
    {
      "id": "python_medium_02",
      "name": "Three Sum",
      "difficulty": "medium",
      "category": "algorithms",
      "description": "Given an integer array nums, return all unique triplets [nums[i], nums[j], nums[k]] such that i != j, i != k, and j != k, and nums[i] + nums[j] + nums[k] == 0.",
      "signature": "def three_sum(nums: List[int]) -> List[List[int]]:",
      "test_cases": [
        {
          "input": "[-1,0,1,2,-1,-4]",
          "expected": "[[-1,-1,2],[-1,0,1]]"
        },
        {
          "input": "[0,1,1]",
          "expected": "[]"
        },
        {
          "input": "[0,0,0]",
          "expected": "[[0,0,0]]"
        }
      ],
      "constraints": [
        "3 <= nums.length <= 3000"
      ],
      "hints": [
        "Sort array first",
        "Use two pointers for each fixed element"
      ],
      "solution_approach": "Sort + two pointers",
      "time_complexity": "O(n^2)",
      "space_complexity": "O(1)"
    },
    {
      "id": "python_medium_03",
      "name": "Longest Substring Without Repeating",
      "difficulty": "medium",
      "category": "algorithms",
      "description": "Given a string s, find the length of the longest substring without repeating characters.",
      "signature": "def length_of_longest_substring(s: str) -> int:",
      "test_cases": [
        {
          "input": "'abcabcbb'",
          "expected": "3",
          "explanation": "'abc' is the answer"
        },
        {
          "input": "'bbbbb'",
          "expected": "1"
        },
        {
          "input": "'pwwkew'",
          "expected": "3",
          "explanation": "'wke' is the answer"
        }
      ],
      "constraints": [
        "0 <= s.length <= 5 * 10^4"
      ],
      "hints": [
        "Use sliding window technique",
        "Track characters with set or dictionary"
      ],
      "solution_approach": "Sliding window with hash set",
      "time_complexity": "O(n)",
      "space_complexity": "O(min(n, m))"
    },
    {
      "id": "python_medium_06",
      "name": "Async Task Processor",
      "difficulty": "medium",
      "category": "async_programming",
      "description": "Implement an async task processor that runs multiple tasks concurrently with a maximum concurrency limit and returns results in order.",
      "signature": "async def process_tasks(tasks: List[Callable], max_concurrent: int) -> List[Any]:",
      "test_cases": [
        {
          "input": "([async_task1, async_task2, async_task3], 2)",
          "expected": "[result1, result2, result3]",
          "explanation": "Process at most 2 tasks concurrently"
        }
      ],
      "constraints": [
        "1 <= len(tasks) <= 100",
        "1 <= max_concurrent <= 10"
      ],
      "hints": [
        "Use asyncio.Semaphore for concurrency control",
        "Use asyncio.gather to collect results"
      ],
      "solution_approach": "Semaphore-based concurrency limiting",
      "time_complexity": "O(n / max_concurrent)",
      "space_complexity": "O(n)"
    },
    {
      "id": "python_medium_04",
      "name": "Binary Tree Level Order Traversal",
      "difficulty": "medium",
      "category": "data_structures",
      "description": "Given the root of a binary tree, return the level order traversal of its nodes' values (i.e., from left to right, level by level).",
      "signature": "def level_order(root: Optional[TreeNode]) -> List[List[int]]:",
      "test_cases": [
        {
          "input": "[3,9,20,null,null,15,7]",
          "expected": "[[3],[9,20],[15,7]]"
        },
        {
          "input": "[1]",
          "expected": "[[1]]"
        },
        {
          "input": "[]",
          "expected": "[]"
        }
      ],
      "constraints": [
        "Number of nodes is in range [0, 2000]"
      ],
      "hints": [
        "Use BFS with queue",
        "Process nodes level by level"
      ],
      "solution_approach": "Breadth-first search with queue",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    },
    {
      "id": "python_medium_10",
      "name": "Rate Limiter",
      "difficulty": "medium",
      "category": "real_world",
      "description": "Design a rate limiter that allows at most N requests per time window using sliding window algorithm.",
      "signature": "class RateLimiter:\n    def __init__(self, max_requests: int, window_seconds: int):\n    def allow_request(self, user_id: str) -> bool:",
      "test_cases": [
        {
          "input": "RateLimiter(3, 60) // 3 requests per 60 seconds",
          "expected": "True, True, True, False for 4 consecutive requests"
        }
      ],
      "constraints": [
        "1 <= max_requests <= 1000",
        "1 <= window_seconds <= 3600"
      ],
      "hints": [
        "Use deque to track request timestamps",
        "Remove old requests outside window"
      ],
      "solution_approach": "Sliding window with timestamp queue",
      "time_complexity": "O(n) per request",
      "space_complexity": "O(n * u)"
    },
    {
      "id": "python_hard_01",
      "name": "Median of Two Sorted Arrays",
      "difficulty": "hard",
      "category": "algorithms",
      "description": "Given two sorted arrays nums1 and nums2, return the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).",
      "signature": "def find_median_sorted_arrays(nums1: List[int], nums2: List[int]) -> float:",
      "test_cases": [
        {
          "input": "([1,3], [2])",
          "expected": "2.0"
        },
        {
          "input": "([1,2], [3,4])",
          "expected": "2.5"
        }
      ],
      "constraints": [
        "nums1.length + nums2.length >= 1",
        "Must be O(log(m+n)) complexity"
      ],
      "hints": [
        "Use binary search on smaller array",
        "Find correct partition point"
      ],
      "solution_approach": "Binary search on partition",
      "time_complexity": "O(log(min(m, n)))",
      "space_complexity": "O(1)"
    },
    {
      "id": "python_hard_05",
      "name": "Async Worker Pool with Retries",
      "difficulty": "hard",
      "category": "async_programming",
      "description": "Implement an async worker pool that processes tasks with configurable retry logic, exponential backoff, and graceful shutdown.",
      "signature": "class AsyncWorkerPool:\n    def __init__(self, num_workers: int, max_retries: int):\n    async def submit(self, task: Callable) -> Any:\n    async def shutdown(self) -> None:",
      "test_cases": [
        {
          "input": "AsyncWorkerPool(5, 3)",
          "expected": "Processes tasks with up to 3 retries and exponential backoff"
        }
      ],
      "constraints": [
        "1 <= num_workers <= 100",
        "0 <= max_retries <= 10"
      ],
      "hints": [
        "Use asyncio.Queue for task distribution",
        "Implement exponential backoff with asyncio.sleep",
        "Track worker states for graceful shutdown"
      ],
      "solution_approach": "Queue-based worker pool with retry logic",
      "time_complexity": "O(n / num_workers)",
      "space_complexity": "O(num_workers + queue_size)"
    },
    {
      "id": "python_hard_03",
      "name": "Serialize and Deserialize Binary Tree",
      "difficulty": "hard",
      "category": "data_structures",
      "description": "Design an algorithm to serialize and deserialize a binary tree. Serialization converts tree to string, deserialization converts string back to tree.",
      "signature": "class Codec:\n    def serialize(self, root: Optional[TreeNode]) -> str:\n    def deserialize(self, data: str) -> Optional[TreeNode]:",
      "test_cases": [
        {
          "input": "[1,2,3,null,null,4,5]",
          "expected": "[1,2,3,null,null,4,5]",
          "explanation": "Deserialize(serialize(tree)) == tree"
        }
      ],
      "constraints": [
        "Number of nodes is in range [0, 10^4]"
      ],
      "hints": [
        "Use preorder traversal",
        "Use delimiter and null marker"
      ],
      "solution_approach": "Preorder traversal with null markers",
      "time_complexity": "O(n)",
      "space_complexity": "O(n)"
    }
  ]
}