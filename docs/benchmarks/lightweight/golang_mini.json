{
  "agent_id": "golang_engineer",
  "language": "golang",
  "suite_type": "lightweight",
  "total_tests": 12,
  "difficulty_distribution": {
    "easy": 4,
    "medium": 5,
    "hard": 3
  },
  "category_coverage": [
    "error_handling",
    "performance",
    "real_world",
    "concurrency",
    "oop",
    "interfaces",
    "generics"
  ],
  "source_suite": "expanded_v1",
  "version": "1.0.0",
  "tests": [
    {
      "id": "go_easy_01",
      "name": "Simple Goroutine",
      "difficulty": "easy",
      "category": "concurrency",
      "description": "Launch goroutine to print numbers concurrently.",
      "signature": "func printNumbers(n int) {\n    // Print 1 to n using goroutine\n}",
      "test_cases": [
        {
          "input": "5",
          "expected": "Prints 1 2 3 4 5 (order may vary)"
        }
      ],
      "constraints": [
        "Use goroutine",
        "Use WaitGroup"
      ],
      "hints": [
        "Use go keyword",
        "Use sync.WaitGroup to wait"
      ],
      "solution_approach": "Basic goroutine with sync",
      "time_complexity": "O(n)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_easy_05",
      "name": "Error Handling",
      "difficulty": "easy",
      "category": "error_handling",
      "description": "Implement function with proper error handling.",
      "signature": "func divide(a, b float64) (float64, error) {\n    // Handle division by zero\n}",
      "test_cases": [
        {
          "input": "(10, 2)",
          "expected": "(5, nil)"
        },
        {
          "input": "(10, 0)",
          "expected": "(0, error)"
        }
      ],
      "constraints": [
        "Return error",
        "Use errors.New"
      ],
      "hints": [
        "Check for zero divisor",
        "Return errors.New()"
      ],
      "solution_approach": "Error return pattern",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_easy_04",
      "name": "Interface Implementation",
      "difficulty": "easy",
      "category": "interfaces",
      "description": "Implement simple interface.",
      "signature": "type Shape interface {\n    Area() float64\n}\n\ntype Circle struct {\n    radius float64\n}\n\nfunc (c Circle) Area() float64 {\n    // Implement Area\n}",
      "test_cases": [
        {
          "input": "Circle{radius: 5}",
          "expected": "Area: 78.54"
        }
      ],
      "constraints": [
        "Implement interface",
        "Implicit implementation"
      ],
      "hints": [
        "Define method matching interface",
        "No explicit implements keyword"
      ],
      "solution_approach": "Interface implementation",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_easy_03",
      "name": "Struct Methods",
      "difficulty": "easy",
      "category": "oop",
      "description": "Define struct with methods.",
      "signature": "type Rectangle struct {\n    width, height float64\n}\n\nfunc (r Rectangle) Area() float64 {\n    // Calculate area\n}",
      "test_cases": [
        {
          "input": "Rectangle{width: 5, height: 3}",
          "expected": "Area: 15"
        }
      ],
      "constraints": [
        "Use struct",
        "Define method"
      ],
      "hints": [
        "Define method with receiver",
        "Access struct fields"
      ],
      "solution_approach": "Struct with methods",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_medium_01",
      "name": "Worker Pool",
      "difficulty": "medium",
      "category": "concurrency",
      "description": "Implement worker pool pattern with goroutines.",
      "signature": "func workerPool(jobs <-chan int, results chan<- int, numWorkers int) {\n    // Create worker pool\n}",
      "test_cases": [
        {
          "input": "100 jobs, 5 workers",
          "expected": "All jobs processed concurrently"
        }
      ],
      "constraints": [
        "Fixed number of workers",
        "Process all jobs"
      ],
      "hints": [
        "Launch numWorkers goroutines",
        "Each reads from jobs channel"
      ],
      "solution_approach": "Worker pool with channels",
      "time_complexity": "O(n/w)",
      "space_complexity": "O(w)"
    },
    {
      "id": "go_medium_04",
      "name": "Custom Error Type",
      "difficulty": "medium",
      "category": "error_handling",
      "description": "Create custom error type with additional context.",
      "signature": "type ValidationError struct {\n    Field string\n    Message string\n}\n\nfunc (e *ValidationError) Error() string {\n    // Implement error interface\n}",
      "test_cases": [
        {
          "input": "Validation fails",
          "expected": "Custom error with field and message"
        }
      ],
      "constraints": [
        "Implement error interface",
        "Include context"
      ],
      "hints": [
        "Implement Error() string method",
        "Include field in struct"
      ],
      "solution_approach": "Custom error type",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_medium_05",
      "name": "Generic Stack",
      "difficulty": "medium",
      "category": "generics",
      "description": "Implement generic stack using Go generics.",
      "signature": "type Stack[T any] struct {\n    items []T\n}\n\nfunc (s *Stack[T]) Push(item T) {\n    // Push item\n}\n\nfunc (s *Stack[T]) Pop() (T, bool) {\n    // Pop item\n}",
      "test_cases": [
        {
          "input": "Push and pop integers",
          "expected": "Type-safe operations"
        }
      ],
      "constraints": [
        "Use generics",
        "Type-safe operations"
      ],
      "hints": [
        "Use [T any] syntax",
        "Return zero value on empty"
      ],
      "solution_approach": "Generic data structure",
      "time_complexity": "O(1) per operation",
      "space_complexity": "O(n)"
    },
    {
      "id": "go_medium_07",
      "name": "Interface Composition",
      "difficulty": "medium",
      "category": "interfaces",
      "description": "Compose interfaces for flexible abstractions.",
      "signature": "type Reader interface {\n    Read() ([]byte, error)\n}\n\ntype Writer interface {\n    Write([]byte) error\n}\n\ntype ReadWriter interface {\n    Reader\n    Writer\n}",
      "test_cases": [
        {
          "input": "Type implementing ReadWriter",
          "expected": "Satisfies both interfaces"
        }
      ],
      "constraints": [
        "Compose interfaces",
        "Implicit satisfaction"
      ],
      "hints": [
        "Embed interfaces",
        "Implement all methods"
      ],
      "solution_approach": "Interface composition",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    },
    {
      "id": "go_medium_10",
      "name": "HTTP Client with Timeout",
      "difficulty": "medium",
      "category": "real_world",
      "description": "Create HTTP client with context timeout.",
      "signature": "func fetchWithTimeout(url string, timeout time.Duration) ([]byte, error) {\n    // Fetch with timeout\n}",
      "test_cases": [
        {
          "input": "URL with 5 second timeout",
          "expected": "Cancel if exceeds timeout"
        }
      ],
      "constraints": [
        "Use context.WithTimeout",
        "Handle cancellation"
      ],
      "hints": [
        "Create request with context",
        "Use http.Client.Do()"
      ],
      "solution_approach": "HTTP with context timeout",
      "time_complexity": "O(1)",
      "space_complexity": "O(n)"
    },
    {
      "id": "go_hard_01",
      "name": "Pipeline Pattern",
      "difficulty": "hard",
      "category": "concurrency",
      "description": "Build multi-stage concurrent pipeline.",
      "signature": "func pipeline(nums []int) <-chan int {\n    // Stage 1: Generate\n    // Stage 2: Process\n    // Stage 3: Output\n}",
      "test_cases": [
        {
          "input": "Numbers through multi-stage pipeline",
          "expected": "Processed through all stages"
        }
      ],
      "constraints": [
        "Multiple stages",
        "Concurrent execution",
        "Proper cleanup"
      ],
      "hints": [
        "Each stage is goroutine",
        "Chain channels",
        "Close channels properly"
      ],
      "solution_approach": "Multi-stage pipeline",
      "time_complexity": "O(n)",
      "space_complexity": "O(stages)"
    },
    {
      "id": "go_hard_04",
      "name": "Memory Pool",
      "difficulty": "hard",
      "category": "performance",
      "description": "Implement object pool using sync.Pool.",
      "signature": "type BufferPool struct {\n    pool sync.Pool\n}\n\nfunc NewBufferPool() *BufferPool {\n    // Create pool with buffer allocation\n}",
      "test_cases": [
        {
          "input": "Allocate and reuse buffers",
          "expected": "Reduced allocations"
        }
      ],
      "constraints": [
        "Use sync.Pool",
        "Reset objects on return"
      ],
      "hints": [
        "Define New function",
        "Reset before putting back"
      ],
      "solution_approach": "Object pooling for performance",
      "time_complexity": "O(1)",
      "space_complexity": "O(pool_size)"
    },
    {
      "id": "go_hard_03",
      "name": "Graceful Shutdown",
      "difficulty": "hard",
      "category": "real_world",
      "description": "Implement graceful shutdown for HTTP server.",
      "signature": "func runServer(addr string) error {\n    // HTTP server with graceful shutdown\n}",
      "test_cases": [
        {
          "input": "SIGTERM signal",
          "expected": "Complete in-flight requests, then shutdown"
        }
      ],
      "constraints": [
        "Handle signals",
        "Complete in-flight requests",
        "Timeout for forceful shutdown"
      ],
      "hints": [
        "Listen for os.Signal",
        "Use server.Shutdown(ctx)",
        "Set timeout context"
      ],
      "solution_approach": "Signal-based graceful shutdown",
      "time_complexity": "O(1)",
      "space_complexity": "O(1)"
    }
  ]
}