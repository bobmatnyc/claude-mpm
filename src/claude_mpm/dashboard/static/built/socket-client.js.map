{"version":3,"file":"socket-client.js","sources":["../js/socket-client.js","../js/components/socket-manager.js","../js/components/ui-state-manager.js"],"sourcesContent":["/**\n * Socket.IO Client for Claude MPM Dashboard\n * \n * This module provides real-time WebSocket communication between the Claude MPM dashboard\n * and the backend Socket.IO server. It handles connection management, event processing,\n * retry logic, and health monitoring.\n * \n * Architecture:\n * - Maintains persistent WebSocket connection to Claude MPM backend\n * - Implements robust retry logic with exponential backoff\n * - Provides event queuing during disconnections\n * - Validates event schemas for data integrity\n * - Monitors connection health with ping/pong mechanisms\n * \n * Event Flow:\n * 1. Events from Claude Code hooks ‚Üí Socket.IO server ‚Üí Dashboard client\n * 2. Dashboard requests ‚Üí Socket.IO server ‚Üí Backend services\n * 3. Status updates ‚Üí Socket.IO server ‚Üí All connected clients\n * \n * Thread Safety:\n * - Single-threaded JavaScript execution model ensures safety\n * - Event callbacks are queued and executed sequentially\n * - Connection state changes are atomic\n * \n * Performance Considerations:\n * - Event queue limited to 100 items to prevent memory leaks\n * - Health checks run every 45s to match server ping interval\n * - Exponential backoff prevents connection spam\n * - Lazy event validation reduces overhead\n * \n * Security:\n * - Connects only to localhost to prevent external access\n * - Event schema validation prevents malformed data processing\n * - Connection timeout prevents hanging connections\n * \n * @author Claude MPM Team\n * @version 1.0\n * @since v4.0.25\n */\n\n// Access the global io from window object in ES6 module context\n// WHY: Socket.IO is loaded via CDN in HTML, available as window.io\nconst io = window.io;\n\n/**\n * Primary Socket.IO client for dashboard communication.\n * \n * Manages WebSocket connection lifecycle, event processing, and error handling.\n * Implements connection resilience with automatic retry and health monitoring.\n * \n * Key Features:\n * - Automatic connection retry with exponential backoff\n * - Event queue management during disconnections  \n * - Schema validation for incoming events\n * - Health monitoring with ping/pong\n * - Session management and event history\n * \n * Connection States:\n * - isConnected: Currently connected to server\n * - isConnecting: Connection attempt in progress\n * - disconnectTime: Timestamp of last disconnection\n * \n * Event Processing:\n * - Validates against schema before processing\n * - Queues events during disconnection (max 100)\n * - Maintains event history and session tracking\n * \n * @class SocketClient\n */\nclass SocketClient {\n    /**\n     * Initialize Socket.IO client with default configuration.\n     * \n     * Sets up connection management, event processing, and health monitoring.\n     * Configures retry logic and event queue management.\n     * \n     * WHY this initialization approach:\n     * - Lazy socket creation allows for port specification\n     * - Event queue prevents data loss during reconnections\n     * - Health monitoring detects server issues early\n     * - Schema validation ensures data integrity\n     * \n     * @constructor\n     */\n    constructor() {\n        /**\n         * Socket.IO connection instance.\n         * @type {Socket|null}\n         * @private\n         */\n        this.socket = null;\n        \n        /**\n         * Current connection port.\n         * @type {string|null}\n         * @private\n         */\n        this.port = null; // Store the current port\n        \n        /**\n         * Event callback registry for connection lifecycle events.\n         * WHY: Allows multiple components to register for connection events.\n         * @type {Object.<string, Function[]>}\n         * @private\n         */\n        this.connectionCallbacks = {\n            connect: [],    // Called on successful connection\n            disconnect: [], // Called on disconnection  \n            error: [],      // Called on connection errors\n            event: []       // Called on incoming events\n        };\n        \n        /**\n         * Event schema definition for validation.\n         * WHY: Ensures data integrity and prevents processing malformed events.\n         * @type {Object}\n         * @private\n         */\n        this.eventSchema = {\n            required: ['source', 'type', 'subtype', 'timestamp', 'data'],\n            optional: ['event', 'session_id']\n        };\n\n        /**\n         * Current connection state.\n         * @type {boolean}\n         * @private\n         */\n        this.isConnected = false;\n        \n        /**\n         * Connection attempt in progress flag.\n         * WHY: Prevents multiple simultaneous connection attempts.\n         * @type {boolean}\n         * @private\n         */\n        this.isConnecting = false;\n        \n        /**\n         * Timestamp of last successful connection.\n         * @type {number|null}\n         * @private\n         */\n        this.lastConnectTime = null;\n        \n        /**\n         * Timestamp of last disconnection.\n         * WHY: Used to calculate downtime and trigger reconnection logic.\n         * @type {number|null}\n         * @private\n         */\n        this.disconnectTime = null;\n\n        /**\n         * Event history storage.\n         * WHY: Maintains event history for dashboard display and analysis.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.events = [];\n        \n        /**\n         * Session tracking map.\n         * WHY: Groups events by session for better organization.\n         * @type {Map<string, Object>}\n         * @private\n         */\n        this.sessions = new Map();\n        \n        /**\n         * Current active session identifier.\n         * @type {string|null}\n         * @private\n         */\n        this.currentSessionId = null;\n\n        /**\n         * Event queue for disconnection periods.\n         * WHY: Prevents event loss during temporary disconnections.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.eventQueue = [];\n        \n        /**\n         * Maximum queue size to prevent memory leaks.\n         * WHY: Limits memory usage during extended disconnections.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.maxQueueSize = 100;\n        \n        /**\n         * Current retry attempt counter.\n         * WHY: Tracks retry attempts for exponential backoff logic.\n         * @type {number}\n         * @private\n         */\n        this.retryAttempts = 0;\n        \n        /**\n         * Maximum retry attempts before giving up.\n         * WHY: Prevents infinite retry loops that could impact performance.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.maxRetryAttempts = 5;  // Increased from 3 to 5 for better stability\n        \n        /**\n         * Retry delay intervals in milliseconds (exponential backoff).\n         * WHY: Prevents server overload during connection issues.\n         * @type {number[]}\n         * @private\n         * @const\n         */\n        this.retryDelays = [1000, 2000, 3000, 4000, 5000]; // Exponential backoff with 5 attempts\n        \n        /**\n         * Map of pending emissions for retry logic.\n         * WHY: Tracks failed emissions that need to be retried.\n         * @type {Map<string, Object>}\n         * @private\n         */\n        this.pendingEmissions = new Map(); // Track pending emissions for retry\n        \n        /**\n         * Timestamp of last ping sent to server.\n         * WHY: Used for health monitoring and connection validation.\n         * @type {number|null}\n         * @private\n         */\n        this.lastPingTime = null;\n        \n        /**\n         * Timestamp of last pong received from server.\n         * WHY: Confirms server is responsive and connection is healthy.\n         * @type {number|null}\n         * @private\n         */\n        this.lastPongTime = null;\n        \n        /**\n         * Health check timeout in milliseconds.\n         * WHY: More lenient than Socket.IO timeout to prevent false positives.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.pingTimeout = 120000; // 120 seconds for health check (more lenient for stability)\n        \n        /**\n         * Health check interval timer.\n         * @type {number|null}\n         * @private\n         */\n        this.healthCheckInterval = null;\n        \n        // Initialize background monitoring\n        this.startStatusCheckFallback();\n        this.startHealthMonitoring();\n    }\n\n    /**\n     * Connect to Socket.IO server on specified port.\n     * \n     * Initiates WebSocket connection to the Claude MPM Socket.IO server.\n     * Handles connection conflicts and ensures clean state transitions.\n     * \n     * Connection Process:\n     * 1. Validates port and constructs localhost URL\n     * 2. Checks for existing connections and cleans up if needed\n     * 3. Delegates to doConnect() for actual connection logic\n     * \n     * Thread Safety:\n     * - Uses setTimeout for async cleanup to prevent race conditions\n     * - Connection state flags prevent multiple simultaneous attempts\n     * \n     * @param {string} [port='8765'] - Port number to connect to (defaults to 8765)\n     * \n     * @throws {Error} If Socket.IO library is not loaded\n     * \n     * @example\n     * // Connect to default port\n     * socketClient.connect();\n     * \n     * // Connect to specific port\n     * socketClient.connect('8766');\n     */\n    connect(port = '8765') {\n        // Store the port for later use in reconnections\n        this.port = port;\n        const url = `http://localhost:${port}`;\n\n        // WHY this check: Prevents connection conflicts that can cause memory leaks\n        if (this.socket && (this.socket.connected || this.socket.connecting)) {\n            console.log('Already connected or connecting, disconnecting first...');\n            this.socket.disconnect();\n            // WHY 100ms delay: Allows cleanup to complete before new connection\n            setTimeout(() => this.doConnect(url), 100);\n            return;\n        }\n\n        this.doConnect(url);\n    }\n\n    /**\n     * Execute the actual Socket.IO connection with full configuration.\n     * \n     * Creates and configures Socket.IO client with appropriate timeouts,\n     * retry logic, and transport settings. Sets up event handlers for\n     * connection lifecycle management.\n     * \n     * Configuration Details:\n     * - autoConnect: true - Immediate connection attempt\n     * - reconnection: true - Built-in reconnection enabled\n     * - pingInterval: 25000ms - Matches server configuration\n     * - pingTimeout: 20000ms - Health check timeout\n     * - transports: ['websocket', 'polling'] - Fallback options\n     * \n     * WHY these settings:\n     * - Ping intervals must match server to prevent timeouts\n     * - Limited reconnection attempts prevent infinite loops\n     * - forceNew prevents socket reuse issues\n     * \n     * @param {string} url - Complete Socket.IO server URL (http://localhost:port)\n     * @private\n     * \n     * @throws {Error} If Socket.IO library is not available\n     */\n    doConnect(url) {\n        console.log(`Connecting to Socket.IO server at ${url}`);\n        \n        // Check if io is available\n        if (typeof io === 'undefined') {\n            console.error('Socket.IO library not loaded! Make sure socket.io.min.js is loaded before this script.');\n            this.notifyConnectionStatus('Socket.IO library not loaded', 'error');\n            return;\n        }\n        \n        this.isConnecting = true;\n        this.notifyConnectionStatus('Connecting...', 'connecting');\n\n        this.socket = io(url, {\n            autoConnect: true,\n            reconnection: true,\n            reconnectionDelay: 1000,\n            reconnectionDelayMax: 10000,  // Increased max delay for stability\n            reconnectionAttempts: 10,  // Increased attempts for better resilience  \n            timeout: 30000,  // Increased connection timeout to 30 seconds\n            forceNew: true,\n            transports: ['websocket', 'polling'],\n            pingInterval: 30000,  // Increased ping interval for stability\n            pingTimeout: 60000    // Much longer timeout for better stability\n        });\n\n        this.setupSocketHandlers();\n    }\n\n    /**\n     * Setup Socket.IO event handlers\n     */\n    setupSocketHandlers() {\n        this.socket.on('connect', () => {\n            console.log('Connected to Socket.IO server');\n            const previouslyConnected = this.isConnected;\n            this.isConnected = true;\n            this.isConnecting = false;\n            this.lastConnectTime = Date.now();\n            this.retryAttempts = 0; // Reset retry counter on successful connect\n            \n            // Calculate downtime if this is a reconnection\n            if (this.disconnectTime && previouslyConnected === false) {\n                const downtime = (Date.now() - this.disconnectTime) / 1000;\n                console.log(`Reconnected after ${downtime.toFixed(1)}s downtime`);\n                \n                // Flush queued events after reconnection\n                this.flushEventQueue();\n            }\n            \n            this.notifyConnectionStatus('Connected', 'connected');\n\n            // Expose socket globally for components that need direct access\n            window.socket = this.socket;\n            console.log('SocketClient: Exposed socket globally as window.socket');\n\n            // Emit connect callback\n            this.connectionCallbacks.connect.forEach(callback =>\n                callback(this.socket.id)\n            );\n\n            this.requestStatus();\n            // History is now automatically sent by server on connection\n            // No need to explicitly request it\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            // Enhanced logging for debugging disconnection issues\n            const disconnectInfo = {\n                reason: reason,\n                timestamp: new Date().toISOString(),\n                wasConnected: this.isConnected,\n                uptimeSeconds: this.lastConnectTime ? ((Date.now() - this.lastConnectTime) / 1000).toFixed(1) : 0,\n                lastPing: this.lastPingTime ? ((Date.now() - this.lastPingTime) / 1000).toFixed(1) + 's ago' : 'never',\n                lastPong: this.lastPongTime ? ((Date.now() - this.lastPongTime) / 1000).toFixed(1) + 's ago' : 'never'\n            };\n            \n            console.log('Disconnected from server:', disconnectInfo);\n            \n            this.isConnected = false;\n            this.isConnecting = false;\n            this.disconnectTime = Date.now();\n            \n            this.notifyConnectionStatus(`Disconnected: ${reason}`, 'disconnected');\n\n            // Emit disconnect callback\n            this.connectionCallbacks.disconnect.forEach(callback =>\n                callback(reason)\n            );\n            \n            // Detailed reason analysis for auto-reconnect decision\n            const reconnectReasons = [\n                'transport close',      // Network issue\n                'ping timeout',         // Server not responding\n                'transport error',      // Connection error\n                'io server disconnect', // Server initiated disconnect (might be restart)\n            ];\n            \n            if (reconnectReasons.includes(reason)) {\n                console.log(`Auto-reconnect triggered for reason: ${reason}`);\n                this.scheduleReconnect();\n            } else if (reason === 'io client disconnect') {\n                console.log('Client-initiated disconnect, not auto-reconnecting');\n            } else {\n                console.log(`Unknown disconnect reason: ${reason}, attempting reconnect anyway`);\n                this.scheduleReconnect();\n            }\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.isConnecting = false;\n            const errorMsg = error.message || error.description || 'Unknown error';\n            this.notifyConnectionStatus(`Connection Error: ${errorMsg}`, 'disconnected');\n\n            // Add error event\n            this.addEvent({\n                type: 'connection.error',\n                timestamp: new Date().toISOString(),\n                data: { \n                    error: errorMsg, \n                    url: this.socket.io.uri,\n                    retry_attempt: this.retryAttempts\n                }\n            });\n\n            // Emit error callback\n            this.connectionCallbacks.error.forEach(callback =>\n                callback(errorMsg)\n            );\n            \n            // Schedule reconnect with backoff\n            this.scheduleReconnect();\n        });\n\n        // Primary event handler - this is what the server actually emits\n        this.socket.on('claude_event', (data) => {\n            console.log('Received claude_event:', data);\n            \n            // Validate event schema\n            const validatedEvent = this.validateEventSchema(data);\n            if (!validatedEvent) {\n                console.warn('Invalid event schema received:', data);\n                return;\n            }\n            \n            // Code analysis events are now allowed to flow through to the events list for troubleshooting\n            // They will appear in both the Events tab and the Code tab\n            if (validatedEvent.type && validatedEvent.type.startsWith('code:')) {\n                console.log('Code analysis event received via claude_event, adding to events list for troubleshooting:', validatedEvent.type);\n            }\n            \n            // Transform event to match expected format (for backward compatibility)\n            const transformedEvent = this.transformEvent(validatedEvent);\n            console.log('Transformed event:', transformedEvent);\n            this.addEvent(transformedEvent);\n        });\n\n        // Add ping/pong handlers for health monitoring\n        this.socket.on('ping', (data) => {\n            // console.log('Received ping from server');\n            this.lastPingTime = Date.now();\n            \n            // Send pong response immediately\n            this.socket.emit('pong', { \n                timestamp: data.timestamp,\n                client_time: Date.now()\n            });\n        });\n        \n        // Track pong responses from server\n        this.socket.on('pong', (data) => {\n            this.lastPongTime = Date.now();\n            // console.log('Received pong from server');\n        });\n        \n        // Listen for heartbeat events from server (every 3 minutes)\n        this.socket.on('heartbeat', (data) => {\n            console.log('ü´Ä Received server heartbeat:', data);\n            // Add heartbeat to event list for visibility\n            this.addEvent({\n                type: 'system',\n                subtype: 'heartbeat',\n                timestamp: data.timestamp || new Date().toISOString(),\n                data: data\n            });\n            \n            // Update last ping time to indicate server is alive\n            this.lastPingTime = Date.now();\n            \n            // Log to console for debugging\n            console.log(`Server heartbeat #${data.heartbeat_number}: ${data.server_uptime_formatted} uptime, ${data.connected_clients} clients connected`);\n        });\n        \n        // Session and event handlers (legacy/fallback)\n        this.socket.on('session.started', (data) => {\n            this.addEvent({ type: 'session', subtype: 'started', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('session.ended', (data) => {\n            this.addEvent({ type: 'session', subtype: 'ended', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.request', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'request', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.response', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'response', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.loaded', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'loaded', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.executed', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'executed', timestamp: new Date().toISOString(), data });\n        });\n\n        // DISABLED: Legacy hook handlers - events now come through claude_event pathway\n        // to prevent duplication. Hook events are processed by the claude_event handler above.\n        // this.socket.on('hook.pre', (data) => {\n        //     this.addEvent({ type: 'hook', subtype: 'pre', timestamp: new Date().toISOString(), data });\n        // });\n\n        // this.socket.on('hook.post', (data) => {\n        //     this.addEvent({ type: 'hook', subtype: 'post', timestamp: new Date().toISOString(), data });\n        // });\n\n        this.socket.on('todo.updated', (data) => {\n            this.addEvent({ type: 'todo', subtype: 'updated', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('memory.operation', (data) => {\n            this.addEvent({ type: 'memory', subtype: 'operation', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('log.entry', (data) => {\n            this.addEvent({ type: 'log', subtype: 'entry', timestamp: new Date().toISOString(), data });\n        });\n\n        // Code analysis events - now allowed to flow through for troubleshooting\n        // These are ALSO handled by the code-tree component and shown in the footer\n        // They will appear in both places: Events tab (for troubleshooting) and Code tab (for visualization)\n        this.socket.on('code:analysis:queued', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis queued event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:queued', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:accepted', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis accepted event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:accepted', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:start', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis start event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:start', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:complete', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis complete event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:complete', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:error', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis error event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:error', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:file:start', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code file start event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'file:start', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:node:found', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code node found event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'node:found', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:progress', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis progress event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:progress', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('history', (data) => {\n            console.log('Received event history:', data);\n            if (data && Array.isArray(data.events)) {\n                console.log(`Processing ${data.events.length} historical events (${data.count} sent, ${data.total_available} total available)`);\n                // Add events in the order received (should already be chronological - oldest first)\n                // Transform each historical event to match expected format\n                data.events.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n                console.log(`Event history loaded: ${data.events.length} events added to dashboard`);\n            } else if (Array.isArray(data)) {\n                // Handle legacy format for backward compatibility\n                console.log('Received legacy event history format:', data.length, 'events');\n                data.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n            }\n        });\n\n        this.socket.on('system.status', (data) => {\n            console.log('Received system status:', data);\n            if (data.sessions) {\n                this.updateSessions(data.sessions);\n            }\n            if (data.current_session) {\n                this.currentSessionId = data.current_session;\n            }\n        });\n    }\n\n    /**\n     * Disconnect from Socket.IO server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.port = null; // Clear the stored port\n        this.isConnected = false;\n        this.isConnecting = false;\n    }\n\n    /**\n     * Emit an event with retry support\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     * @param {Object} options - Options for retry behavior\n     */\n    emitWithRetry(event, data = null, options = {}) {\n        const { \n            maxRetries = 3,\n            retryDelays = [1000, 2000, 4000],\n            onSuccess = null,\n            onFailure = null\n        } = options;\n        \n        const emissionId = `${event}_${Date.now()}_${Math.random()}`;\n        \n        const attemptEmission = (attemptNum = 0) => {\n            if (!this.socket || !this.socket.connected) {\n                // Queue for later if disconnected\n                if (attemptNum === 0) {\n                    this.queueEvent(event, data);\n                    console.log(`Queued ${event} for later emission (disconnected)`);\n                    if (onFailure) onFailure('disconnected');\n                }\n                return;\n            }\n            \n            try {\n                // Attempt emission\n                this.socket.emit(event, data);\n                console.log(`Emitted ${event} successfully`);\n                \n                // Remove from pending\n                this.pendingEmissions.delete(emissionId);\n                \n                if (onSuccess) onSuccess();\n                \n            } catch (error) {\n                console.error(`Failed to emit ${event} (attempt ${attemptNum + 1}):`, error);\n                \n                if (attemptNum < maxRetries - 1) {\n                    const delay = retryDelays[attemptNum] || retryDelays[retryDelays.length - 1];\n                    console.log(`Retrying ${event} in ${delay}ms...`);\n                    \n                    // Store pending emission\n                    this.pendingEmissions.set(emissionId, {\n                        event,\n                        data,\n                        attemptNum: attemptNum + 1,\n                        scheduledTime: Date.now() + delay\n                    });\n                    \n                    setTimeout(() => attemptEmission(attemptNum + 1), delay);\n                } else {\n                    console.error(`Failed to emit ${event} after ${maxRetries} attempts`);\n                    this.pendingEmissions.delete(emissionId);\n                    if (onFailure) onFailure('max_retries_exceeded');\n                }\n            }\n        };\n        \n        attemptEmission();\n    }\n    \n    /**\n     * Queue an event for later emission\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     */\n    queueEvent(event, data) {\n        if (this.eventQueue.length >= this.maxQueueSize) {\n            // Remove oldest event if queue is full\n            const removed = this.eventQueue.shift();\n            console.warn(`Event queue full, dropped oldest event: ${removed.event}`);\n        }\n        \n        this.eventQueue.push({\n            event,\n            data,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Flush queued events after reconnection\n     */\n    flushEventQueue() {\n        if (this.eventQueue.length === 0) return;\n        \n        console.log(`Flushing ${this.eventQueue.length} queued events...`);\n        const events = [...this.eventQueue];\n        this.eventQueue = [];\n        \n        // Emit each queued event with a small delay between them\n        events.forEach((item, index) => {\n            setTimeout(() => {\n                if (this.socket && this.socket.connected) {\n                    this.socket.emit(item.event, item.data);\n                    console.log(`Flushed queued event: ${item.event}`);\n                }\n            }, index * 100); // 100ms between each event\n        });\n    }\n    \n    /**\n     * Schedule a reconnection attempt with exponential backoff\n     */\n    scheduleReconnect() {\n        if (this.retryAttempts >= this.maxRetryAttempts) {\n            console.log('Max reconnection attempts reached, stopping auto-reconnect');\n            this.notifyConnectionStatus('Reconnection failed', 'disconnected');\n            return;\n        }\n        \n        const delay = this.retryDelays[this.retryAttempts] || this.retryDelays[this.retryDelays.length - 1];\n        this.retryAttempts++;\n        \n        console.log(`Scheduling reconnect attempt ${this.retryAttempts}/${this.maxRetryAttempts} in ${delay}ms...`);\n        this.notifyConnectionStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');\n        \n        setTimeout(() => {\n            if (!this.isConnected && this.port) {\n                console.log(`Attempting reconnection ${this.retryAttempts}/${this.maxRetryAttempts}...`);\n                this.connect(this.port);\n            }\n        }, delay);\n    }\n    \n    /**\n     * Request server status\n     */\n    requestStatus() {\n        if (this.socket && this.socket.connected) {\n            console.log('Requesting server status...');\n            this.emitWithRetry('request.status', null, {\n                maxRetries: 2,\n                retryDelays: [500, 1000]\n            });\n        }\n    }\n\n    /**\n     * Request event history from server\n     * @param {Object} options - History request options\n     * @param {number} options.limit - Maximum number of events to retrieve (default: 50)\n     * @param {Array<string>} options.event_types - Optional filter by event types\n     */\n    requestHistory(options = {}) {\n        if (this.socket && this.socket.connected) {\n            const params = {\n                limit: options.limit || 50,\n                event_types: options.event_types || []\n            };\n            console.log('Requesting event history...', params);\n            this.emitWithRetry('get_history', params, {\n                maxRetries: 3,\n                retryDelays: [1000, 2000, 3000],\n                onFailure: (reason) => {\n                    console.error(`Failed to request history: ${reason}`);\n                }\n            });\n        } else {\n            console.warn('Cannot request history: not connected to server');\n        }\n    }\n\n    /**\n     * Add event to local storage and notify listeners\n     * @param {Object} eventData - Event data\n     * @param {boolean} notify - Whether to notify listeners (default: true)\n     */\n    addEvent(eventData, notify = true) {\n        // Ensure event has required fields\n        if (!eventData.timestamp) {\n            eventData.timestamp = new Date().toISOString();\n        }\n        if (!eventData.id) {\n            eventData.id = Date.now() + Math.random();\n        }\n\n        this.events.push(eventData);\n\n        // Update session tracking\n        if (eventData.data && eventData.data.session_id) {\n            const sessionId = eventData.data.session_id;\n            if (!this.sessions.has(sessionId)) {\n                this.sessions.set(sessionId, {\n                    id: sessionId,\n                    startTime: eventData.timestamp,\n                    lastActivity: eventData.timestamp,\n                    eventCount: 0,\n                    working_directory: null,\n                    git_branch: null\n                });\n            }\n            const session = this.sessions.get(sessionId);\n            session.lastActivity = eventData.timestamp;\n            session.eventCount++;\n            \n            // Extract working directory from event data if available (prioritize newer data)\n            // Check multiple possible locations for working directory\n            const possiblePaths = [\n                eventData.data.cwd,\n                eventData.data.working_directory,\n                eventData.data.working_dir,\n                eventData.data.workingDirectory,\n                eventData.data.instance_info?.working_dir,\n                eventData.data.instance_info?.working_directory,\n                eventData.data.instance_info?.cwd,\n                eventData.cwd,\n                eventData.working_directory,\n                eventData.working_dir\n            ];\n            \n            for (const path of possiblePaths) {\n                if (path && typeof path === 'string' && path.trim()) {\n                    session.working_directory = path;\n                    console.log(`[SOCKET-CLIENT] Found working directory for session ${sessionId}:`, path);\n                    break;\n                }\n            }\n            \n            // Extract git branch if available\n            if (eventData.data.git_branch) {\n                session.git_branch = eventData.data.git_branch;\n            } else if (eventData.data.instance_info && eventData.data.instance_info.git_branch) {\n                session.git_branch = eventData.data.instance_info.git_branch;\n            }\n        }\n\n        if (notify) {\n            this.notifyEventUpdate();\n        }\n    }\n\n    /**\n     * Update sessions from server data\n     * @param {Array} sessionsData - Sessions data from server\n     */\n    updateSessions(sessionsData) {\n        if (Array.isArray(sessionsData)) {\n            sessionsData.forEach(session => {\n                this.sessions.set(session.id, session);\n            });\n        }\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.events = [];\n        this.sessions.clear();\n        this.notifyEventUpdate();\n    }\n\n    /**\n     * Clear events and request fresh history from server\n     * @param {Object} options - History request options (same as requestHistory)\n     */\n    refreshHistory(options = {}) {\n        this.clearEvents();\n        this.requestHistory(options);\n    }\n\n    /**\n     * Get filtered events by session\n     * @param {string} sessionId - Session ID to filter by (null for all)\n     * @returns {Array} Filtered events\n     */\n    getEventsBySession(sessionId = null) {\n        if (!sessionId) {\n            return this.events;\n        }\n        return this.events.filter(event =>\n            event.data && event.data.session_id === sessionId\n        );\n    }\n\n    /**\n     * Register callback for connection events\n     * @param {string} eventType - Type of event (connect, disconnect, error)\n     * @param {Function} callback - Callback function\n     */\n    onConnection(eventType, callback) {\n        if (this.connectionCallbacks[eventType]) {\n            this.connectionCallbacks[eventType].push(callback);\n        }\n    }\n\n    /**\n     * Register callback for event updates\n     * @param {Function} callback - Callback function\n     */\n    onEventUpdate(callback) {\n        this.connectionCallbacks.event.push(callback);\n    }\n\n    /**\n     * Subscribe to socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function\n     */\n    on(event, callback) {\n        if (this.socket) {\n            return this.socket.on(event, callback);\n        } else {\n            console.warn(`Cannot subscribe to '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Unsubscribe from socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function (optional)\n     */\n    off(event, callback) {\n        if (this.socket) {\n            return this.socket.off(event, callback);\n        } else {\n            console.warn(`Cannot unsubscribe from '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Notify connection status change\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    notifyConnectionStatus(status, type) {\n        console.log(`SocketClient: Connection status changed to '${status}' (${type})`);\n\n        // Direct DOM update - immediate and reliable\n        this.updateConnectionStatusDOM(status, type);\n\n        // Also dispatch custom event for other modules\n        document.dispatchEvent(new CustomEvent('socketConnectionStatus', {\n            detail: { status, type }\n        }));\n    }\n\n    /**\n     * Directly update the connection status DOM element\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    updateConnectionStatusDOM(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Update the text content while preserving the indicator span\n            statusElement.innerHTML = `<span>‚óè</span> ${status}`;\n\n            // Update the CSS class for styling\n            statusElement.className = `status-badge status-${type}`;\n\n            console.log(`SocketClient: Direct DOM update - status: '${status}' (${type})`);\n        } else {\n            console.warn('SocketClient: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Notify event update\n     */\n    notifyEventUpdate() {\n        this.connectionCallbacks.event.forEach(callback =>\n            callback(this.events, this.sessions)\n        );\n\n        // Also dispatch custom event\n        document.dispatchEvent(new CustomEvent('socketEventUpdate', {\n            detail: { events: this.events, sessions: this.sessions }\n        }));\n    }\n\n    /**\n     * Get connection state\n     * @returns {Object} Connection state\n     */\n    getConnectionState() {\n        return {\n            isConnected: this.isConnected,\n            isConnecting: this.isConnecting,\n            socketId: this.socket ? this.socket.id : null\n        };\n    }\n\n    /**\n     * Validate event against expected schema\n     * @param {Object} eventData - Raw event data\n     * @returns {Object|null} Validated event or null if invalid\n     */\n    validateEventSchema(eventData) {\n        if (!eventData || typeof eventData !== 'object') {\n            console.warn('Event data is not an object:', eventData);\n            return null;\n        }\n        \n        // Make a copy to avoid modifying the original\n        const validated = { ...eventData };\n        \n        // Check and provide defaults for required fields\n        if (!validated.source) {\n            validated.source = 'system';  // Default source for backward compatibility\n        }\n        if (!validated.type) {\n            // If there's an event field, use it as the type\n            if (validated.event) {\n                validated.type = validated.event;\n            } else {\n                validated.type = 'unknown';\n            }\n        }\n        if (!validated.subtype) {\n            validated.subtype = 'generic';\n        }\n        if (!validated.timestamp) {\n            validated.timestamp = new Date().toISOString();\n        }\n        if (!validated.data) {\n            validated.data = {};\n        }\n        \n        // Ensure data field is an object\n        if (validated.data && typeof validated.data !== 'object') {\n            validated.data = { value: validated.data };\n        }\n        \n        console.log('Validated event:', validated);\n        return validated;\n    }\n    \n    /**\n     * Transform received event to match expected dashboard format\n     * @param {Object} eventData - Raw event data from server\n     * @returns {Object} Transformed event\n     */\n    transformEvent(eventData) {\n        // Handle multiple event structures:\n        // 1. Hook events: { type: 'hook.pre_tool', timestamp: '...', data: {...} }\n        // 2. Legacy events: { event: 'TestStart', timestamp: '...', ... }\n        // 3. Standard events: { type: 'session', subtype: 'started', ... }\n        // 4. Normalized events: { type: 'code', subtype: 'progress', ... } - already normalized, keep as-is\n\n        if (!eventData) {\n            return eventData; // Return as-is if null/undefined\n        }\n\n        let transformedEvent = { ...eventData };\n\n        // Check if event is already normalized (has both type and subtype as separate fields)\n        // This prevents double-transformation of events that were normalized on the backend\n        const isAlreadyNormalized = eventData.type && eventData.subtype && \n                                   !eventData.type.includes('.') && \n                                   !eventData.type.includes(':');\n\n        if (isAlreadyNormalized) {\n            // Event is already properly normalized from backend, just preserve it\n            // Store a composite originalEventName for display if needed\n            if (!transformedEvent.originalEventName) {\n                if (eventData.subtype === 'generic' || eventData.type === eventData.subtype) {\n                    transformedEvent.originalEventName = eventData.type;\n                } else {\n                    transformedEvent.originalEventName = `${eventData.type}.${eventData.subtype}`;\n                }\n            }\n            // Return early to avoid further transformation\n        }\n        // Handle legacy format with 'event' field but no 'type'\n        else if (!eventData.type && eventData.event) {\n            // Map common event names to proper type/subtype\n            const eventName = eventData.event;\n            \n            // Check for known event patterns\n            if (eventName === 'TestStart' || eventName === 'TestEnd') {\n                transformedEvent.type = 'test';\n                transformedEvent.subtype = eventName.toLowerCase().replace('test', '');\n            } else if (eventName === 'SubagentStart' || eventName === 'SubagentStop') {\n                transformedEvent.type = 'subagent';\n                transformedEvent.subtype = eventName.toLowerCase().replace('subagent', '');\n            } else if (eventName === 'ToolCall') {\n                transformedEvent.type = 'tool';\n                transformedEvent.subtype = 'call';\n            } else if (eventName === 'UserPrompt') {\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = 'user_prompt';\n            } else {\n                // Generic fallback for unknown event names\n                // Use 'unknown' for type and the actual eventName for subtype\n                transformedEvent.type = 'unknown';\n                transformedEvent.subtype = eventName.toLowerCase();\n                \n                // Prevent duplicate type/subtype values\n                if (transformedEvent.type === transformedEvent.subtype) {\n                    transformedEvent.subtype = 'event';\n                }\n            }\n            \n            // Remove the 'event' field to avoid confusion\n            delete transformedEvent.event;\n            // Store original event name for display purposes\n            transformedEvent.originalEventName = eventName;\n        }\n        // Handle standard format with 'type' field that needs transformation\n        else if (eventData.type) {\n            const type = eventData.type;\n            \n            // Transform 'hook.subtype' format to separate type and subtype\n            if (type.startsWith('hook.')) {\n                const subtype = type.substring(5); // Remove 'hook.' prefix\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = subtype;\n                transformedEvent.originalEventName = type;\n            }\n            // Transform 'code:*' events to proper code type\n            // Handle multi-level subtypes like 'code:analysis:queued'\n            else if (type.startsWith('code:')) {\n                transformedEvent.type = 'code';\n                // Replace colons with underscores in subtype for consistency\n                const subtypePart = type.substring(5); // Remove 'code:' prefix\n                transformedEvent.subtype = subtypePart.replace(/:/g, '_');\n                transformedEvent.originalEventName = type;\n            }\n            // Transform other dotted types like 'session.started' -> type: 'session', subtype: 'started'\n            else if (type.includes('.')) {\n                const [mainType, ...subtypeParts] = type.split('.');\n                transformedEvent.type = mainType;\n                transformedEvent.subtype = subtypeParts.join('.');\n                transformedEvent.originalEventName = type;\n            }\n            // Transform any remaining colon-separated types generically\n            else if (type.includes(':')) {\n                const parts = type.split(':', 2); // Split into max 2 parts\n                transformedEvent.type = parts[0];\n                // Replace any remaining colons with underscores in subtype\n                transformedEvent.subtype = parts.length > 1 ? parts[1].replace(/:/g, '_') : 'generic';\n                transformedEvent.originalEventName = type;\n            }\n            // If type doesn't need transformation but has no subtype, set a default\n            else if (!eventData.subtype) {\n                transformedEvent.subtype = 'generic';\n                transformedEvent.originalEventName = type;\n            }\n        }\n        // If no type and no event field, mark as unknown\n        else {\n            transformedEvent.type = 'unknown';\n            transformedEvent.subtype = '';\n            transformedEvent.originalEventName = 'unknown';\n        }\n\n        // Extract and flatten data fields to top level for dashboard compatibility\n        // The dashboard expects fields like tool_name, agent_type, etc. at the top level\n        if (eventData.data && typeof eventData.data === 'object') {\n            // Protected fields that should never be overwritten by data fields\n            const protectedFields = ['type', 'subtype', 'timestamp', 'id', 'event', 'event_type', 'originalEventName'];\n            \n            // Copy all data fields to the top level, except protected ones\n            Object.keys(eventData.data).forEach(key => {\n                // Only copy if not a protected field\n                if (!protectedFields.includes(key)) {\n                    // Special handling for tool_parameters to ensure it's properly preserved\n                    // This is critical for file path extraction in file-tool-tracker\n                    if (key === 'tool_parameters' && typeof eventData.data[key] === 'object') {\n                        // Deep copy the tool_parameters object to preserve all nested fields\n                        transformedEvent[key] = JSON.parse(JSON.stringify(eventData.data[key]));\n                    } else {\n                        transformedEvent[key] = eventData.data[key];\n                    }\n                } else {\n                    // Log debug info if data field would overwrite a protected field\n                    // Only log for non-timestamp fields to reduce noise\n                    if (key !== 'timestamp') {\n                        console.debug(`Protected field '${key}' in data object was not copied to top level to preserve event structure`);\n                    }\n                }\n            });\n            \n            // Keep the original data object for backward compatibility\n            transformedEvent.data = eventData.data;\n        }\n\n        // Add hook_event_name for ActivityTree compatibility\n        // Map the type/subtype structure to the expected hook_event_name format\n        if (transformedEvent.type === 'hook') {\n            if (transformedEvent.subtype === 'pre_tool') {\n                transformedEvent.hook_event_name = 'PreToolUse';\n            } else if (transformedEvent.subtype === 'post_tool') {\n                transformedEvent.hook_event_name = 'PostToolUse';\n            } else if (transformedEvent.subtype === 'subagent_start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'subagent_stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            } else if (transformedEvent.subtype === 'todo_write') {\n                transformedEvent.hook_event_name = 'TodoWrite';\n            } else if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'Start';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'Stop';\n            }\n        } else if (transformedEvent.type === 'subagent') {\n            if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            }\n        } else if (transformedEvent.type === 'todo' && transformedEvent.subtype === 'updated') {\n            transformedEvent.hook_event_name = 'TodoWrite';\n        }\n\n        // Debug logging for tool events\n        if (transformedEvent.type === 'hook' && (transformedEvent.subtype === 'pre_tool' || transformedEvent.subtype === 'post_tool')) {\n            console.log('Transformed tool event:', {\n                type: transformedEvent.type,\n                subtype: transformedEvent.subtype,\n                hook_event_name: transformedEvent.hook_event_name,\n                tool_name: transformedEvent.tool_name,\n                has_tool_parameters: !!transformedEvent.tool_parameters,\n                tool_parameters: transformedEvent.tool_parameters,\n                has_data: !!transformedEvent.data,\n                keys: Object.keys(transformedEvent).filter(k => k !== 'data')\n            });\n            \n            // Extra debug logging for file-related tools\n            const fileTools = ['Read', 'Write', 'Edit', 'MultiEdit', 'NotebookEdit'];\n            if (fileTools.includes(transformedEvent.tool_name)) {\n                console.log('File tool event details:', {\n                    tool_name: transformedEvent.tool_name,\n                    file_path: transformedEvent.tool_parameters?.file_path,\n                    path: transformedEvent.tool_parameters?.path,\n                    notebook_path: transformedEvent.tool_parameters?.notebook_path,\n                    full_parameters: transformedEvent.tool_parameters\n                });\n            }\n        }\n\n        return transformedEvent;\n    }\n\n    /**\n     * Get current events and sessions\n     * @returns {Object} Current state\n     */\n    getState() {\n        return {\n            events: this.events,\n            sessions: this.sessions,\n            currentSessionId: this.currentSessionId\n        };\n    }\n\n    /**\n     * Start health monitoring\n     * Detects stale connections and triggers reconnection\n     */\n    startHealthMonitoring() {\n        this.healthCheckInterval = setInterval(() => {\n            if (this.isConnected && this.lastPingTime) {\n                const timeSinceLastPing = Date.now() - this.lastPingTime;\n                \n                if (timeSinceLastPing > this.pingTimeout) {\n                    console.warn(`No ping from server for ${timeSinceLastPing/1000}s, connection may be stale`);\n                    \n                    // Force reconnection\n                    if (this.socket) {\n                        console.log('Forcing reconnection due to stale connection...');\n                        this.socket.disconnect();\n                        setTimeout(() => {\n                            if (this.port) {\n                                this.connect(this.port);\n                            }\n                        }, 1000);\n                    }\n                }\n            }\n        }, 10000); // Check every 10 seconds\n    }\n    \n    /**\n     * Stop health monitoring\n     */\n    stopHealthMonitoring() {\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n            this.healthCheckInterval = null;\n        }\n    }\n    \n    /**\n     * Start periodic status check as fallback mechanism\n     * This ensures the UI stays in sync with actual socket state\n     */\n    startStatusCheckFallback() {\n        // Check status every 2 seconds\n        setInterval(() => {\n            this.checkAndUpdateStatus();\n        }, 2000);\n\n        // Initial check after DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => {\n                setTimeout(() => this.checkAndUpdateStatus(), 100);\n            });\n        } else {\n            setTimeout(() => this.checkAndUpdateStatus(), 100);\n        }\n    }\n\n    /**\n     * Check actual socket state and update UI if necessary\n     */\n    checkAndUpdateStatus() {\n        let actualStatus = 'Disconnected';\n        let actualType = 'disconnected';\n\n        if (this.socket) {\n            if (this.socket.connected) {\n                actualStatus = 'Connected';\n                actualType = 'connected';\n                this.isConnected = true;\n                this.isConnecting = false;\n            } else if (this.socket.connecting || this.isConnecting) {\n                actualStatus = 'Connecting...';\n                actualType = 'connecting';\n                this.isConnected = false;\n            } else {\n                actualStatus = 'Disconnected';\n                actualType = 'disconnected';\n                this.isConnected = false;\n                this.isConnecting = false;\n            }\n        }\n\n        // Check if UI needs updating\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            const currentText = statusElement.textContent.replace('‚óè', '').trim();\n            const currentClass = statusElement.className;\n            const expectedClass = `status-badge status-${actualType}`;\n\n            // Update if status text or class doesn't match\n            if (currentText !== actualStatus || currentClass !== expectedClass) {\n                console.log(`SocketClient: Fallback update - was '${currentText}' (${currentClass}), now '${actualStatus}' (${expectedClass})`);\n                this.updateConnectionStatusDOM(actualStatus, actualType);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.stopHealthMonitoring();\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.eventQueue = [];\n        this.pendingEmissions.clear();\n    }\n    \n    /**\n     * Get connection metrics\n     * @returns {Object} Connection metrics\n     */\n    getConnectionMetrics() {\n        return {\n            isConnected: this.isConnected,\n            uptime: this.lastConnectTime ? (Date.now() - this.lastConnectTime) / 1000 : 0,\n            lastPing: this.lastPingTime ? (Date.now() - this.lastPingTime) / 1000 : null,\n            queuedEvents: this.eventQueue.length,\n            pendingEmissions: this.pendingEmissions.size,\n            retryAttempts: this.retryAttempts\n        };\n    }\n}\n\n// ES6 Module export\nexport { SocketClient };\nexport default SocketClient;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.SocketClient = SocketClient;\n","/**\n * Socket Manager Module\n *\n * Handles all socket connection management, event dispatching, and connection state.\n * Provides a centralized interface for socket operations across the dashboard.\n *\n * WHY: Extracted from main dashboard to centralize socket connection logic and\n * provide better separation of concerns. This allows for easier testing and\n * maintenance of connection handling code.\n *\n * DESIGN DECISION: Acts as a wrapper around SocketClient to provide dashboard-specific\n * connection management while maintaining the existing SocketClient interface.\n * Uses event dispatching to notify other modules of connection state changes.\n */\n\n// Import SocketClient (assuming it will be converted to ES6 modules too)\nimport { SocketClient } from '../socket-client.js';\nclass SocketManager {\n    constructor() {\n        this.socketClient = null;\n        this.connectionCallbacks = new Set();\n        this.eventUpdateCallbacks = new Set();\n\n        // Initialize socket client\n        this.socketClient = new SocketClient();\n\n        // Make socketClient globally available (for backward compatibility)\n        window.socketClient = this.socketClient;\n\n        this.setupSocketEventHandlers();\n\n        // Force initial status update after a short delay to ensure DOM is ready\n        setTimeout(() => {\n            this.updateInitialConnectionStatus();\n        }, 100);\n\n        console.log('Socket manager initialized');\n    }\n\n    /**\n     * Set up socket event handlers for connection status and events\n     */\n    setupSocketEventHandlers() {\n        // Listen for connection status changes\n        document.addEventListener('socketConnectionStatus', (e) => {\n            console.log(`SocketManager: Processing connection status update: ${e.detail.status} (${e.detail.type})`);\n            this.handleConnectionStatusChange(e.detail.status, e.detail.type);\n\n            // Notify all registered callbacks\n            this.connectionCallbacks.forEach(callback => {\n                try {\n                    callback(e.detail.status, e.detail.type);\n                } catch (error) {\n                    console.error('Error in connection callback:', error);\n                }\n            });\n        });\n\n        // Set up event update handling\n        if (this.socketClient) {\n            this.socketClient.onEventUpdate((events) => {\n                // Notify all registered callbacks\n                this.eventUpdateCallbacks.forEach(callback => {\n                    try {\n                        callback(events);\n                    } catch (error) {\n                        console.error('Error in event update callback:', error);\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Handle connection status changes\n     * @param {string} status - Connection status text\n     * @param {string} type - Connection type ('connected', 'disconnected', etc.)\n     */\n    handleConnectionStatusChange(status, type) {\n        this.updateConnectionStatus(status, type);\n\n        // Set up git branch listener when connected\n        if (type === 'connected' && this.socketClient && this.socketClient.socket) {\n            // Expose socket globally for components like CodeTree\n            window.socket = this.socketClient.socket;\n            console.log('SocketManager: Exposed socket globally as window.socket');\n            \n            this.setupGitBranchListener();\n        }\n    }\n\n    /**\n     * Update initial connection status on dashboard load\n     */\n    updateInitialConnectionStatus() {\n        console.log('SocketManager: Updating initial connection status');\n\n        // Force status check on socket client (uses fallback mechanism)\n        if (this.socketClient && typeof this.socketClient.checkAndUpdateStatus === 'function') {\n            console.log('SocketManager: Using socket client checkAndUpdateStatus method');\n            this.socketClient.checkAndUpdateStatus();\n        } else if (this.socketClient && this.socketClient.socket) {\n            console.log('SocketManager: Checking socket state directly', {\n                connected: this.socketClient.socket.connected,\n                connecting: this.socketClient.socket.connecting,\n                isConnecting: this.socketClient.isConnecting,\n                isConnected: this.socketClient.isConnected\n            });\n\n            if (this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket is already connected, updating status');\n                // Expose socket globally for components like CodeTree\n                window.socket = this.socketClient.socket;\n                console.log('SocketManager: Exposed socket globally as window.socket');\n                this.updateConnectionStatus('Connected', 'connected');\n            } else if (this.socketClient.isConnecting || this.socketClient.socket.connecting) {\n                console.log('SocketManager: Socket is connecting, updating status');\n                this.updateConnectionStatus('Connecting...', 'connecting');\n            } else {\n                console.log('SocketManager: Socket is disconnected, updating status');\n                this.updateConnectionStatus('Disconnected', 'disconnected');\n            }\n        } else {\n            console.log('SocketManager: No socket client or socket found, setting disconnected status');\n            this.updateConnectionStatus('Disconnected', 'disconnected');\n        }\n\n        // Additional fallback - check again after a longer delay in case connection is still establishing\n        setTimeout(() => {\n            console.log('SocketManager: Secondary status check after 1 second');\n            if (this.socketClient && this.socketClient.socket && this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket connected in secondary check, updating status');\n                // Expose socket globally if not already done\n                if (!window.socket) {\n                    window.socket = this.socketClient.socket;\n                    console.log('SocketManager: Exposed socket globally as window.socket (secondary check)');\n                }\n                this.updateConnectionStatus('Connected', 'connected');\n            }\n        }, 1000);\n    }\n\n    /**\n     * Set up git branch response listener for connected socket\n     */\n    setupGitBranchListener() {\n        // Remove any existing listener first\n        this.socketClient.socket.off('git_branch_response');\n\n        // Add the listener\n        this.socketClient.socket.on('git_branch_response', (data) => {\n            if (data.success) {\n                const footerBranch = document.getElementById('footer-git-branch');\n                if (footerBranch) {\n                    footerBranch.textContent = data.branch || 'unknown';\n                }\n                if (footerBranch) {\n                    footerBranch.style.display = 'inline';\n                }\n            } else {\n                console.error('Git branch request failed:', data.error);\n            }\n        });\n    }\n\n    /**\n     * Update connection status display\n     * @param {string} status - Status text to display\n     * @param {string} type - Status type for styling\n     */\n    updateConnectionStatus(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Check if there's a span indicator first\n            const indicator = statusElement.querySelector('span');\n            if (indicator) {\n                // If there's a span, update the text content after the span\n                const statusIndicator = type === 'connected' ? '‚óè' : '‚óè';\n                statusElement.innerHTML = `<span>${statusIndicator}</span> ${status}`;\n            } else {\n                // If no span, just update text content\n                statusElement.textContent = status;\n            }\n\n            statusElement.className = `status-badge status-${type}`;\n            console.log(`SocketManager: UI updated - status: '${status}' (${type})`);\n        } else {\n            console.error('SocketManager: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Connect to socket server\n     * @param {number} port - Port number to connect to\n     */\n    connect(port) {\n        if (this.socketClient) {\n            this.socketClient.connect(port);\n        }\n    }\n\n    /**\n     * Disconnect from socket server\n     */\n    disconnect() {\n        if (this.socketClient) {\n            this.socketClient.disconnect();\n        }\n    }\n\n    /**\n     * Check if socket is connected\n     * @returns {boolean} - True if connected\n     */\n    isConnected() {\n        return this.socketClient && this.socketClient.isConnected;\n    }\n\n    /**\n     * Check if socket is connecting\n     * @returns {boolean} - True if connecting\n     */\n    isConnecting() {\n        return this.socketClient && this.socketClient.isConnecting;\n    }\n\n    /**\n     * Get the underlying socket client\n     * @returns {SocketClient} - The socket client instance\n     */\n    getSocketClient() {\n        return this.socketClient;\n    }\n\n    /**\n     * Get the raw socket connection\n     * @returns {Socket|null} - The raw socket or null\n     */\n    getSocket() {\n        return this.socketClient ? this.socketClient.socket : null;\n    }\n\n    /**\n     * Register a callback for connection status changes\n     * @param {Function} callback - Callback function(status, type)\n     */\n    onConnectionStatusChange(callback) {\n        this.connectionCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister a connection status callback\n     * @param {Function} callback - Callback to remove\n     */\n    offConnectionStatusChange(callback) {\n        this.connectionCallbacks.delete(callback);\n    }\n\n    /**\n     * Register a callback for event updates\n     * @param {Function} callback - Callback function(events)\n     */\n    onEventUpdate(callback) {\n        this.eventUpdateCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister an event update callback\n     * @param {Function} callback - Callback to remove\n     */\n    offEventUpdate(callback) {\n        this.eventUpdateCallbacks.delete(callback);\n    }\n\n    /**\n     * Toggle connection controls visibility\n     */\n    toggleConnectionControls() {\n        const controlsRow = document.getElementById('connection-controls-row');\n        const toggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (controlsRow && toggleBtn) {\n            const isVisible = controlsRow.classList.contains('show');\n\n            if (isVisible) {\n                controlsRow.classList.remove('show');\n                controlsRow.style.display = 'none';\n                toggleBtn.textContent = 'Connection Settings';\n            } else {\n                controlsRow.classList.add('show');\n                controlsRow.style.display = 'block';\n                toggleBtn.textContent = 'Hide Settings';\n            }\n        }\n    }\n\n    /**\n     * Setup connection control event handlers\n     * Called during dashboard initialization\n     */\n    setupConnectionControls() {\n        const connectBtn = document.getElementById('connect-btn');\n        const disconnectBtn = document.getElementById('disconnect-btn');\n        const connectionToggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (connectBtn) {\n            connectBtn.addEventListener('click', () => {\n                const port = document.getElementById('port-input').value || 8765;\n                this.connect(port);\n            });\n        }\n\n        if (disconnectBtn) {\n            disconnectBtn.addEventListener('click', () => {\n                this.disconnect();\n            });\n        }\n\n        if (connectionToggleBtn) {\n            connectionToggleBtn.addEventListener('click', () => {\n                this.toggleConnectionControls();\n            });\n        }\n    }\n\n    /**\n     * Initialize connection from URL parameters\n     * @param {URLSearchParams} params - URL search parameters\n     */\n    initializeFromURL(params) {\n        const port = params.get('port');\n        const portInput = document.getElementById('port-input');\n\n        // Determine the port to use:\n        // 1. URL parameter 'port'\n        // 2. Current page port (if served via HTTP)\n        // 3. Default port value from input field\n        // 4. Fallback to 8765\n        let connectPort = port;\n        if (!connectPort && window.location.protocol === 'http:') {\n            connectPort = window.location.port || '8765';\n        }\n        if (!connectPort) {\n            connectPort = portInput?.value || '8765';\n        }\n\n        // Update the port input field with the determined port\n        if (portInput) {\n            portInput.value = connectPort;\n        }\n\n        // Auto-connect by default unless explicitly disabled\n        // Changed: Always auto-connect by default even without URL params\n        const shouldAutoConnect = params.get('connect') !== 'false';\n        if (shouldAutoConnect && !this.isConnected() && !this.isConnecting()) {\n            console.log(`SocketManager: Auto-connecting to port ${connectPort}`);\n            this.connect(connectPort);\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketManager };\nexport default SocketManager;\n","/**\n * UI State Manager Module\n *\n * Manages UI state including tab switching, card selection, keyboard navigation,\n * and visual feedback across the dashboard interface.\n *\n * WHY: Extracted from main dashboard to centralize UI state management and\n * provide better separation between business logic and UI state. This makes\n * the UI behavior more predictable and easier to test.\n *\n * DESIGN DECISION: Maintains centralized state for current tab, selected cards,\n * and navigation context while providing a clean API for other modules to\n * interact with UI state changes.\n */\nclass UIStateManager {\n    constructor() {\n        // Current active tab\n        this.currentTab = 'events';\n\n        // Auto-scroll behavior\n        this.autoScroll = true;\n\n        // Selection state - tracks the currently selected card across all tabs\n        this.selectedCard = {\n            tab: null,        // which tab the selection is in\n            index: null,      // index of selected item in that tab\n            type: null,       // 'event', 'agent', 'tool', 'file'\n            data: null        // the actual data object\n        };\n\n        // Navigation state for each tab\n        this.tabNavigation = {\n            events: { selectedIndex: -1, items: [] },\n            agents: { selectedIndex: -1, items: [] },\n            tools: { selectedIndex: -1, items: [] },\n            files: { selectedIndex: -1, items: [] }\n        };\n\n        this.setupEventHandlers();\n        console.log('UI state manager initialized');\n    }\n\n    /**\n     * Set up event handlers for UI interactions\n     */\n    setupEventHandlers() {\n        this.setupTabNavigation();\n        this.setupUnifiedKeyboardNavigation();\n    }\n\n    /**\n     * Set up tab navigation event listeners\n     */\n    setupTabNavigation() {\n        // Tab buttons\n        document.querySelectorAll('.tab-button').forEach(button => {\n            button.addEventListener('click', () => {\n                const tabName = this.getTabNameFromButton(button);\n                this.switchTab(tabName);\n            });\n        });\n    }\n\n    /**\n     * Set up unified keyboard navigation across all tabs\n     */\n    setupUnifiedKeyboardNavigation() {\n        document.addEventListener('keydown', (e) => {\n            // Only handle if not in an input field\n            if (document.activeElement &&\n                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {\n                return;\n            }\n\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.handleUnifiedArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                this.handleUnifiedEnterKey();\n            } else if (e.key === 'Escape') {\n                this.clearUnifiedSelection();\n            }\n        });\n    }\n\n    /**\n     * Get tab name from button element\n     * @param {HTMLElement} button - Tab button element\n     * @returns {string} - Tab name\n     */\n    getTabNameFromButton(button) {\n        const text = button.textContent.toLowerCase();\n        if (text.includes('events')) return 'events';\n        if (text.includes('activity')) return 'activity';\n        if (text.includes('agents')) return 'agents';\n        if (text.includes('tools')) return 'tools';\n        if (text.includes('files')) return 'files';\n        if (text.includes('code')) return 'code';\n        if (text.includes('sessions')) return 'sessions';\n        if (text.includes('system')) return 'system';\n        return 'events';\n    }\n\n    /**\n     * Switch to specified tab\n     * @param {string} tabName - Name of tab to switch to\n     */\n    switchTab(tabName) {\n        console.log(`[DEBUG] switchTab called with tabName: ${tabName}`);\n        const previousTab = this.currentTab;\n        this.currentTab = tabName;\n\n        // Update tab button active states\n        document.querySelectorAll('.tab-button').forEach(btn => {\n            btn.classList.remove('active');\n            if (this.getTabNameFromButton(btn) === tabName) {\n                btn.classList.add('active');\n            }\n        });\n\n        // Show/hide tab content using CSS classes\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n\n        const activeTab = document.getElementById(`${tabName}-tab`);\n        if (activeTab) {\n            activeTab.classList.add('active');\n        }\n\n        // Clear previous selections when switching tabs\n        this.clearUnifiedSelection();\n\n        // Trigger tab change event for other modules\n        document.dispatchEvent(new CustomEvent('tabChanged', {\n            detail: {\n                newTab: tabName,\n                previousTab: previousTab\n            }\n        }));\n\n        // Auto-scroll to bottom after a brief delay to ensure content is rendered\n        setTimeout(() => {\n            if (this.autoScroll) {\n                this.scrollCurrentTabToBottom();\n            }\n        }, 100);\n    }\n\n    /**\n     * Handle unified arrow navigation across tabs\n     * @param {number} direction - Navigation direction (1 for down, -1 for up)\n     */\n    handleUnifiedArrowNavigation(direction) {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let newIndex = tabNav.selectedIndex + direction;\n\n        // Handle bounds\n        if (tabNav.items.length === 0) return;\n\n        if (newIndex < 0) {\n            newIndex = tabNav.items.length - 1;\n        } else if (newIndex >= tabNav.items.length) {\n            newIndex = 0;\n        }\n\n        this.selectCardByIndex(this.currentTab, newIndex);\n    }\n\n    /**\n     * Handle unified Enter key across all tabs\n     */\n    handleUnifiedEnterKey() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav || tabNav.selectedIndex === -1) return;\n\n        const selectedElement = tabNav.items[tabNav.selectedIndex];\n        if (selectedElement && selectedElement.onclick) {\n            selectedElement.onclick();\n        }\n    }\n\n    /**\n     * Clear all unified selection states\n     */\n    clearUnifiedSelection() {\n        // Clear all tab navigation states\n        Object.keys(this.tabNavigation).forEach(tabName => {\n            this.tabNavigation[tabName].selectedIndex = -1;\n        });\n\n        // Clear card selection\n        this.clearCardSelection();\n    }\n\n    /**\n     * Update tab navigation items for current tab\n     * Should be called after tab content is rendered\n     */\n    updateTabNavigationItems() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let containerSelector;\n        switch (this.currentTab) {\n            case 'events':\n                containerSelector = '#events-list .event-item';\n                break;\n            case 'agents':\n                containerSelector = '#agents-list .event-item';\n                break;\n            case 'tools':\n                containerSelector = '#tools-list .event-item';\n                break;\n            case 'files':\n                containerSelector = '#files-list .event-item';\n                break;\n        }\n\n        if (containerSelector) {\n            tabNav.items = Array.from(document.querySelectorAll(containerSelector));\n        }\n    }\n\n    /**\n     * Select card by index for specified tab\n     * @param {string} tabName - Tab name\n     * @param {number} index - Index of item to select\n     */\n    selectCardByIndex(tabName, index) {\n        const tabNav = this.tabNavigation[tabName];\n        if (!tabNav || index < 0 || index >= tabNav.items.length) return;\n\n        // Update navigation state\n        tabNav.selectedIndex = index;\n\n        // Update visual selection\n        this.updateUnifiedSelectionUI();\n\n        // If this is a different tab selection, record the card selection\n        const selectedElement = tabNav.items[index];\n        if (selectedElement) {\n            // Extract data from the element to populate selectedCard\n            this.selectCard(tabName, index, this.getCardType(tabName), index);\n        }\n\n        // Show details for the selected item\n        this.showCardDetails(tabName, index);\n    }\n\n    /**\n     * Update visual selection UI for unified navigation\n     */\n    updateUnifiedSelectionUI() {\n        // Clear all existing selections\n        document.querySelectorAll('.event-item.keyboard-selected').forEach(el => {\n            el.classList.remove('keyboard-selected');\n        });\n\n        // Apply selection to current tab's selected item\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (tabNav && tabNav.selectedIndex !== -1 && tabNav.items[tabNav.selectedIndex]) {\n            tabNav.items[tabNav.selectedIndex].classList.add('keyboard-selected');\n        }\n    }\n\n    /**\n     * Show card details for specified tab and index\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     */\n    showCardDetails(tabName, index) {\n        // Dispatch event for other modules to handle\n        document.dispatchEvent(new CustomEvent('showCardDetails', {\n            detail: {\n                tabName: tabName,\n                index: index\n            }\n        }));\n    }\n\n    /**\n     * Select a specific card\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     * @param {string} type - Item type\n     * @param {*} data - Item data\n     */\n    selectCard(tabName, index, type, data) {\n        // Clear previous selection\n        this.clearCardSelection();\n\n        // Update selection state\n        this.selectedCard = {\n            tab: tabName,\n            index: index,\n            type: type,\n            data: data\n        };\n\n        this.updateCardSelectionUI();\n\n        console.log('Card selected:', this.selectedCard);\n    }\n\n    /**\n     * Clear card selection\n     */\n    clearCardSelection() {\n        // Clear visual selection from all tabs\n        document.querySelectorAll('.event-item.selected, .file-item.selected').forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Reset selection state\n        this.selectedCard = {\n            tab: null,\n            index: null,\n            type: null,\n            data: null\n        };\n    }\n\n    /**\n     * Update card selection UI\n     */\n    updateCardSelectionUI() {\n        if (!this.selectedCard.tab || this.selectedCard.index === null) return;\n\n        // Get the list container for the selected tab\n        let listContainer;\n        switch (this.selectedCard.tab) {\n            case 'events':\n                listContainer = document.getElementById('events-list');\n                break;\n            case 'agents':\n                listContainer = document.getElementById('agents-list');\n                break;\n            case 'tools':\n                listContainer = document.getElementById('tools-list');\n                break;\n            case 'files':\n                listContainer = document.getElementById('files-list');\n                break;\n        }\n\n        if (listContainer) {\n            const items = listContainer.querySelectorAll('.event-item, .file-item');\n            if (items[this.selectedCard.index]) {\n                items[this.selectedCard.index].classList.add('selected');\n            }\n        }\n    }\n\n    /**\n     * Get card type based on tab name\n     * @param {string} tabName - Tab name\n     * @returns {string} - Card type\n     */\n    getCardType(tabName) {\n        switch (tabName) {\n            case 'events': return 'event';\n            case 'agents': return 'agent';\n            case 'tools': return 'tool';\n            case 'files': return 'file';\n            default: return 'unknown';\n        }\n    }\n\n    /**\n     * Scroll current tab to bottom\n     */\n    scrollCurrentTabToBottom() {\n        const tabId = `${this.currentTab}-list`;\n        const element = document.getElementById(tabId);\n        if (element && this.autoScroll) {\n            element.scrollTop = element.scrollHeight;\n        }\n    }\n\n    /**\n     * Clear selection for cleanup\n     */\n    clearSelection() {\n        this.clearCardSelection();\n        this.clearUnifiedSelection();\n    }\n\n    /**\n     * Get current tab name\n     * @returns {string} - Current tab name\n     */\n    getCurrentTab() {\n        return this.currentTab;\n    }\n\n    /**\n     * Get selected card info\n     * @returns {Object} - Selected card state\n     */\n    getSelectedCard() {\n        return { ...this.selectedCard };\n    }\n\n    /**\n     * Get tab navigation state\n     * @returns {Object} - Tab navigation state\n     */\n    getTabNavigation() {\n        return { ...this.tabNavigation };\n    }\n\n    /**\n     * Set auto-scroll behavior\n     * @param {boolean} enabled - Whether to enable auto-scroll\n     */\n    setAutoScroll(enabled) {\n        this.autoScroll = enabled;\n    }\n\n    /**\n     * Get auto-scroll state\n     * @returns {boolean} - Auto-scroll enabled state\n     */\n    getAutoScroll() {\n        return this.autoScroll;\n    }\n}\n// ES6 Module export\nexport { UIStateManager };\nexport default UIStateManager;\n"],"names":["io","window","SocketClient","constructor","this","socket","port","connectionCallbacks","connect","disconnect","error","event","eventSchema","required","optional","isConnected","isConnecting","lastConnectTime","disconnectTime","events","sessions","Map","currentSessionId","eventQueue","maxQueueSize","retryAttempts","maxRetryAttempts","retryDelays","pendingEmissions","lastPingTime","lastPongTime","pingTimeout","healthCheckInterval","startStatusCheckFallback","startHealthMonitoring","url","connected","connecting","console","log","setTimeout","doConnect","notifyConnectionStatus","autoConnect","reconnection","reconnectionDelay","reconnectionDelayMax","reconnectionAttempts","timeout","forceNew","transports","pingInterval","setupSocketHandlers","on","previouslyConnected","Date","now","downtime","toFixed","flushEventQueue","forEach","callback","id","requestStatus","reason","disconnectInfo","timestamp","toISOString","wasConnected","uptimeSeconds","lastPing","lastPong","includes","scheduleReconnect","errorMsg","message","description","addEvent","type","data","uri","retry_attempt","validatedEvent","validateEventSchema","warn","startsWith","transformedEvent","transformEvent","emit","client_time","subtype","heartbeat_number","server_uptime_formatted","connected_clients","Array","isArray","length","count","total_available","notifyEventUpdate","updateSessions","current_session","emitWithRetry","options","maxRetries","onSuccess","onFailure","emissionId","Math","random","attemptEmission","attemptNum","delete","delay","set","scheduledTime","queueEvent","removed","shift","push","item","index","requestHistory","params","limit","event_types","eventData","notify","session_id","sessionId","has","startTime","lastActivity","eventCount","working_directory","git_branch","session","get","possiblePaths","cwd","working_dir","workingDirectory","instance_info","path","trim","sessionsData","clearEvents","clear","refreshHistory","getEventsBySession","filter","onConnection","eventType","onEventUpdate","off","status","updateConnectionStatusDOM","document","dispatchEvent","CustomEvent","detail","statusElement","getElementById","innerHTML","className","getConnectionState","socketId","validated","source","value","originalEventName","eventName","toLowerCase","replace","substring","subtypePart","mainType","subtypeParts","split","join","parts","protectedFields","Object","keys","key","debug","JSON","parse","stringify","hook_event_name","tool_name","has_tool_parameters","tool_parameters","has_data","k","file_path","notebook_path","full_parameters","getState","setInterval","timeSinceLastPing","stopHealthMonitoring","clearInterval","checkAndUpdateStatus","readyState","addEventListener","actualStatus","actualType","currentText","textContent","currentClass","expectedClass","destroy","getConnectionMetrics","uptime","queuedEvents","size","SocketManager","socketClient","Set","eventUpdateCallbacks","setupSocketEventHandlers","updateInitialConnectionStatus","e","handleConnectionStatusChange","updateConnectionStatus","setupGitBranchListener","success","footerBranch","branch","style","display","querySelector","statusIndicator","getSocketClient","getSocket","onConnectionStatusChange","add","offConnectionStatusChange","offEventUpdate","toggleConnectionControls","controlsRow","toggleBtn","classList","contains","remove","setupConnectionControls","connectBtn","disconnectBtn","connectionToggleBtn","initializeFromURL","portInput","connectPort","location","protocol","UIStateManager","currentTab","autoScroll","selectedCard","tab","tabNavigation","selectedIndex","items","agents","tools","files","setupEventHandlers","setupTabNavigation","setupUnifiedKeyboardNavigation","querySelectorAll","button","tabName","getTabNameFromButton","switchTab","activeElement","tagName","preventDefault","handleUnifiedArrowNavigation","handleUnifiedEnterKey","clearUnifiedSelection","text","previousTab","btn","content","activeTab","newTab","scrollCurrentTabToBottom","direction","tabNav","newIndex","selectCardByIndex","selectedElement","onclick","clearCardSelection","updateTabNavigationItems","containerSelector","from","updateUnifiedSelectionUI","selectCard","getCardType","showCardDetails","el","updateCardSelectionUI","listContainer","tabId","element","scrollTop","scrollHeight","clearSelection","getCurrentTab","getSelectedCard","getTabNavigation","setAutoScroll","enabled","getAutoScroll"],"mappings":"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"}