{"version":3,"file":"socket-client.js","sources":["../js/socket-client.js","../js/components/socket-manager.js","../js/components/ui-state-manager.js"],"sourcesContent":["/**\n * Socket.IO Client for Claude MPM Dashboard\n * \n * This module provides real-time WebSocket communication between the Claude MPM dashboard\n * and the backend Socket.IO server. It handles connection management, event processing,\n * retry logic, and health monitoring.\n * \n * Architecture:\n * - Maintains persistent WebSocket connection to Claude MPM backend\n * - Implements robust retry logic with exponential backoff\n * - Provides event queuing during disconnections\n * - Validates event schemas for data integrity\n * - Monitors connection health with ping/pong mechanisms\n * \n * Event Flow:\n * 1. Events from Claude Code hooks → Socket.IO server → Dashboard client\n * 2. Dashboard requests → Socket.IO server → Backend services\n * 3. Status updates → Socket.IO server → All connected clients\n * \n * Thread Safety:\n * - Single-threaded JavaScript execution model ensures safety\n * - Event callbacks are queued and executed sequentially\n * - Connection state changes are atomic\n * \n * Performance Considerations:\n * - Event queue limited to 100 items to prevent memory leaks\n * - Health checks run every 45s to match server ping interval\n * - Exponential backoff prevents connection spam\n * - Lazy event validation reduces overhead\n * \n * Security:\n * - Connects only to localhost to prevent external access\n * - Event schema validation prevents malformed data processing\n * - Connection timeout prevents hanging connections\n * \n * @author Claude MPM Team\n * @version 1.0\n * @since v4.0.25\n */\n\n// Access the global io from window object in ES6 module context\n// WHY: Socket.IO is loaded via CDN in HTML, available as window.io\nconst io = window.io;\n\n/**\n * Primary Socket.IO client for dashboard communication.\n * \n * Manages WebSocket connection lifecycle, event processing, and error handling.\n * Implements connection resilience with automatic retry and health monitoring.\n * \n * Key Features:\n * - Automatic connection retry with exponential backoff\n * - Event queue management during disconnections  \n * - Schema validation for incoming events\n * - Health monitoring with ping/pong\n * - Session management and event history\n * \n * Connection States:\n * - isConnected: Currently connected to server\n * - isConnecting: Connection attempt in progress\n * - disconnectTime: Timestamp of last disconnection\n * \n * Event Processing:\n * - Validates against schema before processing\n * - Queues events during disconnection (max 100)\n * - Maintains event history and session tracking\n * \n * @class SocketClient\n */\nclass SocketClient {\n    /**\n     * Initialize Socket.IO client with default configuration.\n     * \n     * Sets up connection management, event processing, and health monitoring.\n     * Configures retry logic and event queue management.\n     * \n     * WHY this initialization approach:\n     * - Lazy socket creation allows for port specification\n     * - Event queue prevents data loss during reconnections\n     * - Health monitoring detects server issues early\n     * - Schema validation ensures data integrity\n     * \n     * @constructor\n     */\n    constructor() {\n        /**\n         * Socket.IO connection instance.\n         * @type {Socket|null}\n         * @private\n         */\n        this.socket = null;\n        \n        /**\n         * Current connection port.\n         * @type {string|null}\n         * @private\n         */\n        this.port = null; // Store the current port\n        \n        /**\n         * Event callback registry for connection lifecycle events.\n         * WHY: Allows multiple components to register for connection events.\n         * @type {Object.<string, Function[]>}\n         * @private\n         */\n        this.connectionCallbacks = {\n            connect: [],    // Called on successful connection\n            disconnect: [], // Called on disconnection  \n            error: [],      // Called on connection errors\n            event: []       // Called on incoming events\n        };\n        \n        /**\n         * Event schema definition for validation.\n         * WHY: Ensures data integrity and prevents processing malformed events.\n         * @type {Object}\n         * @private\n         */\n        this.eventSchema = {\n            required: ['source', 'type', 'subtype', 'timestamp', 'data'],\n            optional: ['event', 'session_id']\n        };\n\n        /**\n         * Current connection state.\n         * @type {boolean}\n         * @private\n         */\n        this.isConnected = false;\n        \n        /**\n         * Connection attempt in progress flag.\n         * WHY: Prevents multiple simultaneous connection attempts.\n         * @type {boolean}\n         * @private\n         */\n        this.isConnecting = false;\n        \n        /**\n         * Timestamp of last successful connection.\n         * @type {number|null}\n         * @private\n         */\n        this.lastConnectTime = null;\n        \n        /**\n         * Timestamp of last disconnection.\n         * WHY: Used to calculate downtime and trigger reconnection logic.\n         * @type {number|null}\n         * @private\n         */\n        this.disconnectTime = null;\n\n        /**\n         * Event history storage.\n         * WHY: Maintains event history for dashboard display and analysis.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.events = [];\n        \n        /**\n         * Session tracking map.\n         * WHY: Groups events by session for better organization.\n         * @type {Map<string, Object>}\n         * @private\n         */\n        this.sessions = new Map();\n        \n        /**\n         * Current active session identifier.\n         * @type {string|null}\n         * @private\n         */\n        this.currentSessionId = null;\n\n        /**\n         * Event queue for disconnection periods.\n         * WHY: Prevents event loss during temporary disconnections.\n         * @type {Array.<Object>}\n         * @private\n         */\n        this.eventQueue = [];\n        \n        /**\n         * Maximum queue size to prevent memory leaks.\n         * WHY: Limits memory usage during extended disconnections.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.maxQueueSize = 100;\n        \n        /**\n         * Current retry attempt counter.\n         * WHY: Tracks retry attempts for exponential backoff logic.\n         * @type {number}\n         * @private\n         */\n        this.retryAttempts = 0;\n        \n        /**\n         * Maximum retry attempts before giving up.\n         * WHY: Prevents infinite retry loops that could impact performance.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.maxRetryAttempts = 5;  // Increased from 3 to 5 for better stability\n        \n        /**\n         * Retry delay intervals in milliseconds (exponential backoff).\n         * WHY: Prevents server overload during connection issues.\n         * @type {number[]}\n         * @private\n         * @const\n         */\n        this.retryDelays = [1000, 2000, 3000, 4000, 5000]; // Exponential backoff with 5 attempts\n        \n        /**\n         * Map of pending emissions for retry logic.\n         * WHY: Tracks failed emissions that need to be retried.\n         * @type {Map<string, Object>}\n         * @private\n         */\n        this.pendingEmissions = new Map(); // Track pending emissions for retry\n        \n        /**\n         * Timestamp of last ping sent to server.\n         * WHY: Used for health monitoring and connection validation.\n         * @type {number|null}\n         * @private\n         */\n        this.lastPingTime = null;\n        \n        /**\n         * Timestamp of last pong received from server.\n         * WHY: Confirms server is responsive and connection is healthy.\n         * @type {number|null}\n         * @private\n         */\n        this.lastPongTime = null;\n        \n        /**\n         * Health check timeout in milliseconds.\n         * WHY: More lenient than Socket.IO timeout to prevent false positives.\n         * @type {number}\n         * @private\n         * @const\n         */\n        this.pingTimeout = 90000; // 90 seconds for health check (more lenient than Socket.IO timeout)\n        \n        /**\n         * Health check interval timer.\n         * @type {number|null}\n         * @private\n         */\n        this.healthCheckInterval = null;\n        \n        // Initialize background monitoring\n        this.startStatusCheckFallback();\n        this.startHealthMonitoring();\n    }\n\n    /**\n     * Connect to Socket.IO server on specified port.\n     * \n     * Initiates WebSocket connection to the Claude MPM Socket.IO server.\n     * Handles connection conflicts and ensures clean state transitions.\n     * \n     * Connection Process:\n     * 1. Validates port and constructs localhost URL\n     * 2. Checks for existing connections and cleans up if needed\n     * 3. Delegates to doConnect() for actual connection logic\n     * \n     * Thread Safety:\n     * - Uses setTimeout for async cleanup to prevent race conditions\n     * - Connection state flags prevent multiple simultaneous attempts\n     * \n     * @param {string} [port='8765'] - Port number to connect to (defaults to 8765)\n     * \n     * @throws {Error} If Socket.IO library is not loaded\n     * \n     * @example\n     * // Connect to default port\n     * socketClient.connect();\n     * \n     * // Connect to specific port\n     * socketClient.connect('8766');\n     */\n    connect(port = '8765') {\n        // Store the port for later use in reconnections\n        this.port = port;\n        const url = `http://localhost:${port}`;\n\n        // WHY this check: Prevents connection conflicts that can cause memory leaks\n        if (this.socket && (this.socket.connected || this.socket.connecting)) {\n            console.log('Already connected or connecting, disconnecting first...');\n            this.socket.disconnect();\n            // WHY 100ms delay: Allows cleanup to complete before new connection\n            setTimeout(() => this.doConnect(url), 100);\n            return;\n        }\n\n        this.doConnect(url);\n    }\n\n    /**\n     * Execute the actual Socket.IO connection with full configuration.\n     * \n     * Creates and configures Socket.IO client with appropriate timeouts,\n     * retry logic, and transport settings. Sets up event handlers for\n     * connection lifecycle management.\n     * \n     * Configuration Details:\n     * - autoConnect: true - Immediate connection attempt\n     * - reconnection: true - Built-in reconnection enabled\n     * - pingInterval: 25000ms - Matches server configuration\n     * - pingTimeout: 20000ms - Health check timeout\n     * - transports: ['websocket', 'polling'] - Fallback options\n     * \n     * WHY these settings:\n     * - Ping intervals must match server to prevent timeouts\n     * - Limited reconnection attempts prevent infinite loops\n     * - forceNew prevents socket reuse issues\n     * \n     * @param {string} url - Complete Socket.IO server URL (http://localhost:port)\n     * @private\n     * \n     * @throws {Error} If Socket.IO library is not available\n     */\n    doConnect(url) {\n        console.log(`Connecting to Socket.IO server at ${url}`);\n        \n        // Check if io is available\n        if (typeof io === 'undefined') {\n            console.error('Socket.IO library not loaded! Make sure socket.io.min.js is loaded before this script.');\n            this.notifyConnectionStatus('Socket.IO library not loaded', 'error');\n            return;\n        }\n        \n        this.isConnecting = true;\n        this.notifyConnectionStatus('Connecting...', 'connecting');\n\n        this.socket = io(url, {\n            autoConnect: true,\n            reconnection: true,\n            reconnectionDelay: 1000,\n            reconnectionDelayMax: 5000,\n            reconnectionAttempts: 5,  // Try 5 times then stop (was Infinity which can cause issues)\n            timeout: 20000,  // Connection timeout\n            forceNew: true,\n            transports: ['websocket', 'polling'],\n            pingInterval: 25000,  // CRITICAL: Must match server's 25 seconds\n            pingTimeout: 20000    // CRITICAL: Must match server's 20 seconds\n        });\n\n        this.setupSocketHandlers();\n    }\n\n    /**\n     * Setup Socket.IO event handlers\n     */\n    setupSocketHandlers() {\n        this.socket.on('connect', () => {\n            console.log('Connected to Socket.IO server');\n            const previouslyConnected = this.isConnected;\n            this.isConnected = true;\n            this.isConnecting = false;\n            this.lastConnectTime = Date.now();\n            this.retryAttempts = 0; // Reset retry counter on successful connect\n            \n            // Calculate downtime if this is a reconnection\n            if (this.disconnectTime && previouslyConnected === false) {\n                const downtime = (Date.now() - this.disconnectTime) / 1000;\n                console.log(`Reconnected after ${downtime.toFixed(1)}s downtime`);\n                \n                // Flush queued events after reconnection\n                this.flushEventQueue();\n            }\n            \n            this.notifyConnectionStatus('Connected', 'connected');\n\n            // Expose socket globally for components that need direct access\n            window.socket = this.socket;\n            console.log('SocketClient: Exposed socket globally as window.socket');\n\n            // Emit connect callback\n            this.connectionCallbacks.connect.forEach(callback =>\n                callback(this.socket.id)\n            );\n\n            this.requestStatus();\n            // History is now automatically sent by server on connection\n            // No need to explicitly request it\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            // Enhanced logging for debugging disconnection issues\n            const disconnectInfo = {\n                reason: reason,\n                timestamp: new Date().toISOString(),\n                wasConnected: this.isConnected,\n                uptimeSeconds: this.lastConnectTime ? ((Date.now() - this.lastConnectTime) / 1000).toFixed(1) : 0,\n                lastPing: this.lastPingTime ? ((Date.now() - this.lastPingTime) / 1000).toFixed(1) + 's ago' : 'never',\n                lastPong: this.lastPongTime ? ((Date.now() - this.lastPongTime) / 1000).toFixed(1) + 's ago' : 'never'\n            };\n            \n            console.log('Disconnected from server:', disconnectInfo);\n            \n            this.isConnected = false;\n            this.isConnecting = false;\n            this.disconnectTime = Date.now();\n            \n            this.notifyConnectionStatus(`Disconnected: ${reason}`, 'disconnected');\n\n            // Emit disconnect callback\n            this.connectionCallbacks.disconnect.forEach(callback =>\n                callback(reason)\n            );\n            \n            // Detailed reason analysis for auto-reconnect decision\n            const reconnectReasons = [\n                'transport close',      // Network issue\n                'ping timeout',         // Server not responding\n                'transport error',      // Connection error\n                'io server disconnect', // Server initiated disconnect (might be restart)\n            ];\n            \n            if (reconnectReasons.includes(reason)) {\n                console.log(`Auto-reconnect triggered for reason: ${reason}`);\n                this.scheduleReconnect();\n            } else if (reason === 'io client disconnect') {\n                console.log('Client-initiated disconnect, not auto-reconnecting');\n            } else {\n                console.log(`Unknown disconnect reason: ${reason}, attempting reconnect anyway`);\n                this.scheduleReconnect();\n            }\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.isConnecting = false;\n            const errorMsg = error.message || error.description || 'Unknown error';\n            this.notifyConnectionStatus(`Connection Error: ${errorMsg}`, 'disconnected');\n\n            // Add error event\n            this.addEvent({\n                type: 'connection.error',\n                timestamp: new Date().toISOString(),\n                data: { \n                    error: errorMsg, \n                    url: this.socket.io.uri,\n                    retry_attempt: this.retryAttempts\n                }\n            });\n\n            // Emit error callback\n            this.connectionCallbacks.error.forEach(callback =>\n                callback(errorMsg)\n            );\n            \n            // Schedule reconnect with backoff\n            this.scheduleReconnect();\n        });\n\n        // Primary event handler - this is what the server actually emits\n        this.socket.on('claude_event', (data) => {\n            console.log('Received claude_event:', data);\n            \n            // Validate event schema\n            const validatedEvent = this.validateEventSchema(data);\n            if (!validatedEvent) {\n                console.warn('Invalid event schema received:', data);\n                return;\n            }\n            \n            // Code analysis events are now allowed to flow through to the events list for troubleshooting\n            // They will appear in both the Events tab and the Code tab\n            if (validatedEvent.type && validatedEvent.type.startsWith('code:')) {\n                console.log('Code analysis event received via claude_event, adding to events list for troubleshooting:', validatedEvent.type);\n            }\n            \n            // Transform event to match expected format (for backward compatibility)\n            const transformedEvent = this.transformEvent(validatedEvent);\n            console.log('Transformed event:', transformedEvent);\n            this.addEvent(transformedEvent);\n        });\n\n        // Add ping/pong handlers for health monitoring\n        this.socket.on('ping', (data) => {\n            // console.log('Received ping from server');\n            this.lastPingTime = Date.now();\n            \n            // Send pong response immediately\n            this.socket.emit('pong', { \n                timestamp: data.timestamp,\n                client_time: Date.now()\n            });\n        });\n        \n        // Track pong responses from server\n        this.socket.on('pong', (data) => {\n            this.lastPongTime = Date.now();\n            // console.log('Received pong from server');\n        });\n        \n        // Session and event handlers (legacy/fallback)\n        this.socket.on('session.started', (data) => {\n            this.addEvent({ type: 'session', subtype: 'started', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('session.ended', (data) => {\n            this.addEvent({ type: 'session', subtype: 'ended', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.request', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'request', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.response', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'response', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.loaded', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'loaded', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.executed', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'executed', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.pre', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'pre', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.post', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'post', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('todo.updated', (data) => {\n            this.addEvent({ type: 'todo', subtype: 'updated', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('memory.operation', (data) => {\n            this.addEvent({ type: 'memory', subtype: 'operation', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('log.entry', (data) => {\n            this.addEvent({ type: 'log', subtype: 'entry', timestamp: new Date().toISOString(), data });\n        });\n\n        // Code analysis events - now allowed to flow through for troubleshooting\n        // These are ALSO handled by the code-tree component and shown in the footer\n        // They will appear in both places: Events tab (for troubleshooting) and Code tab (for visualization)\n        this.socket.on('code:analysis:queued', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis queued event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:queued', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:accepted', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis accepted event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:accepted', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:start', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis start event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:start', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:complete', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis complete event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:complete', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:error', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis error event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:error', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:file:start', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code file start event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'file:start', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:node:found', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code node found event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'node:found', timestamp: new Date().toISOString(), data });\n        });\n        \n        this.socket.on('code:analysis:progress', (data) => {\n            // Add to events list for troubleshooting\n            console.log('Code analysis progress event received, adding to events list for troubleshooting');\n            this.addEvent({ type: 'code', subtype: 'analysis:progress', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('history', (data) => {\n            console.log('Received event history:', data);\n            if (data && Array.isArray(data.events)) {\n                console.log(`Processing ${data.events.length} historical events (${data.count} sent, ${data.total_available} total available)`);\n                // Add events in the order received (should already be chronological - oldest first)\n                // Transform each historical event to match expected format\n                data.events.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n                console.log(`Event history loaded: ${data.events.length} events added to dashboard`);\n            } else if (Array.isArray(data)) {\n                // Handle legacy format for backward compatibility\n                console.log('Received legacy event history format:', data.length, 'events');\n                data.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n            }\n        });\n\n        this.socket.on('system.status', (data) => {\n            console.log('Received system status:', data);\n            if (data.sessions) {\n                this.updateSessions(data.sessions);\n            }\n            if (data.current_session) {\n                this.currentSessionId = data.current_session;\n            }\n        });\n    }\n\n    /**\n     * Disconnect from Socket.IO server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.port = null; // Clear the stored port\n        this.isConnected = false;\n        this.isConnecting = false;\n    }\n\n    /**\n     * Emit an event with retry support\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     * @param {Object} options - Options for retry behavior\n     */\n    emitWithRetry(event, data = null, options = {}) {\n        const { \n            maxRetries = 3,\n            retryDelays = [1000, 2000, 4000],\n            onSuccess = null,\n            onFailure = null\n        } = options;\n        \n        const emissionId = `${event}_${Date.now()}_${Math.random()}`;\n        \n        const attemptEmission = (attemptNum = 0) => {\n            if (!this.socket || !this.socket.connected) {\n                // Queue for later if disconnected\n                if (attemptNum === 0) {\n                    this.queueEvent(event, data);\n                    console.log(`Queued ${event} for later emission (disconnected)`);\n                    if (onFailure) onFailure('disconnected');\n                }\n                return;\n            }\n            \n            try {\n                // Attempt emission\n                this.socket.emit(event, data);\n                console.log(`Emitted ${event} successfully`);\n                \n                // Remove from pending\n                this.pendingEmissions.delete(emissionId);\n                \n                if (onSuccess) onSuccess();\n                \n            } catch (error) {\n                console.error(`Failed to emit ${event} (attempt ${attemptNum + 1}):`, error);\n                \n                if (attemptNum < maxRetries - 1) {\n                    const delay = retryDelays[attemptNum] || retryDelays[retryDelays.length - 1];\n                    console.log(`Retrying ${event} in ${delay}ms...`);\n                    \n                    // Store pending emission\n                    this.pendingEmissions.set(emissionId, {\n                        event,\n                        data,\n                        attemptNum: attemptNum + 1,\n                        scheduledTime: Date.now() + delay\n                    });\n                    \n                    setTimeout(() => attemptEmission(attemptNum + 1), delay);\n                } else {\n                    console.error(`Failed to emit ${event} after ${maxRetries} attempts`);\n                    this.pendingEmissions.delete(emissionId);\n                    if (onFailure) onFailure('max_retries_exceeded');\n                }\n            }\n        };\n        \n        attemptEmission();\n    }\n    \n    /**\n     * Queue an event for later emission\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     */\n    queueEvent(event, data) {\n        if (this.eventQueue.length >= this.maxQueueSize) {\n            // Remove oldest event if queue is full\n            const removed = this.eventQueue.shift();\n            console.warn(`Event queue full, dropped oldest event: ${removed.event}`);\n        }\n        \n        this.eventQueue.push({\n            event,\n            data,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Flush queued events after reconnection\n     */\n    flushEventQueue() {\n        if (this.eventQueue.length === 0) return;\n        \n        console.log(`Flushing ${this.eventQueue.length} queued events...`);\n        const events = [...this.eventQueue];\n        this.eventQueue = [];\n        \n        // Emit each queued event with a small delay between them\n        events.forEach((item, index) => {\n            setTimeout(() => {\n                if (this.socket && this.socket.connected) {\n                    this.socket.emit(item.event, item.data);\n                    console.log(`Flushed queued event: ${item.event}`);\n                }\n            }, index * 100); // 100ms between each event\n        });\n    }\n    \n    /**\n     * Schedule a reconnection attempt with exponential backoff\n     */\n    scheduleReconnect() {\n        if (this.retryAttempts >= this.maxRetryAttempts) {\n            console.log('Max reconnection attempts reached, stopping auto-reconnect');\n            this.notifyConnectionStatus('Reconnection failed', 'disconnected');\n            return;\n        }\n        \n        const delay = this.retryDelays[this.retryAttempts] || this.retryDelays[this.retryDelays.length - 1];\n        this.retryAttempts++;\n        \n        console.log(`Scheduling reconnect attempt ${this.retryAttempts}/${this.maxRetryAttempts} in ${delay}ms...`);\n        this.notifyConnectionStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');\n        \n        setTimeout(() => {\n            if (!this.isConnected && this.port) {\n                console.log(`Attempting reconnection ${this.retryAttempts}/${this.maxRetryAttempts}...`);\n                this.connect(this.port);\n            }\n        }, delay);\n    }\n    \n    /**\n     * Request server status\n     */\n    requestStatus() {\n        if (this.socket && this.socket.connected) {\n            console.log('Requesting server status...');\n            this.emitWithRetry('request.status', null, {\n                maxRetries: 2,\n                retryDelays: [500, 1000]\n            });\n        }\n    }\n\n    /**\n     * Request event history from server\n     * @param {Object} options - History request options\n     * @param {number} options.limit - Maximum number of events to retrieve (default: 50)\n     * @param {Array<string>} options.event_types - Optional filter by event types\n     */\n    requestHistory(options = {}) {\n        if (this.socket && this.socket.connected) {\n            const params = {\n                limit: options.limit || 50,\n                event_types: options.event_types || []\n            };\n            console.log('Requesting event history...', params);\n            this.emitWithRetry('get_history', params, {\n                maxRetries: 3,\n                retryDelays: [1000, 2000, 3000],\n                onFailure: (reason) => {\n                    console.error(`Failed to request history: ${reason}`);\n                }\n            });\n        } else {\n            console.warn('Cannot request history: not connected to server');\n        }\n    }\n\n    /**\n     * Add event to local storage and notify listeners\n     * @param {Object} eventData - Event data\n     * @param {boolean} notify - Whether to notify listeners (default: true)\n     */\n    addEvent(eventData, notify = true) {\n        // Ensure event has required fields\n        if (!eventData.timestamp) {\n            eventData.timestamp = new Date().toISOString();\n        }\n        if (!eventData.id) {\n            eventData.id = Date.now() + Math.random();\n        }\n\n        this.events.push(eventData);\n\n        // Update session tracking\n        if (eventData.data && eventData.data.session_id) {\n            const sessionId = eventData.data.session_id;\n            if (!this.sessions.has(sessionId)) {\n                this.sessions.set(sessionId, {\n                    id: sessionId,\n                    startTime: eventData.timestamp,\n                    lastActivity: eventData.timestamp,\n                    eventCount: 0,\n                    working_directory: null,\n                    git_branch: null\n                });\n            }\n            const session = this.sessions.get(sessionId);\n            session.lastActivity = eventData.timestamp;\n            session.eventCount++;\n            \n            // Extract working directory from event data if available (prioritize newer data)\n            // Check multiple possible locations for working directory\n            const possiblePaths = [\n                eventData.data.cwd,\n                eventData.data.working_directory,\n                eventData.data.working_dir,\n                eventData.data.workingDirectory,\n                eventData.data.instance_info?.working_dir,\n                eventData.data.instance_info?.working_directory,\n                eventData.data.instance_info?.cwd,\n                eventData.cwd,\n                eventData.working_directory,\n                eventData.working_dir\n            ];\n            \n            for (const path of possiblePaths) {\n                if (path && typeof path === 'string' && path.trim()) {\n                    session.working_directory = path;\n                    console.log(`[SOCKET-CLIENT] Found working directory for session ${sessionId}:`, path);\n                    break;\n                }\n            }\n            \n            // Extract git branch if available\n            if (eventData.data.git_branch) {\n                session.git_branch = eventData.data.git_branch;\n            } else if (eventData.data.instance_info && eventData.data.instance_info.git_branch) {\n                session.git_branch = eventData.data.instance_info.git_branch;\n            }\n        }\n\n        if (notify) {\n            this.notifyEventUpdate();\n        }\n    }\n\n    /**\n     * Update sessions from server data\n     * @param {Array} sessionsData - Sessions data from server\n     */\n    updateSessions(sessionsData) {\n        if (Array.isArray(sessionsData)) {\n            sessionsData.forEach(session => {\n                this.sessions.set(session.id, session);\n            });\n        }\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.events = [];\n        this.sessions.clear();\n        this.notifyEventUpdate();\n    }\n\n    /**\n     * Clear events and request fresh history from server\n     * @param {Object} options - History request options (same as requestHistory)\n     */\n    refreshHistory(options = {}) {\n        this.clearEvents();\n        this.requestHistory(options);\n    }\n\n    /**\n     * Get filtered events by session\n     * @param {string} sessionId - Session ID to filter by (null for all)\n     * @returns {Array} Filtered events\n     */\n    getEventsBySession(sessionId = null) {\n        if (!sessionId) {\n            return this.events;\n        }\n        return this.events.filter(event =>\n            event.data && event.data.session_id === sessionId\n        );\n    }\n\n    /**\n     * Register callback for connection events\n     * @param {string} eventType - Type of event (connect, disconnect, error)\n     * @param {Function} callback - Callback function\n     */\n    onConnection(eventType, callback) {\n        if (this.connectionCallbacks[eventType]) {\n            this.connectionCallbacks[eventType].push(callback);\n        }\n    }\n\n    /**\n     * Register callback for event updates\n     * @param {Function} callback - Callback function\n     */\n    onEventUpdate(callback) {\n        this.connectionCallbacks.event.push(callback);\n    }\n\n    /**\n     * Subscribe to socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function\n     */\n    on(event, callback) {\n        if (this.socket) {\n            return this.socket.on(event, callback);\n        } else {\n            console.warn(`Cannot subscribe to '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Unsubscribe from socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function (optional)\n     */\n    off(event, callback) {\n        if (this.socket) {\n            return this.socket.off(event, callback);\n        } else {\n            console.warn(`Cannot unsubscribe from '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Notify connection status change\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    notifyConnectionStatus(status, type) {\n        console.log(`SocketClient: Connection status changed to '${status}' (${type})`);\n\n        // Direct DOM update - immediate and reliable\n        this.updateConnectionStatusDOM(status, type);\n\n        // Also dispatch custom event for other modules\n        document.dispatchEvent(new CustomEvent('socketConnectionStatus', {\n            detail: { status, type }\n        }));\n    }\n\n    /**\n     * Directly update the connection status DOM element\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    updateConnectionStatusDOM(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Update the text content while preserving the indicator span\n            statusElement.innerHTML = `<span>●</span> ${status}`;\n\n            // Update the CSS class for styling\n            statusElement.className = `status-badge status-${type}`;\n\n            console.log(`SocketClient: Direct DOM update - status: '${status}' (${type})`);\n        } else {\n            console.warn('SocketClient: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Notify event update\n     */\n    notifyEventUpdate() {\n        this.connectionCallbacks.event.forEach(callback =>\n            callback(this.events, this.sessions)\n        );\n\n        // Also dispatch custom event\n        document.dispatchEvent(new CustomEvent('socketEventUpdate', {\n            detail: { events: this.events, sessions: this.sessions }\n        }));\n    }\n\n    /**\n     * Get connection state\n     * @returns {Object} Connection state\n     */\n    getConnectionState() {\n        return {\n            isConnected: this.isConnected,\n            isConnecting: this.isConnecting,\n            socketId: this.socket ? this.socket.id : null\n        };\n    }\n\n    /**\n     * Validate event against expected schema\n     * @param {Object} eventData - Raw event data\n     * @returns {Object|null} Validated event or null if invalid\n     */\n    validateEventSchema(eventData) {\n        if (!eventData || typeof eventData !== 'object') {\n            console.warn('Event data is not an object:', eventData);\n            return null;\n        }\n        \n        // Make a copy to avoid modifying the original\n        const validated = { ...eventData };\n        \n        // Check and provide defaults for required fields\n        if (!validated.source) {\n            validated.source = 'system';  // Default source for backward compatibility\n        }\n        if (!validated.type) {\n            // If there's an event field, use it as the type\n            if (validated.event) {\n                validated.type = validated.event;\n            } else {\n                validated.type = 'unknown';\n            }\n        }\n        if (!validated.subtype) {\n            validated.subtype = 'generic';\n        }\n        if (!validated.timestamp) {\n            validated.timestamp = new Date().toISOString();\n        }\n        if (!validated.data) {\n            validated.data = {};\n        }\n        \n        // Ensure data field is an object\n        if (validated.data && typeof validated.data !== 'object') {\n            validated.data = { value: validated.data };\n        }\n        \n        console.log('Validated event:', validated);\n        return validated;\n    }\n    \n    /**\n     * Transform received event to match expected dashboard format\n     * @param {Object} eventData - Raw event data from server\n     * @returns {Object} Transformed event\n     */\n    transformEvent(eventData) {\n        // Handle multiple event structures:\n        // 1. Hook events: { type: 'hook.pre_tool', timestamp: '...', data: {...} }\n        // 2. Legacy events: { event: 'TestStart', timestamp: '...', ... }\n        // 3. Standard events: { type: 'session', subtype: 'started', ... }\n        // 4. Normalized events: { type: 'code', subtype: 'progress', ... } - already normalized, keep as-is\n\n        if (!eventData) {\n            return eventData; // Return as-is if null/undefined\n        }\n\n        let transformedEvent = { ...eventData };\n\n        // Check if event is already normalized (has both type and subtype as separate fields)\n        // This prevents double-transformation of events that were normalized on the backend\n        const isAlreadyNormalized = eventData.type && eventData.subtype && \n                                   !eventData.type.includes('.') && \n                                   !eventData.type.includes(':');\n\n        if (isAlreadyNormalized) {\n            // Event is already properly normalized from backend, just preserve it\n            // Store a composite originalEventName for display if needed\n            if (!transformedEvent.originalEventName) {\n                if (eventData.subtype === 'generic' || eventData.type === eventData.subtype) {\n                    transformedEvent.originalEventName = eventData.type;\n                } else {\n                    transformedEvent.originalEventName = `${eventData.type}.${eventData.subtype}`;\n                }\n            }\n            // Return early to avoid further transformation\n        }\n        // Handle legacy format with 'event' field but no 'type'\n        else if (!eventData.type && eventData.event) {\n            // Map common event names to proper type/subtype\n            const eventName = eventData.event;\n            \n            // Check for known event patterns\n            if (eventName === 'TestStart' || eventName === 'TestEnd') {\n                transformedEvent.type = 'test';\n                transformedEvent.subtype = eventName.toLowerCase().replace('test', '');\n            } else if (eventName === 'SubagentStart' || eventName === 'SubagentStop') {\n                transformedEvent.type = 'subagent';\n                transformedEvent.subtype = eventName.toLowerCase().replace('subagent', '');\n            } else if (eventName === 'ToolCall') {\n                transformedEvent.type = 'tool';\n                transformedEvent.subtype = 'call';\n            } else if (eventName === 'UserPrompt') {\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = 'user_prompt';\n            } else {\n                // Generic fallback for unknown event names\n                // Use 'unknown' for type and the actual eventName for subtype\n                transformedEvent.type = 'unknown';\n                transformedEvent.subtype = eventName.toLowerCase();\n                \n                // Prevent duplicate type/subtype values\n                if (transformedEvent.type === transformedEvent.subtype) {\n                    transformedEvent.subtype = 'event';\n                }\n            }\n            \n            // Remove the 'event' field to avoid confusion\n            delete transformedEvent.event;\n            // Store original event name for display purposes\n            transformedEvent.originalEventName = eventName;\n        }\n        // Handle standard format with 'type' field that needs transformation\n        else if (eventData.type) {\n            const type = eventData.type;\n            \n            // Transform 'hook.subtype' format to separate type and subtype\n            if (type.startsWith('hook.')) {\n                const subtype = type.substring(5); // Remove 'hook.' prefix\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = subtype;\n                transformedEvent.originalEventName = type;\n            }\n            // Transform 'code:*' events to proper code type\n            // Handle multi-level subtypes like 'code:analysis:queued'\n            else if (type.startsWith('code:')) {\n                transformedEvent.type = 'code';\n                // Replace colons with underscores in subtype for consistency\n                const subtypePart = type.substring(5); // Remove 'code:' prefix\n                transformedEvent.subtype = subtypePart.replace(/:/g, '_');\n                transformedEvent.originalEventName = type;\n            }\n            // Transform other dotted types like 'session.started' -> type: 'session', subtype: 'started'\n            else if (type.includes('.')) {\n                const [mainType, ...subtypeParts] = type.split('.');\n                transformedEvent.type = mainType;\n                transformedEvent.subtype = subtypeParts.join('.');\n                transformedEvent.originalEventName = type;\n            }\n            // Transform any remaining colon-separated types generically\n            else if (type.includes(':')) {\n                const parts = type.split(':', 2); // Split into max 2 parts\n                transformedEvent.type = parts[0];\n                // Replace any remaining colons with underscores in subtype\n                transformedEvent.subtype = parts.length > 1 ? parts[1].replace(/:/g, '_') : 'generic';\n                transformedEvent.originalEventName = type;\n            }\n            // If type doesn't need transformation but has no subtype, set a default\n            else if (!eventData.subtype) {\n                transformedEvent.subtype = 'generic';\n                transformedEvent.originalEventName = type;\n            }\n        }\n        // If no type and no event field, mark as unknown\n        else {\n            transformedEvent.type = 'unknown';\n            transformedEvent.subtype = '';\n            transformedEvent.originalEventName = 'unknown';\n        }\n\n        // Extract and flatten data fields to top level for dashboard compatibility\n        // The dashboard expects fields like tool_name, agent_type, etc. at the top level\n        if (eventData.data && typeof eventData.data === 'object') {\n            // Protected fields that should never be overwritten by data fields\n            const protectedFields = ['type', 'subtype', 'timestamp', 'id', 'event', 'event_type', 'originalEventName'];\n            \n            // Copy all data fields to the top level, except protected ones\n            Object.keys(eventData.data).forEach(key => {\n                // Only copy if not a protected field\n                if (!protectedFields.includes(key)) {\n                    // Special handling for tool_parameters to ensure it's properly preserved\n                    // This is critical for file path extraction in file-tool-tracker\n                    if (key === 'tool_parameters' && typeof eventData.data[key] === 'object') {\n                        // Deep copy the tool_parameters object to preserve all nested fields\n                        transformedEvent[key] = JSON.parse(JSON.stringify(eventData.data[key]));\n                    } else {\n                        transformedEvent[key] = eventData.data[key];\n                    }\n                } else {\n                    // Log warning if data field would overwrite a protected field\n                    console.warn(`Protected field '${key}' in data object was not copied to top level to preserve event structure`);\n                }\n            });\n            \n            // Keep the original data object for backward compatibility\n            transformedEvent.data = eventData.data;\n        }\n\n        // Add hook_event_name for ActivityTree compatibility\n        // Map the type/subtype structure to the expected hook_event_name format\n        if (transformedEvent.type === 'hook') {\n            if (transformedEvent.subtype === 'pre_tool') {\n                transformedEvent.hook_event_name = 'PreToolUse';\n            } else if (transformedEvent.subtype === 'post_tool') {\n                transformedEvent.hook_event_name = 'PostToolUse';\n            } else if (transformedEvent.subtype === 'subagent_start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'subagent_stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            } else if (transformedEvent.subtype === 'todo_write') {\n                transformedEvent.hook_event_name = 'TodoWrite';\n            } else if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'Start';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'Stop';\n            }\n        } else if (transformedEvent.type === 'subagent') {\n            if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            }\n        } else if (transformedEvent.type === 'todo' && transformedEvent.subtype === 'updated') {\n            transformedEvent.hook_event_name = 'TodoWrite';\n        }\n\n        // Debug logging for tool events\n        if (transformedEvent.type === 'hook' && (transformedEvent.subtype === 'pre_tool' || transformedEvent.subtype === 'post_tool')) {\n            console.log('Transformed tool event:', {\n                type: transformedEvent.type,\n                subtype: transformedEvent.subtype,\n                hook_event_name: transformedEvent.hook_event_name,\n                tool_name: transformedEvent.tool_name,\n                has_tool_parameters: !!transformedEvent.tool_parameters,\n                tool_parameters: transformedEvent.tool_parameters,\n                has_data: !!transformedEvent.data,\n                keys: Object.keys(transformedEvent).filter(k => k !== 'data')\n            });\n            \n            // Extra debug logging for file-related tools\n            const fileTools = ['Read', 'Write', 'Edit', 'MultiEdit', 'NotebookEdit'];\n            if (fileTools.includes(transformedEvent.tool_name)) {\n                console.log('File tool event details:', {\n                    tool_name: transformedEvent.tool_name,\n                    file_path: transformedEvent.tool_parameters?.file_path,\n                    path: transformedEvent.tool_parameters?.path,\n                    notebook_path: transformedEvent.tool_parameters?.notebook_path,\n                    full_parameters: transformedEvent.tool_parameters\n                });\n            }\n        }\n\n        return transformedEvent;\n    }\n\n    /**\n     * Get current events and sessions\n     * @returns {Object} Current state\n     */\n    getState() {\n        return {\n            events: this.events,\n            sessions: this.sessions,\n            currentSessionId: this.currentSessionId\n        };\n    }\n\n    /**\n     * Start health monitoring\n     * Detects stale connections and triggers reconnection\n     */\n    startHealthMonitoring() {\n        this.healthCheckInterval = setInterval(() => {\n            if (this.isConnected && this.lastPingTime) {\n                const timeSinceLastPing = Date.now() - this.lastPingTime;\n                \n                if (timeSinceLastPing > this.pingTimeout) {\n                    console.warn(`No ping from server for ${timeSinceLastPing/1000}s, connection may be stale`);\n                    \n                    // Force reconnection\n                    if (this.socket) {\n                        console.log('Forcing reconnection due to stale connection...');\n                        this.socket.disconnect();\n                        setTimeout(() => {\n                            if (this.port) {\n                                this.connect(this.port);\n                            }\n                        }, 1000);\n                    }\n                }\n            }\n        }, 10000); // Check every 10 seconds\n    }\n    \n    /**\n     * Stop health monitoring\n     */\n    stopHealthMonitoring() {\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n            this.healthCheckInterval = null;\n        }\n    }\n    \n    /**\n     * Start periodic status check as fallback mechanism\n     * This ensures the UI stays in sync with actual socket state\n     */\n    startStatusCheckFallback() {\n        // Check status every 2 seconds\n        setInterval(() => {\n            this.checkAndUpdateStatus();\n        }, 2000);\n\n        // Initial check after DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => {\n                setTimeout(() => this.checkAndUpdateStatus(), 100);\n            });\n        } else {\n            setTimeout(() => this.checkAndUpdateStatus(), 100);\n        }\n    }\n\n    /**\n     * Check actual socket state and update UI if necessary\n     */\n    checkAndUpdateStatus() {\n        let actualStatus = 'Disconnected';\n        let actualType = 'disconnected';\n\n        if (this.socket) {\n            if (this.socket.connected) {\n                actualStatus = 'Connected';\n                actualType = 'connected';\n                this.isConnected = true;\n                this.isConnecting = false;\n            } else if (this.socket.connecting || this.isConnecting) {\n                actualStatus = 'Connecting...';\n                actualType = 'connecting';\n                this.isConnected = false;\n            } else {\n                actualStatus = 'Disconnected';\n                actualType = 'disconnected';\n                this.isConnected = false;\n                this.isConnecting = false;\n            }\n        }\n\n        // Check if UI needs updating\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            const currentText = statusElement.textContent.replace('●', '').trim();\n            const currentClass = statusElement.className;\n            const expectedClass = `status-badge status-${actualType}`;\n\n            // Update if status text or class doesn't match\n            if (currentText !== actualStatus || currentClass !== expectedClass) {\n                console.log(`SocketClient: Fallback update - was '${currentText}' (${currentClass}), now '${actualStatus}' (${expectedClass})`);\n                this.updateConnectionStatusDOM(actualStatus, actualType);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.stopHealthMonitoring();\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.eventQueue = [];\n        this.pendingEmissions.clear();\n    }\n    \n    /**\n     * Get connection metrics\n     * @returns {Object} Connection metrics\n     */\n    getConnectionMetrics() {\n        return {\n            isConnected: this.isConnected,\n            uptime: this.lastConnectTime ? (Date.now() - this.lastConnectTime) / 1000 : 0,\n            lastPing: this.lastPingTime ? (Date.now() - this.lastPingTime) / 1000 : null,\n            queuedEvents: this.eventQueue.length,\n            pendingEmissions: this.pendingEmissions.size,\n            retryAttempts: this.retryAttempts\n        };\n    }\n}\n\n// ES6 Module export\nexport { SocketClient };\nexport default SocketClient;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.SocketClient = SocketClient;\n","/**\n * Socket Manager Module\n *\n * Handles all socket connection management, event dispatching, and connection state.\n * Provides a centralized interface for socket operations across the dashboard.\n *\n * WHY: Extracted from main dashboard to centralize socket connection logic and\n * provide better separation of concerns. This allows for easier testing and\n * maintenance of connection handling code.\n *\n * DESIGN DECISION: Acts as a wrapper around SocketClient to provide dashboard-specific\n * connection management while maintaining the existing SocketClient interface.\n * Uses event dispatching to notify other modules of connection state changes.\n */\n\n// Import SocketClient (assuming it will be converted to ES6 modules too)\nimport { SocketClient } from '../socket-client.js';\nclass SocketManager {\n    constructor() {\n        this.socketClient = null;\n        this.connectionCallbacks = new Set();\n        this.eventUpdateCallbacks = new Set();\n\n        // Initialize socket client\n        this.socketClient = new SocketClient();\n\n        // Make socketClient globally available (for backward compatibility)\n        window.socketClient = this.socketClient;\n\n        this.setupSocketEventHandlers();\n\n        // Force initial status update after a short delay to ensure DOM is ready\n        setTimeout(() => {\n            this.updateInitialConnectionStatus();\n        }, 100);\n\n        console.log('Socket manager initialized');\n    }\n\n    /**\n     * Set up socket event handlers for connection status and events\n     */\n    setupSocketEventHandlers() {\n        // Listen for connection status changes\n        document.addEventListener('socketConnectionStatus', (e) => {\n            console.log(`SocketManager: Processing connection status update: ${e.detail.status} (${e.detail.type})`);\n            this.handleConnectionStatusChange(e.detail.status, e.detail.type);\n\n            // Notify all registered callbacks\n            this.connectionCallbacks.forEach(callback => {\n                try {\n                    callback(e.detail.status, e.detail.type);\n                } catch (error) {\n                    console.error('Error in connection callback:', error);\n                }\n            });\n        });\n\n        // Set up event update handling\n        if (this.socketClient) {\n            this.socketClient.onEventUpdate((events) => {\n                // Notify all registered callbacks\n                this.eventUpdateCallbacks.forEach(callback => {\n                    try {\n                        callback(events);\n                    } catch (error) {\n                        console.error('Error in event update callback:', error);\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Handle connection status changes\n     * @param {string} status - Connection status text\n     * @param {string} type - Connection type ('connected', 'disconnected', etc.)\n     */\n    handleConnectionStatusChange(status, type) {\n        this.updateConnectionStatus(status, type);\n\n        // Set up git branch listener when connected\n        if (type === 'connected' && this.socketClient && this.socketClient.socket) {\n            // Expose socket globally for components like CodeTree\n            window.socket = this.socketClient.socket;\n            console.log('SocketManager: Exposed socket globally as window.socket');\n            \n            this.setupGitBranchListener();\n        }\n    }\n\n    /**\n     * Update initial connection status on dashboard load\n     */\n    updateInitialConnectionStatus() {\n        console.log('SocketManager: Updating initial connection status');\n\n        // Force status check on socket client (uses fallback mechanism)\n        if (this.socketClient && typeof this.socketClient.checkAndUpdateStatus === 'function') {\n            console.log('SocketManager: Using socket client checkAndUpdateStatus method');\n            this.socketClient.checkAndUpdateStatus();\n        } else if (this.socketClient && this.socketClient.socket) {\n            console.log('SocketManager: Checking socket state directly', {\n                connected: this.socketClient.socket.connected,\n                connecting: this.socketClient.socket.connecting,\n                isConnecting: this.socketClient.isConnecting,\n                isConnected: this.socketClient.isConnected\n            });\n\n            if (this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket is already connected, updating status');\n                // Expose socket globally for components like CodeTree\n                window.socket = this.socketClient.socket;\n                console.log('SocketManager: Exposed socket globally as window.socket');\n                this.updateConnectionStatus('Connected', 'connected');\n            } else if (this.socketClient.isConnecting || this.socketClient.socket.connecting) {\n                console.log('SocketManager: Socket is connecting, updating status');\n                this.updateConnectionStatus('Connecting...', 'connecting');\n            } else {\n                console.log('SocketManager: Socket is disconnected, updating status');\n                this.updateConnectionStatus('Disconnected', 'disconnected');\n            }\n        } else {\n            console.log('SocketManager: No socket client or socket found, setting disconnected status');\n            this.updateConnectionStatus('Disconnected', 'disconnected');\n        }\n\n        // Additional fallback - check again after a longer delay in case connection is still establishing\n        setTimeout(() => {\n            console.log('SocketManager: Secondary status check after 1 second');\n            if (this.socketClient && this.socketClient.socket && this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket connected in secondary check, updating status');\n                // Expose socket globally if not already done\n                if (!window.socket) {\n                    window.socket = this.socketClient.socket;\n                    console.log('SocketManager: Exposed socket globally as window.socket (secondary check)');\n                }\n                this.updateConnectionStatus('Connected', 'connected');\n            }\n        }, 1000);\n    }\n\n    /**\n     * Set up git branch response listener for connected socket\n     */\n    setupGitBranchListener() {\n        // Remove any existing listener first\n        this.socketClient.socket.off('git_branch_response');\n\n        // Add the listener\n        this.socketClient.socket.on('git_branch_response', (data) => {\n            if (data.success) {\n                const footerBranch = document.getElementById('footer-git-branch');\n                if (footerBranch) {\n                    footerBranch.textContent = data.branch || 'unknown';\n                }\n                if (footerBranch) {\n                    footerBranch.style.display = 'inline';\n                }\n            } else {\n                console.error('Git branch request failed:', data.error);\n            }\n        });\n    }\n\n    /**\n     * Update connection status display\n     * @param {string} status - Status text to display\n     * @param {string} type - Status type for styling\n     */\n    updateConnectionStatus(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Check if there's a span indicator first\n            const indicator = statusElement.querySelector('span');\n            if (indicator) {\n                // If there's a span, update the text content after the span\n                const statusIndicator = type === 'connected' ? '●' : '●';\n                statusElement.innerHTML = `<span>${statusIndicator}</span> ${status}`;\n            } else {\n                // If no span, just update text content\n                statusElement.textContent = status;\n            }\n\n            statusElement.className = `status-badge status-${type}`;\n            console.log(`SocketManager: UI updated - status: '${status}' (${type})`);\n        } else {\n            console.error('SocketManager: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Connect to socket server\n     * @param {number} port - Port number to connect to\n     */\n    connect(port) {\n        if (this.socketClient) {\n            this.socketClient.connect(port);\n        }\n    }\n\n    /**\n     * Disconnect from socket server\n     */\n    disconnect() {\n        if (this.socketClient) {\n            this.socketClient.disconnect();\n        }\n    }\n\n    /**\n     * Check if socket is connected\n     * @returns {boolean} - True if connected\n     */\n    isConnected() {\n        return this.socketClient && this.socketClient.isConnected;\n    }\n\n    /**\n     * Check if socket is connecting\n     * @returns {boolean} - True if connecting\n     */\n    isConnecting() {\n        return this.socketClient && this.socketClient.isConnecting;\n    }\n\n    /**\n     * Get the underlying socket client\n     * @returns {SocketClient} - The socket client instance\n     */\n    getSocketClient() {\n        return this.socketClient;\n    }\n\n    /**\n     * Get the raw socket connection\n     * @returns {Socket|null} - The raw socket or null\n     */\n    getSocket() {\n        return this.socketClient ? this.socketClient.socket : null;\n    }\n\n    /**\n     * Register a callback for connection status changes\n     * @param {Function} callback - Callback function(status, type)\n     */\n    onConnectionStatusChange(callback) {\n        this.connectionCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister a connection status callback\n     * @param {Function} callback - Callback to remove\n     */\n    offConnectionStatusChange(callback) {\n        this.connectionCallbacks.delete(callback);\n    }\n\n    /**\n     * Register a callback for event updates\n     * @param {Function} callback - Callback function(events)\n     */\n    onEventUpdate(callback) {\n        this.eventUpdateCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister an event update callback\n     * @param {Function} callback - Callback to remove\n     */\n    offEventUpdate(callback) {\n        this.eventUpdateCallbacks.delete(callback);\n    }\n\n    /**\n     * Toggle connection controls visibility\n     */\n    toggleConnectionControls() {\n        const controlsRow = document.getElementById('connection-controls-row');\n        const toggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (controlsRow && toggleBtn) {\n            const isVisible = controlsRow.classList.contains('show');\n\n            if (isVisible) {\n                controlsRow.classList.remove('show');\n                controlsRow.style.display = 'none';\n                toggleBtn.textContent = 'Connection Settings';\n            } else {\n                controlsRow.classList.add('show');\n                controlsRow.style.display = 'block';\n                toggleBtn.textContent = 'Hide Settings';\n            }\n        }\n    }\n\n    /**\n     * Setup connection control event handlers\n     * Called during dashboard initialization\n     */\n    setupConnectionControls() {\n        const connectBtn = document.getElementById('connect-btn');\n        const disconnectBtn = document.getElementById('disconnect-btn');\n        const connectionToggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (connectBtn) {\n            connectBtn.addEventListener('click', () => {\n                const port = document.getElementById('port-input').value || 8765;\n                this.connect(port);\n            });\n        }\n\n        if (disconnectBtn) {\n            disconnectBtn.addEventListener('click', () => {\n                this.disconnect();\n            });\n        }\n\n        if (connectionToggleBtn) {\n            connectionToggleBtn.addEventListener('click', () => {\n                this.toggleConnectionControls();\n            });\n        }\n    }\n\n    /**\n     * Initialize connection from URL parameters\n     * @param {URLSearchParams} params - URL search parameters\n     */\n    initializeFromURL(params) {\n        const port = params.get('port');\n        const portInput = document.getElementById('port-input');\n\n        // Determine the port to use:\n        // 1. URL parameter 'port'\n        // 2. Current page port (if served via HTTP)\n        // 3. Default port value from input field\n        // 4. Fallback to 8765\n        let connectPort = port;\n        if (!connectPort && window.location.protocol === 'http:') {\n            connectPort = window.location.port || '8765';\n        }\n        if (!connectPort) {\n            connectPort = portInput?.value || '8765';\n        }\n\n        // Update the port input field with the determined port\n        if (portInput) {\n            portInput.value = connectPort;\n        }\n\n        // Auto-connect by default unless explicitly disabled\n        // Changed: Always auto-connect by default even without URL params\n        const shouldAutoConnect = params.get('connect') !== 'false';\n        if (shouldAutoConnect && !this.isConnected() && !this.isConnecting()) {\n            console.log(`SocketManager: Auto-connecting to port ${connectPort}`);\n            this.connect(connectPort);\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketManager };\nexport default SocketManager;\n","/**\n * UI State Manager Module\n *\n * Manages UI state including tab switching, card selection, keyboard navigation,\n * and visual feedback across the dashboard interface.\n *\n * WHY: Extracted from main dashboard to centralize UI state management and\n * provide better separation between business logic and UI state. This makes\n * the UI behavior more predictable and easier to test.\n *\n * DESIGN DECISION: Maintains centralized state for current tab, selected cards,\n * and navigation context while providing a clean API for other modules to\n * interact with UI state changes.\n */\nclass UIStateManager {\n    constructor() {\n        // Current active tab\n        this.currentTab = 'events';\n\n        // Auto-scroll behavior\n        this.autoScroll = true;\n\n        // Selection state - tracks the currently selected card across all tabs\n        this.selectedCard = {\n            tab: null,        // which tab the selection is in\n            index: null,      // index of selected item in that tab\n            type: null,       // 'event', 'agent', 'tool', 'file'\n            data: null        // the actual data object\n        };\n\n        // Navigation state for each tab\n        this.tabNavigation = {\n            events: { selectedIndex: -1, items: [] },\n            agents: { selectedIndex: -1, items: [] },\n            tools: { selectedIndex: -1, items: [] },\n            files: { selectedIndex: -1, items: [] }\n        };\n\n        this.setupEventHandlers();\n        console.log('UI state manager initialized');\n    }\n\n    /**\n     * Set up event handlers for UI interactions\n     */\n    setupEventHandlers() {\n        this.setupTabNavigation();\n        this.setupUnifiedKeyboardNavigation();\n    }\n\n    /**\n     * Set up tab navigation event listeners\n     */\n    setupTabNavigation() {\n        // Tab buttons\n        document.querySelectorAll('.tab-button').forEach(button => {\n            button.addEventListener('click', () => {\n                const tabName = this.getTabNameFromButton(button);\n                this.switchTab(tabName);\n            });\n        });\n    }\n\n    /**\n     * Set up unified keyboard navigation across all tabs\n     */\n    setupUnifiedKeyboardNavigation() {\n        document.addEventListener('keydown', (e) => {\n            // Only handle if not in an input field\n            if (document.activeElement &&\n                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {\n                return;\n            }\n\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.handleUnifiedArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                this.handleUnifiedEnterKey();\n            } else if (e.key === 'Escape') {\n                this.clearUnifiedSelection();\n            }\n        });\n    }\n\n    /**\n     * Get tab name from button element\n     * @param {HTMLElement} button - Tab button element\n     * @returns {string} - Tab name\n     */\n    getTabNameFromButton(button) {\n        const text = button.textContent.toLowerCase();\n        if (text.includes('events')) return 'events';\n        if (text.includes('activity')) return 'activity';\n        if (text.includes('agents')) return 'agents';\n        if (text.includes('tools')) return 'tools';\n        if (text.includes('files')) return 'files';\n        if (text.includes('code')) return 'code';\n        if (text.includes('sessions')) return 'sessions';\n        if (text.includes('system')) return 'system';\n        return 'events';\n    }\n\n    /**\n     * Switch to specified tab\n     * @param {string} tabName - Name of tab to switch to\n     */\n    switchTab(tabName) {\n        console.log(`[DEBUG] switchTab called with tabName: ${tabName}`);\n        const previousTab = this.currentTab;\n        this.currentTab = tabName;\n\n        // Update tab button active states\n        document.querySelectorAll('.tab-button').forEach(btn => {\n            btn.classList.remove('active');\n            if (this.getTabNameFromButton(btn) === tabName) {\n                btn.classList.add('active');\n            }\n        });\n\n        // Show/hide tab content using CSS classes\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n\n        const activeTab = document.getElementById(`${tabName}-tab`);\n        if (activeTab) {\n            activeTab.classList.add('active');\n        }\n\n        // Clear previous selections when switching tabs\n        this.clearUnifiedSelection();\n\n        // Trigger tab change event for other modules\n        document.dispatchEvent(new CustomEvent('tabChanged', {\n            detail: {\n                newTab: tabName,\n                previousTab: previousTab\n            }\n        }));\n\n        // Auto-scroll to bottom after a brief delay to ensure content is rendered\n        setTimeout(() => {\n            if (this.autoScroll) {\n                this.scrollCurrentTabToBottom();\n            }\n        }, 100);\n    }\n\n    /**\n     * Handle unified arrow navigation across tabs\n     * @param {number} direction - Navigation direction (1 for down, -1 for up)\n     */\n    handleUnifiedArrowNavigation(direction) {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let newIndex = tabNav.selectedIndex + direction;\n\n        // Handle bounds\n        if (tabNav.items.length === 0) return;\n\n        if (newIndex < 0) {\n            newIndex = tabNav.items.length - 1;\n        } else if (newIndex >= tabNav.items.length) {\n            newIndex = 0;\n        }\n\n        this.selectCardByIndex(this.currentTab, newIndex);\n    }\n\n    /**\n     * Handle unified Enter key across all tabs\n     */\n    handleUnifiedEnterKey() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav || tabNav.selectedIndex === -1) return;\n\n        const selectedElement = tabNav.items[tabNav.selectedIndex];\n        if (selectedElement && selectedElement.onclick) {\n            selectedElement.onclick();\n        }\n    }\n\n    /**\n     * Clear all unified selection states\n     */\n    clearUnifiedSelection() {\n        // Clear all tab navigation states\n        Object.keys(this.tabNavigation).forEach(tabName => {\n            this.tabNavigation[tabName].selectedIndex = -1;\n        });\n\n        // Clear card selection\n        this.clearCardSelection();\n    }\n\n    /**\n     * Update tab navigation items for current tab\n     * Should be called after tab content is rendered\n     */\n    updateTabNavigationItems() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let containerSelector;\n        switch (this.currentTab) {\n            case 'events':\n                containerSelector = '#events-list .event-item';\n                break;\n            case 'agents':\n                containerSelector = '#agents-list .event-item';\n                break;\n            case 'tools':\n                containerSelector = '#tools-list .event-item';\n                break;\n            case 'files':\n                containerSelector = '#files-list .event-item';\n                break;\n        }\n\n        if (containerSelector) {\n            tabNav.items = Array.from(document.querySelectorAll(containerSelector));\n        }\n    }\n\n    /**\n     * Select card by index for specified tab\n     * @param {string} tabName - Tab name\n     * @param {number} index - Index of item to select\n     */\n    selectCardByIndex(tabName, index) {\n        const tabNav = this.tabNavigation[tabName];\n        if (!tabNav || index < 0 || index >= tabNav.items.length) return;\n\n        // Update navigation state\n        tabNav.selectedIndex = index;\n\n        // Update visual selection\n        this.updateUnifiedSelectionUI();\n\n        // If this is a different tab selection, record the card selection\n        const selectedElement = tabNav.items[index];\n        if (selectedElement) {\n            // Extract data from the element to populate selectedCard\n            this.selectCard(tabName, index, this.getCardType(tabName), index);\n        }\n\n        // Show details for the selected item\n        this.showCardDetails(tabName, index);\n    }\n\n    /**\n     * Update visual selection UI for unified navigation\n     */\n    updateUnifiedSelectionUI() {\n        // Clear all existing selections\n        document.querySelectorAll('.event-item.keyboard-selected').forEach(el => {\n            el.classList.remove('keyboard-selected');\n        });\n\n        // Apply selection to current tab's selected item\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (tabNav && tabNav.selectedIndex !== -1 && tabNav.items[tabNav.selectedIndex]) {\n            tabNav.items[tabNav.selectedIndex].classList.add('keyboard-selected');\n        }\n    }\n\n    /**\n     * Show card details for specified tab and index\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     */\n    showCardDetails(tabName, index) {\n        // Dispatch event for other modules to handle\n        document.dispatchEvent(new CustomEvent('showCardDetails', {\n            detail: {\n                tabName: tabName,\n                index: index\n            }\n        }));\n    }\n\n    /**\n     * Select a specific card\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     * @param {string} type - Item type\n     * @param {*} data - Item data\n     */\n    selectCard(tabName, index, type, data) {\n        // Clear previous selection\n        this.clearCardSelection();\n\n        // Update selection state\n        this.selectedCard = {\n            tab: tabName,\n            index: index,\n            type: type,\n            data: data\n        };\n\n        this.updateCardSelectionUI();\n\n        console.log('Card selected:', this.selectedCard);\n    }\n\n    /**\n     * Clear card selection\n     */\n    clearCardSelection() {\n        // Clear visual selection from all tabs\n        document.querySelectorAll('.event-item.selected, .file-item.selected').forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Reset selection state\n        this.selectedCard = {\n            tab: null,\n            index: null,\n            type: null,\n            data: null\n        };\n    }\n\n    /**\n     * Update card selection UI\n     */\n    updateCardSelectionUI() {\n        if (!this.selectedCard.tab || this.selectedCard.index === null) return;\n\n        // Get the list container for the selected tab\n        let listContainer;\n        switch (this.selectedCard.tab) {\n            case 'events':\n                listContainer = document.getElementById('events-list');\n                break;\n            case 'agents':\n                listContainer = document.getElementById('agents-list');\n                break;\n            case 'tools':\n                listContainer = document.getElementById('tools-list');\n                break;\n            case 'files':\n                listContainer = document.getElementById('files-list');\n                break;\n        }\n\n        if (listContainer) {\n            const items = listContainer.querySelectorAll('.event-item, .file-item');\n            if (items[this.selectedCard.index]) {\n                items[this.selectedCard.index].classList.add('selected');\n            }\n        }\n    }\n\n    /**\n     * Get card type based on tab name\n     * @param {string} tabName - Tab name\n     * @returns {string} - Card type\n     */\n    getCardType(tabName) {\n        switch (tabName) {\n            case 'events': return 'event';\n            case 'agents': return 'agent';\n            case 'tools': return 'tool';\n            case 'files': return 'file';\n            default: return 'unknown';\n        }\n    }\n\n    /**\n     * Scroll current tab to bottom\n     */\n    scrollCurrentTabToBottom() {\n        const tabId = `${this.currentTab}-list`;\n        const element = document.getElementById(tabId);\n        if (element && this.autoScroll) {\n            element.scrollTop = element.scrollHeight;\n        }\n    }\n\n    /**\n     * Clear selection for cleanup\n     */\n    clearSelection() {\n        this.clearCardSelection();\n        this.clearUnifiedSelection();\n    }\n\n    /**\n     * Get current tab name\n     * @returns {string} - Current tab name\n     */\n    getCurrentTab() {\n        return this.currentTab;\n    }\n\n    /**\n     * Get selected card info\n     * @returns {Object} - Selected card state\n     */\n    getSelectedCard() {\n        return { ...this.selectedCard };\n    }\n\n    /**\n     * Get tab navigation state\n     * @returns {Object} - Tab navigation state\n     */\n    getTabNavigation() {\n        return { ...this.tabNavigation };\n    }\n\n    /**\n     * Set auto-scroll behavior\n     * @param {boolean} enabled - Whether to enable auto-scroll\n     */\n    setAutoScroll(enabled) {\n        this.autoScroll = enabled;\n    }\n\n    /**\n     * Get auto-scroll state\n     * @returns {boolean} - Auto-scroll enabled state\n     */\n    getAutoScroll() {\n        return this.autoScroll;\n    }\n}\n// ES6 Module export\nexport { UIStateManager };\nexport default UIStateManager;\n"],"names":["io","window","SocketClient","constructor","this","socket","port","connectionCallbacks","connect","disconnect","error","event","eventSchema","required","optional","isConnected","isConnecting","lastConnectTime","disconnectTime","events","sessions","Map","currentSessionId","eventQueue","maxQueueSize","retryAttempts","maxRetryAttempts","retryDelays","pendingEmissions","lastPingTime","lastPongTime","pingTimeout","healthCheckInterval","startStatusCheckFallback","startHealthMonitoring","url","connected","connecting","console","log","setTimeout","doConnect","notifyConnectionStatus","autoConnect","reconnection","reconnectionDelay","reconnectionDelayMax","reconnectionAttempts","timeout","forceNew","transports","pingInterval","setupSocketHandlers","on","previouslyConnected","Date","now","downtime","toFixed","flushEventQueue","forEach","callback","id","requestStatus","reason","disconnectInfo","timestamp","toISOString","wasConnected","uptimeSeconds","lastPing","lastPong","includes","scheduleReconnect","errorMsg","message","description","addEvent","type","data","uri","retry_attempt","validatedEvent","validateEventSchema","warn","startsWith","transformedEvent","transformEvent","emit","client_time","subtype","Array","isArray","length","count","total_available","notifyEventUpdate","updateSessions","current_session","emitWithRetry","options","maxRetries","onSuccess","onFailure","emissionId","Math","random","attemptEmission","attemptNum","delete","delay","set","scheduledTime","queueEvent","removed","shift","push","item","index","requestHistory","params","limit","event_types","eventData","notify","session_id","sessionId","has","startTime","lastActivity","eventCount","working_directory","git_branch","session","get","possiblePaths","cwd","working_dir","workingDirectory","instance_info","path","trim","sessionsData","clearEvents","clear","refreshHistory","getEventsBySession","filter","onConnection","eventType","onEventUpdate","off","status","updateConnectionStatusDOM","document","dispatchEvent","CustomEvent","detail","statusElement","getElementById","innerHTML","className","getConnectionState","socketId","validated","source","value","originalEventName","eventName","toLowerCase","replace","substring","subtypePart","mainType","subtypeParts","split","join","parts","protectedFields","Object","keys","key","JSON","parse","stringify","hook_event_name","tool_name","has_tool_parameters","tool_parameters","has_data","k","file_path","notebook_path","full_parameters","getState","setInterval","timeSinceLastPing","stopHealthMonitoring","clearInterval","checkAndUpdateStatus","readyState","addEventListener","actualStatus","actualType","currentText","textContent","currentClass","expectedClass","destroy","getConnectionMetrics","uptime","queuedEvents","size","SocketManager","socketClient","Set","eventUpdateCallbacks","setupSocketEventHandlers","updateInitialConnectionStatus","e","handleConnectionStatusChange","updateConnectionStatus","setupGitBranchListener","success","footerBranch","branch","style","display","querySelector","statusIndicator","getSocketClient","getSocket","onConnectionStatusChange","add","offConnectionStatusChange","offEventUpdate","toggleConnectionControls","controlsRow","toggleBtn","classList","contains","remove","setupConnectionControls","connectBtn","disconnectBtn","connectionToggleBtn","initializeFromURL","portInput","connectPort","location","protocol","UIStateManager","currentTab","autoScroll","selectedCard","tab","tabNavigation","selectedIndex","items","agents","tools","files","setupEventHandlers","setupTabNavigation","setupUnifiedKeyboardNavigation","querySelectorAll","button","tabName","getTabNameFromButton","switchTab","activeElement","tagName","preventDefault","handleUnifiedArrowNavigation","handleUnifiedEnterKey","clearUnifiedSelection","text","previousTab","btn","content","activeTab","newTab","scrollCurrentTabToBottom","direction","tabNav","newIndex","selectCardByIndex","selectedElement","onclick","clearCardSelection","updateTabNavigationItems","containerSelector","from","updateUnifiedSelectionUI","selectCard","getCardType","showCardDetails","el","updateCardSelectionUI","listContainer","tabId","element","scrollTop","scrollHeight","clearSelection","getCurrentTab","getSelectedCard","getTabNavigation","setAutoScroll","enabled","getAutoScroll"],"mappings":"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"}