{"version":3,"file":"socket-client.js","sources":["../js/socket-client.js","../js/components/socket-manager.js","../js/components/ui-state-manager.js"],"sourcesContent":["/**\n * Socket.IO Client for Claude MPM Dashboard\n * Handles WebSocket connections and event processing\n */\n\n// Access the global io from window object in ES6 module context\nconst io = window.io;\n\nclass SocketClient {\n    constructor() {\n        this.socket = null;\n        this.port = null; // Store the current port\n        this.connectionCallbacks = {\n            connect: [],\n            disconnect: [],\n            error: [],\n            event: []\n        };\n        \n        // Event schema validation\n        this.eventSchema = {\n            required: ['source', 'type', 'subtype', 'timestamp', 'data'],\n            optional: ['event', 'session_id']\n        };\n\n        // Connection state\n        this.isConnected = false;\n        this.isConnecting = false;\n        this.lastConnectTime = null;\n        this.disconnectTime = null;\n\n        // Event processing\n        this.events = [];\n        this.sessions = new Map();\n        this.currentSessionId = null;\n\n        // Event queue for disconnection periods\n        this.eventQueue = [];\n        this.maxQueueSize = 100;\n        \n        // Retry configuration - Match server settings\n        this.retryAttempts = 0;\n        this.maxRetryAttempts = 5;  // Increased from 3 to 5 for better stability\n        this.retryDelays = [1000, 2000, 3000, 4000, 5000]; // Exponential backoff with 5 attempts\n        this.pendingEmissions = new Map(); // Track pending emissions for retry\n        \n        // Health monitoring\n        this.lastPingTime = null;\n        this.lastPongTime = null;\n        this.pingTimeout = 90000; // 90 seconds for health check (more lenient than Socket.IO timeout)\n        this.healthCheckInterval = null;\n        \n        // Start periodic status check as fallback mechanism\n        this.startStatusCheckFallback();\n        this.startHealthMonitoring();\n    }\n\n    /**\n     * Connect to Socket.IO server\n     * @param {string} port - Port number to connect to\n     */\n    connect(port = '8765') {\n        // Store the port for later use\n        this.port = port;\n        const url = `http://localhost:${port}`;\n\n        // Prevent multiple simultaneous connections\n        if (this.socket && (this.socket.connected || this.socket.connecting)) {\n            console.log('Already connected or connecting, disconnecting first...');\n            this.socket.disconnect();\n            // Wait a moment for cleanup\n            setTimeout(() => this.doConnect(url), 100);\n            return;\n        }\n\n        this.doConnect(url);\n    }\n\n    /**\n     * Perform the actual connection\n     * @param {string} url - Socket.IO server URL\n     */\n    doConnect(url) {\n        console.log(`Connecting to Socket.IO server at ${url}`);\n        \n        // Check if io is available\n        if (typeof io === 'undefined') {\n            console.error('Socket.IO library not loaded! Make sure socket.io.min.js is loaded before this script.');\n            this.notifyConnectionStatus('Socket.IO library not loaded', 'error');\n            return;\n        }\n        \n        this.isConnecting = true;\n        this.notifyConnectionStatus('Connecting...', 'connecting');\n\n        this.socket = io(url, {\n            autoConnect: true,\n            reconnection: true,\n            reconnectionDelay: 1000,\n            reconnectionDelayMax: 5000,\n            reconnectionAttempts: 5,  // Try 5 times then stop (was Infinity which can cause issues)\n            timeout: 20000,  // Connection timeout\n            forceNew: true,\n            transports: ['websocket', 'polling'],\n            pingInterval: 45000,  // CRITICAL: Must match server's 45 seconds\n            pingTimeout: 20000    // CRITICAL: Must match server's 20 seconds\n        });\n\n        this.setupSocketHandlers();\n    }\n\n    /**\n     * Setup Socket.IO event handlers\n     */\n    setupSocketHandlers() {\n        this.socket.on('connect', () => {\n            console.log('Connected to Socket.IO server');\n            const previouslyConnected = this.isConnected;\n            this.isConnected = true;\n            this.isConnecting = false;\n            this.lastConnectTime = Date.now();\n            this.retryAttempts = 0; // Reset retry counter on successful connect\n            \n            // Calculate downtime if this is a reconnection\n            if (this.disconnectTime && previouslyConnected === false) {\n                const downtime = (Date.now() - this.disconnectTime) / 1000;\n                console.log(`Reconnected after ${downtime.toFixed(1)}s downtime`);\n                \n                // Flush queued events after reconnection\n                this.flushEventQueue();\n            }\n            \n            this.notifyConnectionStatus('Connected', 'connected');\n\n            // Emit connect callback\n            this.connectionCallbacks.connect.forEach(callback =>\n                callback(this.socket.id)\n            );\n\n            this.requestStatus();\n            // History is now automatically sent by server on connection\n            // No need to explicitly request it\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            // Enhanced logging for debugging disconnection issues\n            const disconnectInfo = {\n                reason: reason,\n                timestamp: new Date().toISOString(),\n                wasConnected: this.isConnected,\n                uptimeSeconds: this.lastConnectTime ? ((Date.now() - this.lastConnectTime) / 1000).toFixed(1) : 0,\n                lastPing: this.lastPingTime ? ((Date.now() - this.lastPingTime) / 1000).toFixed(1) + 's ago' : 'never',\n                lastPong: this.lastPongTime ? ((Date.now() - this.lastPongTime) / 1000).toFixed(1) + 's ago' : 'never'\n            };\n            \n            console.log('Disconnected from server:', disconnectInfo);\n            \n            this.isConnected = false;\n            this.isConnecting = false;\n            this.disconnectTime = Date.now();\n            \n            this.notifyConnectionStatus(`Disconnected: ${reason}`, 'disconnected');\n\n            // Emit disconnect callback\n            this.connectionCallbacks.disconnect.forEach(callback =>\n                callback(reason)\n            );\n            \n            // Detailed reason analysis for auto-reconnect decision\n            const reconnectReasons = [\n                'transport close',      // Network issue\n                'ping timeout',         // Server not responding\n                'transport error',      // Connection error\n                'io server disconnect', // Server initiated disconnect (might be restart)\n            ];\n            \n            if (reconnectReasons.includes(reason)) {\n                console.log(`Auto-reconnect triggered for reason: ${reason}`);\n                this.scheduleReconnect();\n            } else if (reason === 'io client disconnect') {\n                console.log('Client-initiated disconnect, not auto-reconnecting');\n            } else {\n                console.log(`Unknown disconnect reason: ${reason}, attempting reconnect anyway`);\n                this.scheduleReconnect();\n            }\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.isConnecting = false;\n            const errorMsg = error.message || error.description || 'Unknown error';\n            this.notifyConnectionStatus(`Connection Error: ${errorMsg}`, 'disconnected');\n\n            // Add error event\n            this.addEvent({\n                type: 'connection.error',\n                timestamp: new Date().toISOString(),\n                data: { \n                    error: errorMsg, \n                    url: this.socket.io.uri,\n                    retry_attempt: this.retryAttempts\n                }\n            });\n\n            // Emit error callback\n            this.connectionCallbacks.error.forEach(callback =>\n                callback(errorMsg)\n            );\n            \n            // Schedule reconnect with backoff\n            this.scheduleReconnect();\n        });\n\n        // Primary event handler - this is what the server actually emits\n        this.socket.on('claude_event', (data) => {\n            console.log('Received claude_event:', data);\n            \n            // Validate event schema\n            const validatedEvent = this.validateEventSchema(data);\n            if (!validatedEvent) {\n                console.warn('Invalid event schema received:', data);\n                return;\n            }\n            \n            // Transform event to match expected format (for backward compatibility)\n            const transformedEvent = this.transformEvent(validatedEvent);\n            console.log('Transformed event:', transformedEvent);\n            this.addEvent(transformedEvent);\n        });\n\n        // Add ping/pong handlers for health monitoring\n        this.socket.on('ping', (data) => {\n            // console.log('Received ping from server');\n            this.lastPingTime = Date.now();\n            \n            // Send pong response immediately\n            this.socket.emit('pong', { \n                timestamp: data.timestamp,\n                client_time: Date.now()\n            });\n        });\n        \n        // Track pong responses from server\n        this.socket.on('pong', (data) => {\n            this.lastPongTime = Date.now();\n            // console.log('Received pong from server');\n        });\n        \n        // Session and event handlers (legacy/fallback)\n        this.socket.on('session.started', (data) => {\n            this.addEvent({ type: 'session', subtype: 'started', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('session.ended', (data) => {\n            this.addEvent({ type: 'session', subtype: 'ended', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.request', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'request', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.response', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'response', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.loaded', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'loaded', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.executed', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'executed', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.pre', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'pre', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.post', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'post', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('todo.updated', (data) => {\n            this.addEvent({ type: 'todo', subtype: 'updated', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('memory.operation', (data) => {\n            this.addEvent({ type: 'memory', subtype: 'operation', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('log.entry', (data) => {\n            this.addEvent({ type: 'log', subtype: 'entry', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('history', (data) => {\n            console.log('Received event history:', data);\n            if (data && Array.isArray(data.events)) {\n                console.log(`Processing ${data.events.length} historical events (${data.count} sent, ${data.total_available} total available)`);\n                // Add events in the order received (should already be chronological - oldest first)\n                // Transform each historical event to match expected format\n                data.events.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n                console.log(`Event history loaded: ${data.events.length} events added to dashboard`);\n            } else if (Array.isArray(data)) {\n                // Handle legacy format for backward compatibility\n                console.log('Received legacy event history format:', data.length, 'events');\n                data.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n            }\n        });\n\n        this.socket.on('system.status', (data) => {\n            console.log('Received system status:', data);\n            if (data.sessions) {\n                this.updateSessions(data.sessions);\n            }\n            if (data.current_session) {\n                this.currentSessionId = data.current_session;\n            }\n        });\n    }\n\n    /**\n     * Disconnect from Socket.IO server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.port = null; // Clear the stored port\n        this.isConnected = false;\n        this.isConnecting = false;\n    }\n\n    /**\n     * Emit an event with retry support\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     * @param {Object} options - Options for retry behavior\n     */\n    emitWithRetry(event, data = null, options = {}) {\n        const { \n            maxRetries = 3,\n            retryDelays = [1000, 2000, 4000],\n            onSuccess = null,\n            onFailure = null\n        } = options;\n        \n        const emissionId = `${event}_${Date.now()}_${Math.random()}`;\n        \n        const attemptEmission = (attemptNum = 0) => {\n            if (!this.socket || !this.socket.connected) {\n                // Queue for later if disconnected\n                if (attemptNum === 0) {\n                    this.queueEvent(event, data);\n                    console.log(`Queued ${event} for later emission (disconnected)`);\n                    if (onFailure) onFailure('disconnected');\n                }\n                return;\n            }\n            \n            try {\n                // Attempt emission\n                this.socket.emit(event, data);\n                console.log(`Emitted ${event} successfully`);\n                \n                // Remove from pending\n                this.pendingEmissions.delete(emissionId);\n                \n                if (onSuccess) onSuccess();\n                \n            } catch (error) {\n                console.error(`Failed to emit ${event} (attempt ${attemptNum + 1}):`, error);\n                \n                if (attemptNum < maxRetries - 1) {\n                    const delay = retryDelays[attemptNum] || retryDelays[retryDelays.length - 1];\n                    console.log(`Retrying ${event} in ${delay}ms...`);\n                    \n                    // Store pending emission\n                    this.pendingEmissions.set(emissionId, {\n                        event,\n                        data,\n                        attemptNum: attemptNum + 1,\n                        scheduledTime: Date.now() + delay\n                    });\n                    \n                    setTimeout(() => attemptEmission(attemptNum + 1), delay);\n                } else {\n                    console.error(`Failed to emit ${event} after ${maxRetries} attempts`);\n                    this.pendingEmissions.delete(emissionId);\n                    if (onFailure) onFailure('max_retries_exceeded');\n                }\n            }\n        };\n        \n        attemptEmission();\n    }\n    \n    /**\n     * Queue an event for later emission\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     */\n    queueEvent(event, data) {\n        if (this.eventQueue.length >= this.maxQueueSize) {\n            // Remove oldest event if queue is full\n            const removed = this.eventQueue.shift();\n            console.warn(`Event queue full, dropped oldest event: ${removed.event}`);\n        }\n        \n        this.eventQueue.push({\n            event,\n            data,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Flush queued events after reconnection\n     */\n    flushEventQueue() {\n        if (this.eventQueue.length === 0) return;\n        \n        console.log(`Flushing ${this.eventQueue.length} queued events...`);\n        const events = [...this.eventQueue];\n        this.eventQueue = [];\n        \n        // Emit each queued event with a small delay between them\n        events.forEach((item, index) => {\n            setTimeout(() => {\n                if (this.socket && this.socket.connected) {\n                    this.socket.emit(item.event, item.data);\n                    console.log(`Flushed queued event: ${item.event}`);\n                }\n            }, index * 100); // 100ms between each event\n        });\n    }\n    \n    /**\n     * Schedule a reconnection attempt with exponential backoff\n     */\n    scheduleReconnect() {\n        if (this.retryAttempts >= this.maxRetryAttempts) {\n            console.log('Max reconnection attempts reached, stopping auto-reconnect');\n            this.notifyConnectionStatus('Reconnection failed', 'disconnected');\n            return;\n        }\n        \n        const delay = this.retryDelays[this.retryAttempts] || this.retryDelays[this.retryDelays.length - 1];\n        this.retryAttempts++;\n        \n        console.log(`Scheduling reconnect attempt ${this.retryAttempts}/${this.maxRetryAttempts} in ${delay}ms...`);\n        this.notifyConnectionStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');\n        \n        setTimeout(() => {\n            if (!this.isConnected && this.port) {\n                console.log(`Attempting reconnection ${this.retryAttempts}/${this.maxRetryAttempts}...`);\n                this.connect(this.port);\n            }\n        }, delay);\n    }\n    \n    /**\n     * Request server status\n     */\n    requestStatus() {\n        if (this.socket && this.socket.connected) {\n            console.log('Requesting server status...');\n            this.emitWithRetry('request.status', null, {\n                maxRetries: 2,\n                retryDelays: [500, 1000]\n            });\n        }\n    }\n\n    /**\n     * Request event history from server\n     * @param {Object} options - History request options\n     * @param {number} options.limit - Maximum number of events to retrieve (default: 50)\n     * @param {Array<string>} options.event_types - Optional filter by event types\n     */\n    requestHistory(options = {}) {\n        if (this.socket && this.socket.connected) {\n            const params = {\n                limit: options.limit || 50,\n                event_types: options.event_types || []\n            };\n            console.log('Requesting event history...', params);\n            this.emitWithRetry('get_history', params, {\n                maxRetries: 3,\n                retryDelays: [1000, 2000, 3000],\n                onFailure: (reason) => {\n                    console.error(`Failed to request history: ${reason}`);\n                }\n            });\n        } else {\n            console.warn('Cannot request history: not connected to server');\n        }\n    }\n\n    /**\n     * Add event to local storage and notify listeners\n     * @param {Object} eventData - Event data\n     * @param {boolean} notify - Whether to notify listeners (default: true)\n     */\n    addEvent(eventData, notify = true) {\n        // Ensure event has required fields\n        if (!eventData.timestamp) {\n            eventData.timestamp = new Date().toISOString();\n        }\n        if (!eventData.id) {\n            eventData.id = Date.now() + Math.random();\n        }\n\n        this.events.push(eventData);\n\n        // Update session tracking\n        if (eventData.data && eventData.data.session_id) {\n            const sessionId = eventData.data.session_id;\n            if (!this.sessions.has(sessionId)) {\n                this.sessions.set(sessionId, {\n                    id: sessionId,\n                    startTime: eventData.timestamp,\n                    lastActivity: eventData.timestamp,\n                    eventCount: 0,\n                    working_directory: null,\n                    git_branch: null\n                });\n            }\n            const session = this.sessions.get(sessionId);\n            session.lastActivity = eventData.timestamp;\n            session.eventCount++;\n            \n            // Extract working directory from event data if available (prioritize newer data)\n            // Check multiple possible locations for working directory\n            const possiblePaths = [\n                eventData.data.cwd,\n                eventData.data.working_directory,\n                eventData.data.working_dir,\n                eventData.data.workingDirectory,\n                eventData.data.instance_info?.working_dir,\n                eventData.data.instance_info?.working_directory,\n                eventData.data.instance_info?.cwd,\n                eventData.cwd,\n                eventData.working_directory,\n                eventData.working_dir\n            ];\n            \n            for (const path of possiblePaths) {\n                if (path && typeof path === 'string' && path.trim()) {\n                    session.working_directory = path;\n                    console.log(`[SOCKET-CLIENT] Found working directory for session ${sessionId}:`, path);\n                    break;\n                }\n            }\n            \n            // Extract git branch if available\n            if (eventData.data.git_branch) {\n                session.git_branch = eventData.data.git_branch;\n            } else if (eventData.data.instance_info && eventData.data.instance_info.git_branch) {\n                session.git_branch = eventData.data.instance_info.git_branch;\n            }\n        }\n\n        if (notify) {\n            this.notifyEventUpdate();\n        }\n    }\n\n    /**\n     * Update sessions from server data\n     * @param {Array} sessionsData - Sessions data from server\n     */\n    updateSessions(sessionsData) {\n        if (Array.isArray(sessionsData)) {\n            sessionsData.forEach(session => {\n                this.sessions.set(session.id, session);\n            });\n        }\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.events = [];\n        this.sessions.clear();\n        this.notifyEventUpdate();\n    }\n\n    /**\n     * Clear events and request fresh history from server\n     * @param {Object} options - History request options (same as requestHistory)\n     */\n    refreshHistory(options = {}) {\n        this.clearEvents();\n        this.requestHistory(options);\n    }\n\n    /**\n     * Get filtered events by session\n     * @param {string} sessionId - Session ID to filter by (null for all)\n     * @returns {Array} Filtered events\n     */\n    getEventsBySession(sessionId = null) {\n        if (!sessionId) {\n            return this.events;\n        }\n        return this.events.filter(event =>\n            event.data && event.data.session_id === sessionId\n        );\n    }\n\n    /**\n     * Register callback for connection events\n     * @param {string} eventType - Type of event (connect, disconnect, error)\n     * @param {Function} callback - Callback function\n     */\n    onConnection(eventType, callback) {\n        if (this.connectionCallbacks[eventType]) {\n            this.connectionCallbacks[eventType].push(callback);\n        }\n    }\n\n    /**\n     * Register callback for event updates\n     * @param {Function} callback - Callback function\n     */\n    onEventUpdate(callback) {\n        this.connectionCallbacks.event.push(callback);\n    }\n\n    /**\n     * Subscribe to socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function\n     */\n    on(event, callback) {\n        if (this.socket) {\n            return this.socket.on(event, callback);\n        } else {\n            console.warn(`Cannot subscribe to '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Unsubscribe from socket events (proxy to underlying socket)\n     * @param {string} event - Event name\n     * @param {Function} callback - Callback function (optional)\n     */\n    off(event, callback) {\n        if (this.socket) {\n            return this.socket.off(event, callback);\n        } else {\n            console.warn(`Cannot unsubscribe from '${event}': socket not initialized`);\n        }\n    }\n\n    /**\n     * Notify connection status change\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    notifyConnectionStatus(status, type) {\n        console.log(`SocketClient: Connection status changed to '${status}' (${type})`);\n\n        // Direct DOM update - immediate and reliable\n        this.updateConnectionStatusDOM(status, type);\n\n        // Also dispatch custom event for other modules\n        document.dispatchEvent(new CustomEvent('socketConnectionStatus', {\n            detail: { status, type }\n        }));\n    }\n\n    /**\n     * Directly update the connection status DOM element\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    updateConnectionStatusDOM(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Update the text content while preserving the indicator span\n            statusElement.innerHTML = `<span>●</span> ${status}`;\n\n            // Update the CSS class for styling\n            statusElement.className = `status-badge status-${type}`;\n\n            console.log(`SocketClient: Direct DOM update - status: '${status}' (${type})`);\n        } else {\n            console.warn('SocketClient: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Notify event update\n     */\n    notifyEventUpdate() {\n        this.connectionCallbacks.event.forEach(callback =>\n            callback(this.events, this.sessions)\n        );\n\n        // Also dispatch custom event\n        document.dispatchEvent(new CustomEvent('socketEventUpdate', {\n            detail: { events: this.events, sessions: this.sessions }\n        }));\n    }\n\n    /**\n     * Get connection state\n     * @returns {Object} Connection state\n     */\n    getConnectionState() {\n        return {\n            isConnected: this.isConnected,\n            isConnecting: this.isConnecting,\n            socketId: this.socket ? this.socket.id : null\n        };\n    }\n\n    /**\n     * Validate event against expected schema\n     * @param {Object} eventData - Raw event data\n     * @returns {Object|null} Validated event or null if invalid\n     */\n    validateEventSchema(eventData) {\n        if (!eventData || typeof eventData !== 'object') {\n            console.warn('Event data is not an object:', eventData);\n            return null;\n        }\n        \n        // Make a copy to avoid modifying the original\n        const validated = { ...eventData };\n        \n        // Check and provide defaults for required fields\n        if (!validated.source) {\n            validated.source = 'system';  // Default source for backward compatibility\n        }\n        if (!validated.type) {\n            // If there's an event field, use it as the type\n            if (validated.event) {\n                validated.type = validated.event;\n            } else {\n                validated.type = 'unknown';\n            }\n        }\n        if (!validated.subtype) {\n            validated.subtype = 'generic';\n        }\n        if (!validated.timestamp) {\n            validated.timestamp = new Date().toISOString();\n        }\n        if (!validated.data) {\n            validated.data = {};\n        }\n        \n        // Ensure data field is an object\n        if (validated.data && typeof validated.data !== 'object') {\n            validated.data = { value: validated.data };\n        }\n        \n        console.log('Validated event:', validated);\n        return validated;\n    }\n    \n    /**\n     * Transform received event to match expected dashboard format\n     * @param {Object} eventData - Raw event data from server\n     * @returns {Object} Transformed event\n     */\n    transformEvent(eventData) {\n        // Handle multiple event structures:\n        // 1. Hook events: { type: 'hook.pre_tool', timestamp: '...', data: {...} }\n        // 2. Legacy events: { event: 'TestStart', timestamp: '...', ... }\n        // 3. Standard events: { type: 'session', subtype: 'started', ... }\n\n        if (!eventData) {\n            return eventData; // Return as-is if null/undefined\n        }\n\n        let transformedEvent = { ...eventData };\n\n        // Handle legacy format with 'event' field but no 'type'\n        if (!eventData.type && eventData.event) {\n            // Map common event names to proper type/subtype\n            const eventName = eventData.event;\n            \n            // Check for known event patterns\n            if (eventName === 'TestStart' || eventName === 'TestEnd') {\n                transformedEvent.type = 'test';\n                transformedEvent.subtype = eventName.toLowerCase().replace('test', '');\n            } else if (eventName === 'SubagentStart' || eventName === 'SubagentStop') {\n                transformedEvent.type = 'subagent';\n                transformedEvent.subtype = eventName.toLowerCase().replace('subagent', '');\n            } else if (eventName === 'ToolCall') {\n                transformedEvent.type = 'tool';\n                transformedEvent.subtype = 'call';\n            } else if (eventName === 'UserPrompt') {\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = 'user_prompt';\n            } else {\n                // Generic fallback for unknown event names\n                // Use 'unknown' for type and the actual eventName for subtype\n                transformedEvent.type = 'unknown';\n                transformedEvent.subtype = eventName.toLowerCase();\n                \n                // Prevent duplicate type/subtype values\n                if (transformedEvent.type === transformedEvent.subtype) {\n                    transformedEvent.subtype = 'event';\n                }\n            }\n            \n            // Remove the 'event' field to avoid confusion\n            delete transformedEvent.event;\n        }\n        // Handle standard format with 'type' field\n        else if (eventData.type) {\n            const type = eventData.type;\n            \n            // Transform 'hook.subtype' format to separate type and subtype\n            if (type.startsWith('hook.')) {\n                const subtype = type.substring(5); // Remove 'hook.' prefix\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = subtype;\n            }\n            // Transform other dotted types like 'session.started' -> type: 'session', subtype: 'started'\n            else if (type.includes('.')) {\n                const [mainType, ...subtypeParts] = type.split('.');\n                transformedEvent.type = mainType;\n                transformedEvent.subtype = subtypeParts.join('.');\n            }\n        }\n        // If no type and no event field, mark as unknown\n        else {\n            transformedEvent.type = 'unknown';\n            transformedEvent.subtype = '';\n        }\n\n        // Store original event name for display purposes (before any transformation)\n        if (!eventData.type && eventData.event) {\n            transformedEvent.originalEventName = eventData.event;\n        } else if (eventData.type) {\n            transformedEvent.originalEventName = eventData.type;\n        }\n\n        // Extract and flatten data fields to top level for dashboard compatibility\n        // The dashboard expects fields like tool_name, agent_type, etc. at the top level\n        if (eventData.data && typeof eventData.data === 'object') {\n            // Protected fields that should never be overwritten by data fields\n            const protectedFields = ['type', 'subtype', 'timestamp', 'id', 'event', 'event_type', 'originalEventName'];\n            \n            // Copy all data fields to the top level, except protected ones\n            Object.keys(eventData.data).forEach(key => {\n                // Only copy if not a protected field\n                if (!protectedFields.includes(key)) {\n                    // Special handling for tool_parameters to ensure it's properly preserved\n                    // This is critical for file path extraction in file-tool-tracker\n                    if (key === 'tool_parameters' && typeof eventData.data[key] === 'object') {\n                        // Deep copy the tool_parameters object to preserve all nested fields\n                        transformedEvent[key] = JSON.parse(JSON.stringify(eventData.data[key]));\n                    } else {\n                        transformedEvent[key] = eventData.data[key];\n                    }\n                } else {\n                    // Log warning if data field would overwrite a protected field\n                    console.warn(`Protected field '${key}' in data object was not copied to top level to preserve event structure`);\n                }\n            });\n            \n            // Keep the original data object for backward compatibility\n            transformedEvent.data = eventData.data;\n        }\n\n        // Add hook_event_name for ActivityTree compatibility\n        // Map the type/subtype structure to the expected hook_event_name format\n        if (transformedEvent.type === 'hook') {\n            if (transformedEvent.subtype === 'pre_tool') {\n                transformedEvent.hook_event_name = 'PreToolUse';\n            } else if (transformedEvent.subtype === 'post_tool') {\n                transformedEvent.hook_event_name = 'PostToolUse';\n            } else if (transformedEvent.subtype === 'subagent_start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'subagent_stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            } else if (transformedEvent.subtype === 'todo_write') {\n                transformedEvent.hook_event_name = 'TodoWrite';\n            } else if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'Start';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'Stop';\n            }\n        } else if (transformedEvent.type === 'subagent') {\n            if (transformedEvent.subtype === 'start') {\n                transformedEvent.hook_event_name = 'SubagentStart';\n            } else if (transformedEvent.subtype === 'stop') {\n                transformedEvent.hook_event_name = 'SubagentStop';\n            }\n        } else if (transformedEvent.type === 'todo' && transformedEvent.subtype === 'updated') {\n            transformedEvent.hook_event_name = 'TodoWrite';\n        }\n\n        // Debug logging for tool events\n        if (transformedEvent.type === 'hook' && (transformedEvent.subtype === 'pre_tool' || transformedEvent.subtype === 'post_tool')) {\n            console.log('Transformed tool event:', {\n                type: transformedEvent.type,\n                subtype: transformedEvent.subtype,\n                hook_event_name: transformedEvent.hook_event_name,\n                tool_name: transformedEvent.tool_name,\n                has_tool_parameters: !!transformedEvent.tool_parameters,\n                tool_parameters: transformedEvent.tool_parameters,\n                has_data: !!transformedEvent.data,\n                keys: Object.keys(transformedEvent).filter(k => k !== 'data')\n            });\n            \n            // Extra debug logging for file-related tools\n            const fileTools = ['Read', 'Write', 'Edit', 'MultiEdit', 'NotebookEdit'];\n            if (fileTools.includes(transformedEvent.tool_name)) {\n                console.log('File tool event details:', {\n                    tool_name: transformedEvent.tool_name,\n                    file_path: transformedEvent.tool_parameters?.file_path,\n                    path: transformedEvent.tool_parameters?.path,\n                    notebook_path: transformedEvent.tool_parameters?.notebook_path,\n                    full_parameters: transformedEvent.tool_parameters\n                });\n            }\n        }\n\n        return transformedEvent;\n    }\n\n    /**\n     * Get current events and sessions\n     * @returns {Object} Current state\n     */\n    getState() {\n        return {\n            events: this.events,\n            sessions: this.sessions,\n            currentSessionId: this.currentSessionId\n        };\n    }\n\n    /**\n     * Start health monitoring\n     * Detects stale connections and triggers reconnection\n     */\n    startHealthMonitoring() {\n        this.healthCheckInterval = setInterval(() => {\n            if (this.isConnected && this.lastPingTime) {\n                const timeSinceLastPing = Date.now() - this.lastPingTime;\n                \n                if (timeSinceLastPing > this.pingTimeout) {\n                    console.warn(`No ping from server for ${timeSinceLastPing/1000}s, connection may be stale`);\n                    \n                    // Force reconnection\n                    if (this.socket) {\n                        console.log('Forcing reconnection due to stale connection...');\n                        this.socket.disconnect();\n                        setTimeout(() => {\n                            if (this.port) {\n                                this.connect(this.port);\n                            }\n                        }, 1000);\n                    }\n                }\n            }\n        }, 10000); // Check every 10 seconds\n    }\n    \n    /**\n     * Stop health monitoring\n     */\n    stopHealthMonitoring() {\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n            this.healthCheckInterval = null;\n        }\n    }\n    \n    /**\n     * Start periodic status check as fallback mechanism\n     * This ensures the UI stays in sync with actual socket state\n     */\n    startStatusCheckFallback() {\n        // Check status every 2 seconds\n        setInterval(() => {\n            this.checkAndUpdateStatus();\n        }, 2000);\n\n        // Initial check after DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => {\n                setTimeout(() => this.checkAndUpdateStatus(), 100);\n            });\n        } else {\n            setTimeout(() => this.checkAndUpdateStatus(), 100);\n        }\n    }\n\n    /**\n     * Check actual socket state and update UI if necessary\n     */\n    checkAndUpdateStatus() {\n        let actualStatus = 'Disconnected';\n        let actualType = 'disconnected';\n\n        if (this.socket) {\n            if (this.socket.connected) {\n                actualStatus = 'Connected';\n                actualType = 'connected';\n                this.isConnected = true;\n                this.isConnecting = false;\n            } else if (this.socket.connecting || this.isConnecting) {\n                actualStatus = 'Connecting...';\n                actualType = 'connecting';\n                this.isConnected = false;\n            } else {\n                actualStatus = 'Disconnected';\n                actualType = 'disconnected';\n                this.isConnected = false;\n                this.isConnecting = false;\n            }\n        }\n\n        // Check if UI needs updating\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            const currentText = statusElement.textContent.replace('●', '').trim();\n            const currentClass = statusElement.className;\n            const expectedClass = `status-badge status-${actualType}`;\n\n            // Update if status text or class doesn't match\n            if (currentText !== actualStatus || currentClass !== expectedClass) {\n                console.log(`SocketClient: Fallback update - was '${currentText}' (${currentClass}), now '${actualStatus}' (${expectedClass})`);\n                this.updateConnectionStatusDOM(actualStatus, actualType);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.stopHealthMonitoring();\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.eventQueue = [];\n        this.pendingEmissions.clear();\n    }\n    \n    /**\n     * Get connection metrics\n     * @returns {Object} Connection metrics\n     */\n    getConnectionMetrics() {\n        return {\n            isConnected: this.isConnected,\n            uptime: this.lastConnectTime ? (Date.now() - this.lastConnectTime) / 1000 : 0,\n            lastPing: this.lastPingTime ? (Date.now() - this.lastPingTime) / 1000 : null,\n            queuedEvents: this.eventQueue.length,\n            pendingEmissions: this.pendingEmissions.size,\n            retryAttempts: this.retryAttempts\n        };\n    }\n}\n\n// ES6 Module export\nexport { SocketClient };\nexport default SocketClient;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.SocketClient = SocketClient;\n","/**\n * Socket Manager Module\n *\n * Handles all socket connection management, event dispatching, and connection state.\n * Provides a centralized interface for socket operations across the dashboard.\n *\n * WHY: Extracted from main dashboard to centralize socket connection logic and\n * provide better separation of concerns. This allows for easier testing and\n * maintenance of connection handling code.\n *\n * DESIGN DECISION: Acts as a wrapper around SocketClient to provide dashboard-specific\n * connection management while maintaining the existing SocketClient interface.\n * Uses event dispatching to notify other modules of connection state changes.\n */\n\n// Import SocketClient (assuming it will be converted to ES6 modules too)\nimport { SocketClient } from '../socket-client.js';\nclass SocketManager {\n    constructor() {\n        this.socketClient = null;\n        this.connectionCallbacks = new Set();\n        this.eventUpdateCallbacks = new Set();\n\n        // Initialize socket client\n        this.socketClient = new SocketClient();\n\n        // Make socketClient globally available (for backward compatibility)\n        window.socketClient = this.socketClient;\n\n        this.setupSocketEventHandlers();\n\n        // Force initial status update after a short delay to ensure DOM is ready\n        setTimeout(() => {\n            this.updateInitialConnectionStatus();\n        }, 100);\n\n        console.log('Socket manager initialized');\n    }\n\n    /**\n     * Set up socket event handlers for connection status and events\n     */\n    setupSocketEventHandlers() {\n        // Listen for connection status changes\n        document.addEventListener('socketConnectionStatus', (e) => {\n            console.log(`SocketManager: Processing connection status update: ${e.detail.status} (${e.detail.type})`);\n            this.handleConnectionStatusChange(e.detail.status, e.detail.type);\n\n            // Notify all registered callbacks\n            this.connectionCallbacks.forEach(callback => {\n                try {\n                    callback(e.detail.status, e.detail.type);\n                } catch (error) {\n                    console.error('Error in connection callback:', error);\n                }\n            });\n        });\n\n        // Set up event update handling\n        if (this.socketClient) {\n            this.socketClient.onEventUpdate((events) => {\n                // Notify all registered callbacks\n                this.eventUpdateCallbacks.forEach(callback => {\n                    try {\n                        callback(events);\n                    } catch (error) {\n                        console.error('Error in event update callback:', error);\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Handle connection status changes\n     * @param {string} status - Connection status text\n     * @param {string} type - Connection type ('connected', 'disconnected', etc.)\n     */\n    handleConnectionStatusChange(status, type) {\n        this.updateConnectionStatus(status, type);\n\n        // Set up git branch listener when connected\n        if (type === 'connected' && this.socketClient && this.socketClient.socket) {\n            this.setupGitBranchListener();\n        }\n    }\n\n    /**\n     * Update initial connection status on dashboard load\n     */\n    updateInitialConnectionStatus() {\n        console.log('SocketManager: Updating initial connection status');\n\n        // Force status check on socket client (uses fallback mechanism)\n        if (this.socketClient && typeof this.socketClient.checkAndUpdateStatus === 'function') {\n            console.log('SocketManager: Using socket client checkAndUpdateStatus method');\n            this.socketClient.checkAndUpdateStatus();\n        } else if (this.socketClient && this.socketClient.socket) {\n            console.log('SocketManager: Checking socket state directly', {\n                connected: this.socketClient.socket.connected,\n                connecting: this.socketClient.socket.connecting,\n                isConnecting: this.socketClient.isConnecting,\n                isConnected: this.socketClient.isConnected\n            });\n\n            if (this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket is already connected, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            } else if (this.socketClient.isConnecting || this.socketClient.socket.connecting) {\n                console.log('SocketManager: Socket is connecting, updating status');\n                this.updateConnectionStatus('Connecting...', 'connecting');\n            } else {\n                console.log('SocketManager: Socket is disconnected, updating status');\n                this.updateConnectionStatus('Disconnected', 'disconnected');\n            }\n        } else {\n            console.log('SocketManager: No socket client or socket found, setting disconnected status');\n            this.updateConnectionStatus('Disconnected', 'disconnected');\n        }\n\n        // Additional fallback - check again after a longer delay in case connection is still establishing\n        setTimeout(() => {\n            console.log('SocketManager: Secondary status check after 1 second');\n            if (this.socketClient && this.socketClient.socket && this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket connected in secondary check, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            }\n        }, 1000);\n    }\n\n    /**\n     * Set up git branch response listener for connected socket\n     */\n    setupGitBranchListener() {\n        // Remove any existing listener first\n        this.socketClient.socket.off('git_branch_response');\n\n        // Add the listener\n        this.socketClient.socket.on('git_branch_response', (data) => {\n            if (data.success) {\n                const footerBranch = document.getElementById('footer-git-branch');\n                if (footerBranch) {\n                    footerBranch.textContent = data.branch || 'unknown';\n                }\n                if (footerBranch) {\n                    footerBranch.style.display = 'inline';\n                }\n            } else {\n                console.error('Git branch request failed:', data.error);\n            }\n        });\n    }\n\n    /**\n     * Update connection status display\n     * @param {string} status - Status text to display\n     * @param {string} type - Status type for styling\n     */\n    updateConnectionStatus(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Check if there's a span indicator first\n            const indicator = statusElement.querySelector('span');\n            if (indicator) {\n                // If there's a span, update the text content after the span\n                const statusIndicator = type === 'connected' ? '●' : '●';\n                statusElement.innerHTML = `<span>${statusIndicator}</span> ${status}`;\n            } else {\n                // If no span, just update text content\n                statusElement.textContent = status;\n            }\n\n            statusElement.className = `status-badge status-${type}`;\n            console.log(`SocketManager: UI updated - status: '${status}' (${type})`);\n        } else {\n            console.error('SocketManager: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Connect to socket server\n     * @param {number} port - Port number to connect to\n     */\n    connect(port) {\n        if (this.socketClient) {\n            this.socketClient.connect(port);\n        }\n    }\n\n    /**\n     * Disconnect from socket server\n     */\n    disconnect() {\n        if (this.socketClient) {\n            this.socketClient.disconnect();\n        }\n    }\n\n    /**\n     * Check if socket is connected\n     * @returns {boolean} - True if connected\n     */\n    isConnected() {\n        return this.socketClient && this.socketClient.isConnected;\n    }\n\n    /**\n     * Check if socket is connecting\n     * @returns {boolean} - True if connecting\n     */\n    isConnecting() {\n        return this.socketClient && this.socketClient.isConnecting;\n    }\n\n    /**\n     * Get the underlying socket client\n     * @returns {SocketClient} - The socket client instance\n     */\n    getSocketClient() {\n        return this.socketClient;\n    }\n\n    /**\n     * Get the raw socket connection\n     * @returns {Socket|null} - The raw socket or null\n     */\n    getSocket() {\n        return this.socketClient ? this.socketClient.socket : null;\n    }\n\n    /**\n     * Register a callback for connection status changes\n     * @param {Function} callback - Callback function(status, type)\n     */\n    onConnectionStatusChange(callback) {\n        this.connectionCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister a connection status callback\n     * @param {Function} callback - Callback to remove\n     */\n    offConnectionStatusChange(callback) {\n        this.connectionCallbacks.delete(callback);\n    }\n\n    /**\n     * Register a callback for event updates\n     * @param {Function} callback - Callback function(events)\n     */\n    onEventUpdate(callback) {\n        this.eventUpdateCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister an event update callback\n     * @param {Function} callback - Callback to remove\n     */\n    offEventUpdate(callback) {\n        this.eventUpdateCallbacks.delete(callback);\n    }\n\n    /**\n     * Toggle connection controls visibility\n     */\n    toggleConnectionControls() {\n        const controlsRow = document.getElementById('connection-controls-row');\n        const toggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (controlsRow && toggleBtn) {\n            const isVisible = controlsRow.classList.contains('show');\n\n            if (isVisible) {\n                controlsRow.classList.remove('show');\n                controlsRow.style.display = 'none';\n                toggleBtn.textContent = 'Connection Settings';\n            } else {\n                controlsRow.classList.add('show');\n                controlsRow.style.display = 'block';\n                toggleBtn.textContent = 'Hide Settings';\n            }\n        }\n    }\n\n    /**\n     * Setup connection control event handlers\n     * Called during dashboard initialization\n     */\n    setupConnectionControls() {\n        const connectBtn = document.getElementById('connect-btn');\n        const disconnectBtn = document.getElementById('disconnect-btn');\n        const connectionToggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (connectBtn) {\n            connectBtn.addEventListener('click', () => {\n                const port = document.getElementById('port-input').value || 8765;\n                this.connect(port);\n            });\n        }\n\n        if (disconnectBtn) {\n            disconnectBtn.addEventListener('click', () => {\n                this.disconnect();\n            });\n        }\n\n        if (connectionToggleBtn) {\n            connectionToggleBtn.addEventListener('click', () => {\n                this.toggleConnectionControls();\n            });\n        }\n    }\n\n    /**\n     * Initialize connection from URL parameters\n     * @param {URLSearchParams} params - URL search parameters\n     */\n    initializeFromURL(params) {\n        const port = params.get('port');\n        const portInput = document.getElementById('port-input');\n\n        // Determine the port to use:\n        // 1. URL parameter 'port'\n        // 2. Current page port (if served via HTTP)\n        // 3. Default port value from input field\n        // 4. Fallback to 8765\n        let connectPort = port;\n        if (!connectPort && window.location.protocol === 'http:') {\n            connectPort = window.location.port || '8765';\n        }\n        if (!connectPort) {\n            connectPort = portInput?.value || '8765';\n        }\n\n        // Update the port input field with the determined port\n        if (portInput) {\n            portInput.value = connectPort;\n        }\n\n        // Auto-connect by default unless explicitly disabled\n        // Changed: Always auto-connect by default even without URL params\n        const shouldAutoConnect = params.get('connect') !== 'false';\n        if (shouldAutoConnect && !this.isConnected() && !this.isConnecting()) {\n            console.log(`SocketManager: Auto-connecting to port ${connectPort}`);\n            this.connect(connectPort);\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketManager };\nexport default SocketManager;\n","/**\n * UI State Manager Module\n *\n * Manages UI state including tab switching, card selection, keyboard navigation,\n * and visual feedback across the dashboard interface.\n *\n * WHY: Extracted from main dashboard to centralize UI state management and\n * provide better separation between business logic and UI state. This makes\n * the UI behavior more predictable and easier to test.\n *\n * DESIGN DECISION: Maintains centralized state for current tab, selected cards,\n * and navigation context while providing a clean API for other modules to\n * interact with UI state changes.\n */\nclass UIStateManager {\n    constructor() {\n        // Current active tab\n        this.currentTab = 'events';\n\n        // Auto-scroll behavior\n        this.autoScroll = true;\n\n        // Selection state - tracks the currently selected card across all tabs\n        this.selectedCard = {\n            tab: null,        // which tab the selection is in\n            index: null,      // index of selected item in that tab\n            type: null,       // 'event', 'agent', 'tool', 'file'\n            data: null        // the actual data object\n        };\n\n        // Navigation state for each tab\n        this.tabNavigation = {\n            events: { selectedIndex: -1, items: [] },\n            agents: { selectedIndex: -1, items: [] },\n            tools: { selectedIndex: -1, items: [] },\n            files: { selectedIndex: -1, items: [] }\n        };\n\n        this.setupEventHandlers();\n        console.log('UI state manager initialized');\n    }\n\n    /**\n     * Set up event handlers for UI interactions\n     */\n    setupEventHandlers() {\n        this.setupTabNavigation();\n        this.setupUnifiedKeyboardNavigation();\n    }\n\n    /**\n     * Set up tab navigation event listeners\n     */\n    setupTabNavigation() {\n        // Tab buttons\n        document.querySelectorAll('.tab-button').forEach(button => {\n            button.addEventListener('click', () => {\n                const tabName = this.getTabNameFromButton(button);\n                this.switchTab(tabName);\n            });\n        });\n    }\n\n    /**\n     * Set up unified keyboard navigation across all tabs\n     */\n    setupUnifiedKeyboardNavigation() {\n        document.addEventListener('keydown', (e) => {\n            // Only handle if not in an input field\n            if (document.activeElement &&\n                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {\n                return;\n            }\n\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.handleUnifiedArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                this.handleUnifiedEnterKey();\n            } else if (e.key === 'Escape') {\n                this.clearUnifiedSelection();\n            }\n        });\n    }\n\n    /**\n     * Get tab name from button element\n     * @param {HTMLElement} button - Tab button element\n     * @returns {string} - Tab name\n     */\n    getTabNameFromButton(button) {\n        const text = button.textContent.toLowerCase();\n        if (text.includes('events')) return 'events';\n        if (text.includes('activity')) return 'activity';\n        if (text.includes('agents')) return 'agents';\n        if (text.includes('tools')) return 'tools';\n        if (text.includes('files')) return 'files';\n        if (text.includes('sessions')) return 'sessions';\n        if (text.includes('system')) return 'system';\n        return 'events';\n    }\n\n    /**\n     * Switch to specified tab\n     * @param {string} tabName - Name of tab to switch to\n     */\n    switchTab(tabName) {\n        console.log(`[DEBUG] switchTab called with tabName: ${tabName}`);\n        const previousTab = this.currentTab;\n        this.currentTab = tabName;\n\n        // Update tab button active states\n        document.querySelectorAll('.tab-button').forEach(btn => {\n            btn.classList.remove('active');\n            if (this.getTabNameFromButton(btn) === tabName) {\n                btn.classList.add('active');\n            }\n        });\n\n        // Show/hide tab content using CSS classes\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n\n        const activeTab = document.getElementById(`${tabName}-tab`);\n        if (activeTab) {\n            activeTab.classList.add('active');\n        }\n\n        // Clear previous selections when switching tabs\n        this.clearUnifiedSelection();\n\n        // Trigger tab change event for other modules\n        document.dispatchEvent(new CustomEvent('tabChanged', {\n            detail: {\n                newTab: tabName,\n                previousTab: previousTab\n            }\n        }));\n\n        // Auto-scroll to bottom after a brief delay to ensure content is rendered\n        setTimeout(() => {\n            if (this.autoScroll) {\n                this.scrollCurrentTabToBottom();\n            }\n        }, 100);\n    }\n\n    /**\n     * Handle unified arrow navigation across tabs\n     * @param {number} direction - Navigation direction (1 for down, -1 for up)\n     */\n    handleUnifiedArrowNavigation(direction) {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let newIndex = tabNav.selectedIndex + direction;\n\n        // Handle bounds\n        if (tabNav.items.length === 0) return;\n\n        if (newIndex < 0) {\n            newIndex = tabNav.items.length - 1;\n        } else if (newIndex >= tabNav.items.length) {\n            newIndex = 0;\n        }\n\n        this.selectCardByIndex(this.currentTab, newIndex);\n    }\n\n    /**\n     * Handle unified Enter key across all tabs\n     */\n    handleUnifiedEnterKey() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav || tabNav.selectedIndex === -1) return;\n\n        const selectedElement = tabNav.items[tabNav.selectedIndex];\n        if (selectedElement && selectedElement.onclick) {\n            selectedElement.onclick();\n        }\n    }\n\n    /**\n     * Clear all unified selection states\n     */\n    clearUnifiedSelection() {\n        // Clear all tab navigation states\n        Object.keys(this.tabNavigation).forEach(tabName => {\n            this.tabNavigation[tabName].selectedIndex = -1;\n        });\n\n        // Clear card selection\n        this.clearCardSelection();\n    }\n\n    /**\n     * Update tab navigation items for current tab\n     * Should be called after tab content is rendered\n     */\n    updateTabNavigationItems() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let containerSelector;\n        switch (this.currentTab) {\n            case 'events':\n                containerSelector = '#events-list .event-item';\n                break;\n            case 'agents':\n                containerSelector = '#agents-list .event-item';\n                break;\n            case 'tools':\n                containerSelector = '#tools-list .event-item';\n                break;\n            case 'files':\n                containerSelector = '#files-list .event-item';\n                break;\n        }\n\n        if (containerSelector) {\n            tabNav.items = Array.from(document.querySelectorAll(containerSelector));\n        }\n    }\n\n    /**\n     * Select card by index for specified tab\n     * @param {string} tabName - Tab name\n     * @param {number} index - Index of item to select\n     */\n    selectCardByIndex(tabName, index) {\n        const tabNav = this.tabNavigation[tabName];\n        if (!tabNav || index < 0 || index >= tabNav.items.length) return;\n\n        // Update navigation state\n        tabNav.selectedIndex = index;\n\n        // Update visual selection\n        this.updateUnifiedSelectionUI();\n\n        // If this is a different tab selection, record the card selection\n        const selectedElement = tabNav.items[index];\n        if (selectedElement) {\n            // Extract data from the element to populate selectedCard\n            this.selectCard(tabName, index, this.getCardType(tabName), index);\n        }\n\n        // Show details for the selected item\n        this.showCardDetails(tabName, index);\n    }\n\n    /**\n     * Update visual selection UI for unified navigation\n     */\n    updateUnifiedSelectionUI() {\n        // Clear all existing selections\n        document.querySelectorAll('.event-item.keyboard-selected').forEach(el => {\n            el.classList.remove('keyboard-selected');\n        });\n\n        // Apply selection to current tab's selected item\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (tabNav && tabNav.selectedIndex !== -1 && tabNav.items[tabNav.selectedIndex]) {\n            tabNav.items[tabNav.selectedIndex].classList.add('keyboard-selected');\n        }\n    }\n\n    /**\n     * Show card details for specified tab and index\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     */\n    showCardDetails(tabName, index) {\n        // Dispatch event for other modules to handle\n        document.dispatchEvent(new CustomEvent('showCardDetails', {\n            detail: {\n                tabName: tabName,\n                index: index\n            }\n        }));\n    }\n\n    /**\n     * Select a specific card\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     * @param {string} type - Item type\n     * @param {*} data - Item data\n     */\n    selectCard(tabName, index, type, data) {\n        // Clear previous selection\n        this.clearCardSelection();\n\n        // Update selection state\n        this.selectedCard = {\n            tab: tabName,\n            index: index,\n            type: type,\n            data: data\n        };\n\n        this.updateCardSelectionUI();\n\n        console.log('Card selected:', this.selectedCard);\n    }\n\n    /**\n     * Clear card selection\n     */\n    clearCardSelection() {\n        // Clear visual selection from all tabs\n        document.querySelectorAll('.event-item.selected, .file-item.selected').forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Reset selection state\n        this.selectedCard = {\n            tab: null,\n            index: null,\n            type: null,\n            data: null\n        };\n    }\n\n    /**\n     * Update card selection UI\n     */\n    updateCardSelectionUI() {\n        if (!this.selectedCard.tab || this.selectedCard.index === null) return;\n\n        // Get the list container for the selected tab\n        let listContainer;\n        switch (this.selectedCard.tab) {\n            case 'events':\n                listContainer = document.getElementById('events-list');\n                break;\n            case 'agents':\n                listContainer = document.getElementById('agents-list');\n                break;\n            case 'tools':\n                listContainer = document.getElementById('tools-list');\n                break;\n            case 'files':\n                listContainer = document.getElementById('files-list');\n                break;\n        }\n\n        if (listContainer) {\n            const items = listContainer.querySelectorAll('.event-item, .file-item');\n            if (items[this.selectedCard.index]) {\n                items[this.selectedCard.index].classList.add('selected');\n            }\n        }\n    }\n\n    /**\n     * Get card type based on tab name\n     * @param {string} tabName - Tab name\n     * @returns {string} - Card type\n     */\n    getCardType(tabName) {\n        switch (tabName) {\n            case 'events': return 'event';\n            case 'agents': return 'agent';\n            case 'tools': return 'tool';\n            case 'files': return 'file';\n            default: return 'unknown';\n        }\n    }\n\n    /**\n     * Scroll current tab to bottom\n     */\n    scrollCurrentTabToBottom() {\n        const tabId = `${this.currentTab}-list`;\n        const element = document.getElementById(tabId);\n        if (element && this.autoScroll) {\n            element.scrollTop = element.scrollHeight;\n        }\n    }\n\n    /**\n     * Clear selection for cleanup\n     */\n    clearSelection() {\n        this.clearCardSelection();\n        this.clearUnifiedSelection();\n    }\n\n    /**\n     * Get current tab name\n     * @returns {string} - Current tab name\n     */\n    getCurrentTab() {\n        return this.currentTab;\n    }\n\n    /**\n     * Get selected card info\n     * @returns {Object} - Selected card state\n     */\n    getSelectedCard() {\n        return { ...this.selectedCard };\n    }\n\n    /**\n     * Get tab navigation state\n     * @returns {Object} - Tab navigation state\n     */\n    getTabNavigation() {\n        return { ...this.tabNavigation };\n    }\n\n    /**\n     * Set auto-scroll behavior\n     * @param {boolean} enabled - Whether to enable auto-scroll\n     */\n    setAutoScroll(enabled) {\n        this.autoScroll = enabled;\n    }\n\n    /**\n     * Get auto-scroll state\n     * @returns {boolean} - Auto-scroll enabled state\n     */\n    getAutoScroll() {\n        return this.autoScroll;\n    }\n}\n// ES6 Module export\nexport { UIStateManager };\nexport default UIStateManager;\n"],"names":["io","window","SocketClient","constructor","this","socket","port","connectionCallbacks","connect","disconnect","error","event","eventSchema","required","optional","isConnected","isConnecting","lastConnectTime","disconnectTime","events","sessions","Map","currentSessionId","eventQueue","maxQueueSize","retryAttempts","maxRetryAttempts","retryDelays","pendingEmissions","lastPingTime","lastPongTime","pingTimeout","healthCheckInterval","startStatusCheckFallback","startHealthMonitoring","url","connected","connecting","console","log","setTimeout","doConnect","notifyConnectionStatus","autoConnect","reconnection","reconnectionDelay","reconnectionDelayMax","reconnectionAttempts","timeout","forceNew","transports","pingInterval","setupSocketHandlers","on","previouslyConnected","Date","now","downtime","toFixed","flushEventQueue","forEach","callback","id","requestStatus","reason","disconnectInfo","timestamp","toISOString","wasConnected","uptimeSeconds","lastPing","lastPong","includes","scheduleReconnect","errorMsg","message","description","addEvent","type","data","uri","retry_attempt","validatedEvent","validateEventSchema","warn","transformedEvent","transformEvent","emit","client_time","subtype","Array","isArray","length","count","total_available","notifyEventUpdate","updateSessions","current_session","emitWithRetry","options","maxRetries","onSuccess","onFailure","emissionId","Math","random","attemptEmission","attemptNum","delete","delay","set","scheduledTime","queueEvent","removed","shift","push","item","index","requestHistory","params","limit","event_types","eventData","notify","session_id","sessionId","has","startTime","lastActivity","eventCount","working_directory","git_branch","session","get","possiblePaths","cwd","working_dir","workingDirectory","instance_info","path","trim","sessionsData","clearEvents","clear","refreshHistory","getEventsBySession","filter","onConnection","eventType","onEventUpdate","off","status","updateConnectionStatusDOM","document","dispatchEvent","CustomEvent","detail","statusElement","getElementById","innerHTML","className","getConnectionState","socketId","validated","source","value","eventName","toLowerCase","replace","startsWith","substring","mainType","subtypeParts","split","join","originalEventName","protectedFields","Object","keys","key","JSON","parse","stringify","hook_event_name","tool_name","has_tool_parameters","tool_parameters","has_data","k","file_path","notebook_path","full_parameters","getState","setInterval","timeSinceLastPing","stopHealthMonitoring","clearInterval","checkAndUpdateStatus","readyState","addEventListener","actualStatus","actualType","currentText","textContent","currentClass","expectedClass","destroy","getConnectionMetrics","uptime","queuedEvents","size","SocketManager","socketClient","Set","eventUpdateCallbacks","setupSocketEventHandlers","updateInitialConnectionStatus","e","handleConnectionStatusChange","updateConnectionStatus","setupGitBranchListener","success","footerBranch","branch","style","display","querySelector","statusIndicator","getSocketClient","getSocket","onConnectionStatusChange","add","offConnectionStatusChange","offEventUpdate","toggleConnectionControls","controlsRow","toggleBtn","classList","contains","remove","setupConnectionControls","connectBtn","disconnectBtn","connectionToggleBtn","initializeFromURL","portInput","connectPort","location","protocol","UIStateManager","currentTab","autoScroll","selectedCard","tab","tabNavigation","selectedIndex","items","agents","tools","files","setupEventHandlers","setupTabNavigation","setupUnifiedKeyboardNavigation","querySelectorAll","button","tabName","getTabNameFromButton","switchTab","activeElement","tagName","preventDefault","handleUnifiedArrowNavigation","handleUnifiedEnterKey","clearUnifiedSelection","text","previousTab","btn","content","activeTab","newTab","scrollCurrentTabToBottom","direction","tabNav","newIndex","selectCardByIndex","selectedElement","onclick","clearCardSelection","updateTabNavigationItems","containerSelector","from","updateUnifiedSelectionUI","selectCard","getCardType","showCardDetails","el","updateCardSelectionUI","listContainer","tabId","element","scrollTop","scrollHeight","clearSelection","getCurrentTab","getSelectedCard","getTabNavigation","setAutoScroll","enabled","getAutoScroll"],"mappings":"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"}