{"version":3,"file":"socket-client.js","sources":["../js/socket-client.js","../js/components/socket-manager.js","../js/components/ui-state-manager.js"],"sourcesContent":["/**\n * Socket.IO Client for Claude MPM Dashboard\n * Handles WebSocket connections and event processing\n */\n\n// Access the global io from window object in ES6 module context\nconst io = window.io;\n\nclass SocketClient {\n    constructor() {\n        this.socket = null;\n        this.port = null; // Store the current port\n        this.connectionCallbacks = {\n            connect: [],\n            disconnect: [],\n            error: [],\n            event: []\n        };\n\n        // Connection state\n        this.isConnected = false;\n        this.isConnecting = false;\n\n        // Event processing\n        this.events = [];\n        this.sessions = new Map();\n        this.currentSessionId = null;\n\n        // Start periodic status check as fallback mechanism\n        this.startStatusCheckFallback();\n    }\n\n    /**\n     * Connect to Socket.IO server\n     * @param {string} port - Port number to connect to\n     */\n    connect(port = '8765') {\n        // Store the port for later use\n        this.port = port;\n        const url = `http://localhost:${port}`;\n\n        // Prevent multiple simultaneous connections\n        if (this.socket && (this.socket.connected || this.socket.connecting)) {\n            console.log('Already connected or connecting, disconnecting first...');\n            this.socket.disconnect();\n            // Wait a moment for cleanup\n            setTimeout(() => this.doConnect(url), 100);\n            return;\n        }\n\n        this.doConnect(url);\n    }\n\n    /**\n     * Perform the actual connection\n     * @param {string} url - Socket.IO server URL\n     */\n    doConnect(url) {\n        console.log(`Connecting to Socket.IO server at ${url}`);\n        \n        // Check if io is available\n        if (typeof io === 'undefined') {\n            console.error('Socket.IO library not loaded! Make sure socket.io.min.js is loaded before this script.');\n            this.notifyConnectionStatus('Socket.IO library not loaded', 'error');\n            return;\n        }\n        \n        this.isConnecting = true;\n        this.notifyConnectionStatus('Connecting...', 'connecting');\n\n        this.socket = io(url, {\n            autoConnect: true,\n            reconnection: true,\n            reconnectionDelay: 1000,\n            reconnectionDelayMax: 10000,\n            maxReconnectionAttempts: 10,\n            timeout: 10000,\n            forceNew: true,\n            transports: ['websocket', 'polling']\n        });\n\n        this.setupSocketHandlers();\n    }\n\n    /**\n     * Setup Socket.IO event handlers\n     */\n    setupSocketHandlers() {\n        this.socket.on('connect', () => {\n            console.log('Connected to Socket.IO server');\n            this.isConnected = true;\n            this.isConnecting = false;\n            this.notifyConnectionStatus('Connected', 'connected');\n\n            // Emit connect callback\n            this.connectionCallbacks.connect.forEach(callback =>\n                callback(this.socket.id)\n            );\n\n            this.requestStatus();\n            // History is now automatically sent by server on connection\n            // No need to explicitly request it\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            console.log('Disconnected from server:', reason);\n            this.isConnected = false;\n            this.isConnecting = false;\n            this.notifyConnectionStatus(`Disconnected: ${reason}`, 'disconnected');\n\n            // Emit disconnect callback\n            this.connectionCallbacks.disconnect.forEach(callback =>\n                callback(reason)\n            );\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.isConnecting = false;\n            const errorMsg = error.message || error.description || 'Unknown error';\n            this.notifyConnectionStatus(`Connection Error: ${errorMsg}`, 'disconnected');\n\n            // Add error event\n            this.addEvent({\n                type: 'connection.error',\n                timestamp: new Date().toISOString(),\n                data: { error: errorMsg, url: this.socket.io.uri }\n            });\n\n            // Emit error callback\n            this.connectionCallbacks.error.forEach(callback =>\n                callback(errorMsg)\n            );\n        });\n\n        // Primary event handler - this is what the server actually emits\n        this.socket.on('claude_event', (data) => {\n            // console.log('Received claude_event:', data);\n\n            // Transform event to match expected format\n            const transformedEvent = this.transformEvent(data);\n            // console.log('Transformed event:', transformedEvent);\n            this.addEvent(transformedEvent);\n        });\n\n        // Session and event handlers (legacy/fallback)\n        this.socket.on('session.started', (data) => {\n            this.addEvent({ type: 'session', subtype: 'started', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('session.ended', (data) => {\n            this.addEvent({ type: 'session', subtype: 'ended', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.request', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'request', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.response', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'response', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.loaded', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'loaded', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.executed', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'executed', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.pre', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'pre', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.post', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'post', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('todo.updated', (data) => {\n            this.addEvent({ type: 'todo', subtype: 'updated', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('memory.operation', (data) => {\n            this.addEvent({ type: 'memory', subtype: 'operation', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('log.entry', (data) => {\n            this.addEvent({ type: 'log', subtype: 'entry', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('history', (data) => {\n            console.log('Received event history:', data);\n            if (data && Array.isArray(data.events)) {\n                console.log(`Processing ${data.events.length} historical events (${data.count} sent, ${data.total_available} total available)`);\n                // Add events in the order received (should already be chronological - oldest first)\n                // Transform each historical event to match expected format\n                data.events.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n                console.log(`Event history loaded: ${data.events.length} events added to dashboard`);\n            } else if (Array.isArray(data)) {\n                // Handle legacy format for backward compatibility\n                console.log('Received legacy event history format:', data.length, 'events');\n                data.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n            }\n        });\n\n        this.socket.on('system.status', (data) => {\n            console.log('Received system status:', data);\n            if (data.sessions) {\n                this.updateSessions(data.sessions);\n            }\n            if (data.current_session) {\n                this.currentSessionId = data.current_session;\n            }\n        });\n    }\n\n    /**\n     * Disconnect from Socket.IO server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.port = null; // Clear the stored port\n        this.isConnected = false;\n        this.isConnecting = false;\n    }\n\n    /**\n     * Request server status\n     */\n    requestStatus() {\n        if (this.socket && this.socket.connected) {\n            console.log('Requesting server status...');\n            this.socket.emit('request.status');\n        }\n    }\n\n    /**\n     * Request event history from server\n     * @param {Object} options - History request options\n     * @param {number} options.limit - Maximum number of events to retrieve (default: 50)\n     * @param {Array<string>} options.event_types - Optional filter by event types\n     */\n    requestHistory(options = {}) {\n        if (this.socket && this.socket.connected) {\n            const params = {\n                limit: options.limit || 50,\n                event_types: options.event_types || []\n            };\n            console.log('Requesting event history...', params);\n            this.socket.emit('get_history', params);\n        } else {\n            console.warn('Cannot request history: not connected to server');\n        }\n    }\n\n    /**\n     * Add event to local storage and notify listeners\n     * @param {Object} eventData - Event data\n     * @param {boolean} notify - Whether to notify listeners (default: true)\n     */\n    addEvent(eventData, notify = true) {\n        // Ensure event has required fields\n        if (!eventData.timestamp) {\n            eventData.timestamp = new Date().toISOString();\n        }\n        if (!eventData.id) {\n            eventData.id = Date.now() + Math.random();\n        }\n\n        this.events.push(eventData);\n\n        // Update session tracking\n        if (eventData.data && eventData.data.session_id) {\n            const sessionId = eventData.data.session_id;\n            if (!this.sessions.has(sessionId)) {\n                this.sessions.set(sessionId, {\n                    id: sessionId,\n                    startTime: eventData.timestamp,\n                    lastActivity: eventData.timestamp,\n                    eventCount: 0\n                });\n            }\n            const session = this.sessions.get(sessionId);\n            session.lastActivity = eventData.timestamp;\n            session.eventCount++;\n        }\n\n        if (notify) {\n            this.notifyEventUpdate();\n        }\n    }\n\n    /**\n     * Update sessions from server data\n     * @param {Array} sessionsData - Sessions data from server\n     */\n    updateSessions(sessionsData) {\n        if (Array.isArray(sessionsData)) {\n            sessionsData.forEach(session => {\n                this.sessions.set(session.id, session);\n            });\n        }\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.events = [];\n        this.sessions.clear();\n        this.notifyEventUpdate();\n    }\n\n    /**\n     * Clear events and request fresh history from server\n     * @param {Object} options - History request options (same as requestHistory)\n     */\n    refreshHistory(options = {}) {\n        this.clearEvents();\n        this.requestHistory(options);\n    }\n\n    /**\n     * Get filtered events by session\n     * @param {string} sessionId - Session ID to filter by (null for all)\n     * @returns {Array} Filtered events\n     */\n    getEventsBySession(sessionId = null) {\n        if (!sessionId) {\n            return this.events;\n        }\n        return this.events.filter(event =>\n            event.data && event.data.session_id === sessionId\n        );\n    }\n\n    /**\n     * Register callback for connection events\n     * @param {string} eventType - Type of event (connect, disconnect, error)\n     * @param {Function} callback - Callback function\n     */\n    onConnection(eventType, callback) {\n        if (this.connectionCallbacks[eventType]) {\n            this.connectionCallbacks[eventType].push(callback);\n        }\n    }\n\n    /**\n     * Register callback for event updates\n     * @param {Function} callback - Callback function\n     */\n    onEventUpdate(callback) {\n        this.connectionCallbacks.event.push(callback);\n    }\n\n    /**\n     * Notify connection status change\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    notifyConnectionStatus(status, type) {\n        console.log(`SocketClient: Connection status changed to '${status}' (${type})`);\n\n        // Direct DOM update - immediate and reliable\n        this.updateConnectionStatusDOM(status, type);\n\n        // Also dispatch custom event for other modules\n        document.dispatchEvent(new CustomEvent('socketConnectionStatus', {\n            detail: { status, type }\n        }));\n    }\n\n    /**\n     * Directly update the connection status DOM element\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    updateConnectionStatusDOM(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Update the text content while preserving the indicator span\n            statusElement.innerHTML = `<span>●</span> ${status}`;\n\n            // Update the CSS class for styling\n            statusElement.className = `status-badge status-${type}`;\n\n            console.log(`SocketClient: Direct DOM update - status: '${status}' (${type})`);\n        } else {\n            console.warn('SocketClient: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Notify event update\n     */\n    notifyEventUpdate() {\n        this.connectionCallbacks.event.forEach(callback =>\n            callback(this.events, this.sessions)\n        );\n\n        // Also dispatch custom event\n        document.dispatchEvent(new CustomEvent('socketEventUpdate', {\n            detail: { events: this.events, sessions: this.sessions }\n        }));\n    }\n\n    /**\n     * Get connection state\n     * @returns {Object} Connection state\n     */\n    getConnectionState() {\n        return {\n            isConnected: this.isConnected,\n            isConnecting: this.isConnecting,\n            socketId: this.socket ? this.socket.id : null\n        };\n    }\n\n    /**\n     * Transform received event to match expected dashboard format\n     * @param {Object} eventData - Raw event data from server\n     * @returns {Object} Transformed event\n     */\n    transformEvent(eventData) {\n        // Handle multiple event structures:\n        // 1. Hook events: { type: 'hook.pre_tool', timestamp: '...', data: {...} }\n        // 2. Legacy events: { event: 'TestStart', timestamp: '...', ... }\n        // 3. Standard events: { type: 'session', subtype: 'started', ... }\n\n        if (!eventData) {\n            return eventData; // Return as-is if null/undefined\n        }\n\n        let transformedEvent = { ...eventData };\n\n        // Handle legacy format with 'event' field but no 'type'\n        if (!eventData.type && eventData.event) {\n            // Map common event names to proper type/subtype\n            const eventName = eventData.event;\n            \n            // Check for known event patterns\n            if (eventName === 'TestStart' || eventName === 'TestEnd') {\n                transformedEvent.type = 'test';\n                transformedEvent.subtype = eventName.toLowerCase().replace('test', '');\n            } else if (eventName === 'SubagentStart' || eventName === 'SubagentStop') {\n                transformedEvent.type = 'subagent';\n                transformedEvent.subtype = eventName.toLowerCase().replace('subagent', '');\n            } else if (eventName === 'ToolCall') {\n                transformedEvent.type = 'tool';\n                transformedEvent.subtype = 'call';\n            } else if (eventName === 'UserPrompt') {\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = 'user_prompt';\n            } else {\n                // Generic fallback for unknown event names\n                transformedEvent.type = 'system';\n                transformedEvent.subtype = eventName.toLowerCase();\n            }\n            \n            // Remove the 'event' field to avoid confusion\n            delete transformedEvent.event;\n        }\n        // Handle standard format with 'type' field\n        else if (eventData.type) {\n            const type = eventData.type;\n            \n            // Transform 'hook.subtype' format to separate type and subtype\n            if (type.startsWith('hook.')) {\n                const subtype = type.substring(5); // Remove 'hook.' prefix\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = subtype;\n            }\n            // Transform other dotted types like 'session.started' -> type: 'session', subtype: 'started'\n            else if (type.includes('.')) {\n                const [mainType, ...subtypeParts] = type.split('.');\n                transformedEvent.type = mainType;\n                transformedEvent.subtype = subtypeParts.join('.');\n            }\n        }\n        // If no type and no event field, mark as unknown\n        else {\n            transformedEvent.type = 'unknown';\n            transformedEvent.subtype = '';\n        }\n\n        // Store original event name for display purposes (before any transformation)\n        if (!eventData.type && eventData.event) {\n            transformedEvent.originalEventName = eventData.event;\n        } else if (eventData.type) {\n            transformedEvent.originalEventName = eventData.type;\n        }\n\n        // Extract and flatten data fields to top level for dashboard compatibility\n        // The dashboard expects fields like tool_name, agent_type, etc. at the top level\n        if (eventData.data && typeof eventData.data === 'object') {\n            // Protected fields that should never be overwritten by data fields\n            const protectedFields = ['type', 'subtype', 'timestamp', 'id', 'event', 'event_type', 'originalEventName'];\n            \n            // Copy all data fields to the top level, except protected ones\n            Object.keys(eventData.data).forEach(key => {\n                // Only copy if not a protected field\n                if (!protectedFields.includes(key)) {\n                    transformedEvent[key] = eventData.data[key];\n                } else {\n                    // Log warning if data field would overwrite a protected field\n                    console.warn(`Protected field '${key}' in data object was not copied to top level to preserve event structure`);\n                }\n            });\n            \n            // Keep the original data object for backward compatibility\n            transformedEvent.data = eventData.data;\n        }\n\n        // Debug logging for tool events\n        if (transformedEvent.type === 'hook' && (transformedEvent.subtype === 'pre_tool' || transformedEvent.subtype === 'post_tool')) {\n            console.log('Transformed tool event:', {\n                type: transformedEvent.type,\n                subtype: transformedEvent.subtype,\n                tool_name: transformedEvent.tool_name,\n                has_data: !!transformedEvent.data,\n                keys: Object.keys(transformedEvent).filter(k => k !== 'data')\n            });\n        }\n\n        return transformedEvent;\n    }\n\n    /**\n     * Get current events and sessions\n     * @returns {Object} Current state\n     */\n    getState() {\n        return {\n            events: this.events,\n            sessions: this.sessions,\n            currentSessionId: this.currentSessionId\n        };\n    }\n\n    /**\n     * Start periodic status check as fallback mechanism\n     * This ensures the UI stays in sync with actual socket state\n     */\n    startStatusCheckFallback() {\n        // Check status every 2 seconds\n        setInterval(() => {\n            this.checkAndUpdateStatus();\n        }, 2000);\n\n        // Initial check after DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => {\n                setTimeout(() => this.checkAndUpdateStatus(), 100);\n            });\n        } else {\n            setTimeout(() => this.checkAndUpdateStatus(), 100);\n        }\n    }\n\n    /**\n     * Check actual socket state and update UI if necessary\n     */\n    checkAndUpdateStatus() {\n        let actualStatus = 'Disconnected';\n        let actualType = 'disconnected';\n\n        if (this.socket) {\n            if (this.socket.connected) {\n                actualStatus = 'Connected';\n                actualType = 'connected';\n                this.isConnected = true;\n                this.isConnecting = false;\n            } else if (this.socket.connecting || this.isConnecting) {\n                actualStatus = 'Connecting...';\n                actualType = 'connecting';\n                this.isConnected = false;\n            } else {\n                actualStatus = 'Disconnected';\n                actualType = 'disconnected';\n                this.isConnected = false;\n                this.isConnecting = false;\n            }\n        }\n\n        // Check if UI needs updating\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            const currentText = statusElement.textContent.replace('●', '').trim();\n            const currentClass = statusElement.className;\n            const expectedClass = `status-badge status-${actualType}`;\n\n            // Update if status text or class doesn't match\n            if (currentText !== actualStatus || currentClass !== expectedClass) {\n                console.log(`SocketClient: Fallback update - was '${currentText}' (${currentClass}), now '${actualStatus}' (${expectedClass})`);\n                this.updateConnectionStatusDOM(actualStatus, actualType);\n            }\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketClient };\nexport default SocketClient;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.SocketClient = SocketClient;\n","/**\n * Socket Manager Module\n *\n * Handles all socket connection management, event dispatching, and connection state.\n * Provides a centralized interface for socket operations across the dashboard.\n *\n * WHY: Extracted from main dashboard to centralize socket connection logic and\n * provide better separation of concerns. This allows for easier testing and\n * maintenance of connection handling code.\n *\n * DESIGN DECISION: Acts as a wrapper around SocketClient to provide dashboard-specific\n * connection management while maintaining the existing SocketClient interface.\n * Uses event dispatching to notify other modules of connection state changes.\n */\n\n// Import SocketClient (assuming it will be converted to ES6 modules too)\nimport { SocketClient } from '../socket-client.js';\nclass SocketManager {\n    constructor() {\n        this.socketClient = null;\n        this.connectionCallbacks = new Set();\n        this.eventUpdateCallbacks = new Set();\n\n        // Initialize socket client\n        this.socketClient = new SocketClient();\n\n        // Make socketClient globally available (for backward compatibility)\n        window.socketClient = this.socketClient;\n\n        this.setupSocketEventHandlers();\n\n        // Force initial status update after a short delay to ensure DOM is ready\n        setTimeout(() => {\n            this.updateInitialConnectionStatus();\n        }, 100);\n\n        console.log('Socket manager initialized');\n    }\n\n    /**\n     * Set up socket event handlers for connection status and events\n     */\n    setupSocketEventHandlers() {\n        // Listen for connection status changes\n        document.addEventListener('socketConnectionStatus', (e) => {\n            console.log(`SocketManager: Processing connection status update: ${e.detail.status} (${e.detail.type})`);\n            this.handleConnectionStatusChange(e.detail.status, e.detail.type);\n\n            // Notify all registered callbacks\n            this.connectionCallbacks.forEach(callback => {\n                try {\n                    callback(e.detail.status, e.detail.type);\n                } catch (error) {\n                    console.error('Error in connection callback:', error);\n                }\n            });\n        });\n\n        // Set up event update handling\n        if (this.socketClient) {\n            this.socketClient.onEventUpdate((events) => {\n                // Notify all registered callbacks\n                this.eventUpdateCallbacks.forEach(callback => {\n                    try {\n                        callback(events);\n                    } catch (error) {\n                        console.error('Error in event update callback:', error);\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Handle connection status changes\n     * @param {string} status - Connection status text\n     * @param {string} type - Connection type ('connected', 'disconnected', etc.)\n     */\n    handleConnectionStatusChange(status, type) {\n        this.updateConnectionStatus(status, type);\n\n        // Set up git branch listener when connected\n        if (type === 'connected' && this.socketClient && this.socketClient.socket) {\n            this.setupGitBranchListener();\n        }\n    }\n\n    /**\n     * Update initial connection status on dashboard load\n     */\n    updateInitialConnectionStatus() {\n        console.log('SocketManager: Updating initial connection status');\n\n        // Force status check on socket client (uses fallback mechanism)\n        if (this.socketClient && typeof this.socketClient.checkAndUpdateStatus === 'function') {\n            console.log('SocketManager: Using socket client checkAndUpdateStatus method');\n            this.socketClient.checkAndUpdateStatus();\n        } else if (this.socketClient && this.socketClient.socket) {\n            console.log('SocketManager: Checking socket state directly', {\n                connected: this.socketClient.socket.connected,\n                connecting: this.socketClient.socket.connecting,\n                isConnecting: this.socketClient.isConnecting,\n                isConnected: this.socketClient.isConnected\n            });\n\n            if (this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket is already connected, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            } else if (this.socketClient.isConnecting || this.socketClient.socket.connecting) {\n                console.log('SocketManager: Socket is connecting, updating status');\n                this.updateConnectionStatus('Connecting...', 'connecting');\n            } else {\n                console.log('SocketManager: Socket is disconnected, updating status');\n                this.updateConnectionStatus('Disconnected', 'disconnected');\n            }\n        } else {\n            console.log('SocketManager: No socket client or socket found, setting disconnected status');\n            this.updateConnectionStatus('Disconnected', 'disconnected');\n        }\n\n        // Additional fallback - check again after a longer delay in case connection is still establishing\n        setTimeout(() => {\n            console.log('SocketManager: Secondary status check after 1 second');\n            if (this.socketClient && this.socketClient.socket && this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket connected in secondary check, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            }\n        }, 1000);\n    }\n\n    /**\n     * Set up git branch response listener for connected socket\n     */\n    setupGitBranchListener() {\n        // Remove any existing listener first\n        this.socketClient.socket.off('git_branch_response');\n\n        // Add the listener\n        this.socketClient.socket.on('git_branch_response', (data) => {\n            if (data.success) {\n                const footerBranch = document.getElementById('footer-git-branch');\n                if (footerBranch) {\n                    footerBranch.textContent = data.branch || 'unknown';\n                }\n                if (footerBranch) {\n                    footerBranch.style.display = 'inline';\n                }\n            } else {\n                console.error('Git branch request failed:', data.error);\n            }\n        });\n    }\n\n    /**\n     * Update connection status display\n     * @param {string} status - Status text to display\n     * @param {string} type - Status type for styling\n     */\n    updateConnectionStatus(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Check if there's a span indicator first\n            const indicator = statusElement.querySelector('span');\n            if (indicator) {\n                // If there's a span, update the text content after the span\n                const statusIndicator = type === 'connected' ? '●' : '●';\n                statusElement.innerHTML = `<span>${statusIndicator}</span> ${status}`;\n            } else {\n                // If no span, just update text content\n                statusElement.textContent = status;\n            }\n\n            statusElement.className = `status-badge status-${type}`;\n            console.log(`SocketManager: UI updated - status: '${status}' (${type})`);\n        } else {\n            console.error('SocketManager: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Connect to socket server\n     * @param {number} port - Port number to connect to\n     */\n    connect(port) {\n        if (this.socketClient) {\n            this.socketClient.connect(port);\n        }\n    }\n\n    /**\n     * Disconnect from socket server\n     */\n    disconnect() {\n        if (this.socketClient) {\n            this.socketClient.disconnect();\n        }\n    }\n\n    /**\n     * Check if socket is connected\n     * @returns {boolean} - True if connected\n     */\n    isConnected() {\n        return this.socketClient && this.socketClient.isConnected;\n    }\n\n    /**\n     * Check if socket is connecting\n     * @returns {boolean} - True if connecting\n     */\n    isConnecting() {\n        return this.socketClient && this.socketClient.isConnecting;\n    }\n\n    /**\n     * Get the underlying socket client\n     * @returns {SocketClient} - The socket client instance\n     */\n    getSocketClient() {\n        return this.socketClient;\n    }\n\n    /**\n     * Get the raw socket connection\n     * @returns {Socket|null} - The raw socket or null\n     */\n    getSocket() {\n        return this.socketClient ? this.socketClient.socket : null;\n    }\n\n    /**\n     * Register a callback for connection status changes\n     * @param {Function} callback - Callback function(status, type)\n     */\n    onConnectionStatusChange(callback) {\n        this.connectionCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister a connection status callback\n     * @param {Function} callback - Callback to remove\n     */\n    offConnectionStatusChange(callback) {\n        this.connectionCallbacks.delete(callback);\n    }\n\n    /**\n     * Register a callback for event updates\n     * @param {Function} callback - Callback function(events)\n     */\n    onEventUpdate(callback) {\n        this.eventUpdateCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister an event update callback\n     * @param {Function} callback - Callback to remove\n     */\n    offEventUpdate(callback) {\n        this.eventUpdateCallbacks.delete(callback);\n    }\n\n    /**\n     * Toggle connection controls visibility\n     */\n    toggleConnectionControls() {\n        const controlsRow = document.getElementById('connection-controls-row');\n        const toggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (controlsRow && toggleBtn) {\n            const isVisible = controlsRow.classList.contains('show');\n\n            if (isVisible) {\n                controlsRow.classList.remove('show');\n                controlsRow.style.display = 'none';\n                toggleBtn.textContent = 'Connection Settings';\n            } else {\n                controlsRow.classList.add('show');\n                controlsRow.style.display = 'block';\n                toggleBtn.textContent = 'Hide Settings';\n            }\n        }\n    }\n\n    /**\n     * Setup connection control event handlers\n     * Called during dashboard initialization\n     */\n    setupConnectionControls() {\n        const connectBtn = document.getElementById('connect-btn');\n        const disconnectBtn = document.getElementById('disconnect-btn');\n        const connectionToggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (connectBtn) {\n            connectBtn.addEventListener('click', () => {\n                const port = document.getElementById('port-input').value || 8765;\n                this.connect(port);\n            });\n        }\n\n        if (disconnectBtn) {\n            disconnectBtn.addEventListener('click', () => {\n                this.disconnect();\n            });\n        }\n\n        if (connectionToggleBtn) {\n            connectionToggleBtn.addEventListener('click', () => {\n                this.toggleConnectionControls();\n            });\n        }\n    }\n\n    /**\n     * Initialize connection from URL parameters\n     * @param {URLSearchParams} params - URL search parameters\n     */\n    initializeFromURL(params) {\n        const port = params.get('port');\n        const portInput = document.getElementById('port-input');\n\n        // Determine the port to use:\n        // 1. URL parameter 'port'\n        // 2. Current page port (if served via HTTP)\n        // 3. Default port value from input field\n        // 4. Fallback to 8765\n        let connectPort = port;\n        if (!connectPort && window.location.protocol === 'http:') {\n            connectPort = window.location.port || '8765';\n        }\n        if (!connectPort) {\n            connectPort = portInput?.value || '8765';\n        }\n\n        // Update the port input field with the determined port\n        if (portInput) {\n            portInput.value = connectPort;\n        }\n\n        // Auto-connect by default unless explicitly disabled\n        const shouldAutoConnect = params.get('connect') !== 'false';\n        if (shouldAutoConnect && !this.isConnected() && !this.isConnecting()) {\n            this.connect(connectPort);\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketManager };\nexport default SocketManager;\n","/**\n * UI State Manager Module\n *\n * Manages UI state including tab switching, card selection, keyboard navigation,\n * and visual feedback across the dashboard interface.\n *\n * WHY: Extracted from main dashboard to centralize UI state management and\n * provide better separation between business logic and UI state. This makes\n * the UI behavior more predictable and easier to test.\n *\n * DESIGN DECISION: Maintains centralized state for current tab, selected cards,\n * and navigation context while providing a clean API for other modules to\n * interact with UI state changes.\n */\nclass UIStateManager {\n    constructor() {\n        // Current active tab\n        this.currentTab = 'events';\n\n        // Auto-scroll behavior\n        this.autoScroll = true;\n\n        // Selection state - tracks the currently selected card across all tabs\n        this.selectedCard = {\n            tab: null,        // which tab the selection is in\n            index: null,      // index of selected item in that tab\n            type: null,       // 'event', 'agent', 'tool', 'file'\n            data: null        // the actual data object\n        };\n\n        // Navigation state for each tab\n        this.tabNavigation = {\n            events: { selectedIndex: -1, items: [] },\n            agents: { selectedIndex: -1, items: [] },\n            tools: { selectedIndex: -1, items: [] },\n            files: { selectedIndex: -1, items: [] }\n        };\n\n        this.setupEventHandlers();\n        console.log('UI state manager initialized');\n    }\n\n    /**\n     * Set up event handlers for UI interactions\n     */\n    setupEventHandlers() {\n        this.setupTabNavigation();\n        this.setupUnifiedKeyboardNavigation();\n    }\n\n    /**\n     * Set up tab navigation event listeners\n     */\n    setupTabNavigation() {\n        // Tab buttons\n        document.querySelectorAll('.tab-button').forEach(button => {\n            button.addEventListener('click', () => {\n                const tabName = this.getTabNameFromButton(button);\n                this.switchTab(tabName);\n            });\n        });\n    }\n\n    /**\n     * Set up unified keyboard navigation across all tabs\n     */\n    setupUnifiedKeyboardNavigation() {\n        document.addEventListener('keydown', (e) => {\n            // Only handle if not in an input field\n            if (document.activeElement &&\n                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {\n                return;\n            }\n\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.handleUnifiedArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                this.handleUnifiedEnterKey();\n            } else if (e.key === 'Escape') {\n                this.clearUnifiedSelection();\n            }\n        });\n    }\n\n    /**\n     * Get tab name from button element\n     * @param {HTMLElement} button - Tab button element\n     * @returns {string} - Tab name\n     */\n    getTabNameFromButton(button) {\n        const text = button.textContent.toLowerCase();\n        if (text.includes('events')) return 'events';\n        if (text.includes('agents')) return 'agents';\n        if (text.includes('tools')) return 'tools';\n        if (text.includes('files')) return 'files';\n        return 'events';\n    }\n\n    /**\n     * Switch to specified tab\n     * @param {string} tabName - Name of tab to switch to\n     */\n    switchTab(tabName) {\n        console.log(`[DEBUG] switchTab called with tabName: ${tabName}`);\n        const previousTab = this.currentTab;\n        this.currentTab = tabName;\n\n        // Update tab button active states\n        document.querySelectorAll('.tab-button').forEach(btn => {\n            btn.classList.remove('active');\n            if (this.getTabNameFromButton(btn) === tabName) {\n                btn.classList.add('active');\n            }\n        });\n\n        // Show/hide tab content using CSS classes\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n\n        const activeTab = document.getElementById(`${tabName}-tab`);\n        if (activeTab) {\n            activeTab.classList.add('active');\n        }\n\n        // Clear previous selections when switching tabs\n        this.clearUnifiedSelection();\n\n        // Trigger tab change event for other modules\n        document.dispatchEvent(new CustomEvent('tabChanged', {\n            detail: {\n                newTab: tabName,\n                previousTab: previousTab\n            }\n        }));\n\n        // Auto-scroll to bottom after a brief delay to ensure content is rendered\n        setTimeout(() => {\n            if (this.autoScroll) {\n                this.scrollCurrentTabToBottom();\n            }\n        }, 100);\n    }\n\n    /**\n     * Handle unified arrow navigation across tabs\n     * @param {number} direction - Navigation direction (1 for down, -1 for up)\n     */\n    handleUnifiedArrowNavigation(direction) {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let newIndex = tabNav.selectedIndex + direction;\n\n        // Handle bounds\n        if (tabNav.items.length === 0) return;\n\n        if (newIndex < 0) {\n            newIndex = tabNav.items.length - 1;\n        } else if (newIndex >= tabNav.items.length) {\n            newIndex = 0;\n        }\n\n        this.selectCardByIndex(this.currentTab, newIndex);\n    }\n\n    /**\n     * Handle unified Enter key across all tabs\n     */\n    handleUnifiedEnterKey() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav || tabNav.selectedIndex === -1) return;\n\n        const selectedElement = tabNav.items[tabNav.selectedIndex];\n        if (selectedElement && selectedElement.onclick) {\n            selectedElement.onclick();\n        }\n    }\n\n    /**\n     * Clear all unified selection states\n     */\n    clearUnifiedSelection() {\n        // Clear all tab navigation states\n        Object.keys(this.tabNavigation).forEach(tabName => {\n            this.tabNavigation[tabName].selectedIndex = -1;\n        });\n\n        // Clear card selection\n        this.clearCardSelection();\n    }\n\n    /**\n     * Update tab navigation items for current tab\n     * Should be called after tab content is rendered\n     */\n    updateTabNavigationItems() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let containerSelector;\n        switch (this.currentTab) {\n            case 'events':\n                containerSelector = '#events-list .event-item';\n                break;\n            case 'agents':\n                containerSelector = '#agents-list .event-item';\n                break;\n            case 'tools':\n                containerSelector = '#tools-list .event-item';\n                break;\n            case 'files':\n                containerSelector = '#files-list .event-item';\n                break;\n        }\n\n        if (containerSelector) {\n            tabNav.items = Array.from(document.querySelectorAll(containerSelector));\n        }\n    }\n\n    /**\n     * Select card by index for specified tab\n     * @param {string} tabName - Tab name\n     * @param {number} index - Index of item to select\n     */\n    selectCardByIndex(tabName, index) {\n        const tabNav = this.tabNavigation[tabName];\n        if (!tabNav || index < 0 || index >= tabNav.items.length) return;\n\n        // Update navigation state\n        tabNav.selectedIndex = index;\n\n        // Update visual selection\n        this.updateUnifiedSelectionUI();\n\n        // If this is a different tab selection, record the card selection\n        const selectedElement = tabNav.items[index];\n        if (selectedElement) {\n            // Extract data from the element to populate selectedCard\n            this.selectCard(tabName, index, this.getCardType(tabName), index);\n        }\n\n        // Show details for the selected item\n        this.showCardDetails(tabName, index);\n    }\n\n    /**\n     * Update visual selection UI for unified navigation\n     */\n    updateUnifiedSelectionUI() {\n        // Clear all existing selections\n        document.querySelectorAll('.event-item.keyboard-selected').forEach(el => {\n            el.classList.remove('keyboard-selected');\n        });\n\n        // Apply selection to current tab's selected item\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (tabNav && tabNav.selectedIndex !== -1 && tabNav.items[tabNav.selectedIndex]) {\n            tabNav.items[tabNav.selectedIndex].classList.add('keyboard-selected');\n        }\n    }\n\n    /**\n     * Show card details for specified tab and index\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     */\n    showCardDetails(tabName, index) {\n        // Dispatch event for other modules to handle\n        document.dispatchEvent(new CustomEvent('showCardDetails', {\n            detail: {\n                tabName: tabName,\n                index: index\n            }\n        }));\n    }\n\n    /**\n     * Select a specific card\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     * @param {string} type - Item type\n     * @param {*} data - Item data\n     */\n    selectCard(tabName, index, type, data) {\n        // Clear previous selection\n        this.clearCardSelection();\n\n        // Update selection state\n        this.selectedCard = {\n            tab: tabName,\n            index: index,\n            type: type,\n            data: data\n        };\n\n        this.updateCardSelectionUI();\n\n        console.log('Card selected:', this.selectedCard);\n    }\n\n    /**\n     * Clear card selection\n     */\n    clearCardSelection() {\n        // Clear visual selection from all tabs\n        document.querySelectorAll('.event-item.selected, .file-item.selected').forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Reset selection state\n        this.selectedCard = {\n            tab: null,\n            index: null,\n            type: null,\n            data: null\n        };\n    }\n\n    /**\n     * Update card selection UI\n     */\n    updateCardSelectionUI() {\n        if (!this.selectedCard.tab || this.selectedCard.index === null) return;\n\n        // Get the list container for the selected tab\n        let listContainer;\n        switch (this.selectedCard.tab) {\n            case 'events':\n                listContainer = document.getElementById('events-list');\n                break;\n            case 'agents':\n                listContainer = document.getElementById('agents-list');\n                break;\n            case 'tools':\n                listContainer = document.getElementById('tools-list');\n                break;\n            case 'files':\n                listContainer = document.getElementById('files-list');\n                break;\n        }\n\n        if (listContainer) {\n            const items = listContainer.querySelectorAll('.event-item, .file-item');\n            if (items[this.selectedCard.index]) {\n                items[this.selectedCard.index].classList.add('selected');\n            }\n        }\n    }\n\n    /**\n     * Get card type based on tab name\n     * @param {string} tabName - Tab name\n     * @returns {string} - Card type\n     */\n    getCardType(tabName) {\n        switch (tabName) {\n            case 'events': return 'event';\n            case 'agents': return 'agent';\n            case 'tools': return 'tool';\n            case 'files': return 'file';\n            default: return 'unknown';\n        }\n    }\n\n    /**\n     * Scroll current tab to bottom\n     */\n    scrollCurrentTabToBottom() {\n        const tabId = `${this.currentTab}-list`;\n        const element = document.getElementById(tabId);\n        if (element && this.autoScroll) {\n            element.scrollTop = element.scrollHeight;\n        }\n    }\n\n    /**\n     * Clear selection for cleanup\n     */\n    clearSelection() {\n        this.clearCardSelection();\n        this.clearUnifiedSelection();\n    }\n\n    /**\n     * Get current tab name\n     * @returns {string} - Current tab name\n     */\n    getCurrentTab() {\n        return this.currentTab;\n    }\n\n    /**\n     * Get selected card info\n     * @returns {Object} - Selected card state\n     */\n    getSelectedCard() {\n        return { ...this.selectedCard };\n    }\n\n    /**\n     * Get tab navigation state\n     * @returns {Object} - Tab navigation state\n     */\n    getTabNavigation() {\n        return { ...this.tabNavigation };\n    }\n\n    /**\n     * Set auto-scroll behavior\n     * @param {boolean} enabled - Whether to enable auto-scroll\n     */\n    setAutoScroll(enabled) {\n        this.autoScroll = enabled;\n    }\n\n    /**\n     * Get auto-scroll state\n     * @returns {boolean} - Auto-scroll enabled state\n     */\n    getAutoScroll() {\n        return this.autoScroll;\n    }\n}\n// ES6 Module export\nexport { UIStateManager };\nexport default UIStateManager;\n"],"names":["io","window","SocketClient","constructor","this","socket","port","connectionCallbacks","connect","disconnect","error","event","isConnected","isConnecting","events","sessions","Map","currentSessionId","startStatusCheckFallback","url","connected","connecting","console","log","setTimeout","doConnect","notifyConnectionStatus","autoConnect","reconnection","reconnectionDelay","reconnectionDelayMax","maxReconnectionAttempts","timeout","forceNew","transports","setupSocketHandlers","on","forEach","callback","id","requestStatus","reason","errorMsg","message","description","addEvent","type","timestamp","Date","toISOString","data","uri","transformedEvent","transformEvent","subtype","Array","isArray","length","count","total_available","notifyEventUpdate","updateSessions","current_session","emit","requestHistory","options","params","limit","event_types","warn","eventData","notify","now","Math","random","push","session_id","sessionId","has","set","startTime","lastActivity","eventCount","session","get","sessionsData","clearEvents","clear","refreshHistory","getEventsBySession","filter","onConnection","eventType","onEventUpdate","status","updateConnectionStatusDOM","document","dispatchEvent","CustomEvent","detail","statusElement","getElementById","innerHTML","className","getConnectionState","socketId","eventName","toLowerCase","replace","startsWith","substring","includes","mainType","subtypeParts","split","join","originalEventName","protectedFields","Object","keys","key","tool_name","has_data","k","getState","setInterval","checkAndUpdateStatus","readyState","addEventListener","actualStatus","actualType","currentText","textContent","trim","currentClass","expectedClass","SocketManager","socketClient","Set","eventUpdateCallbacks","setupSocketEventHandlers","updateInitialConnectionStatus","e","handleConnectionStatusChange","updateConnectionStatus","setupGitBranchListener","off","success","footerBranch","branch","style","display","querySelector","statusIndicator","getSocketClient","getSocket","onConnectionStatusChange","add","offConnectionStatusChange","delete","offEventUpdate","toggleConnectionControls","controlsRow","toggleBtn","classList","contains","remove","setupConnectionControls","connectBtn","disconnectBtn","connectionToggleBtn","value","initializeFromURL","portInput","connectPort","location","protocol","UIStateManager","currentTab","autoScroll","selectedCard","tab","index","tabNavigation","selectedIndex","items","agents","tools","files","setupEventHandlers","setupTabNavigation","setupUnifiedKeyboardNavigation","querySelectorAll","button","tabName","getTabNameFromButton","switchTab","activeElement","tagName","preventDefault","handleUnifiedArrowNavigation","handleUnifiedEnterKey","clearUnifiedSelection","text","previousTab","btn","content","activeTab","newTab","scrollCurrentTabToBottom","direction","tabNav","newIndex","selectCardByIndex","selectedElement","onclick","clearCardSelection","updateTabNavigationItems","containerSelector","from","updateUnifiedSelectionUI","selectCard","getCardType","showCardDetails","el","updateCardSelectionUI","listContainer","tabId","element","scrollTop","scrollHeight","clearSelection","getCurrentTab","getSelectedCard","getTabNavigation","setAutoScroll","enabled","getAutoScroll"],"mappings":"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"}