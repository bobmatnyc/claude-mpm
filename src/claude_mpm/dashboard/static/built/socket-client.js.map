{"version":3,"file":"socket-client.js","sources":["../js/socket-client.js","../js/components/socket-manager.js","../js/components/ui-state-manager.js"],"sourcesContent":["/**\n * Socket.IO Client for Claude MPM Dashboard\n * Handles WebSocket connections and event processing\n */\n\n// Access the global io from window object in ES6 module context\nconst io = window.io;\n\nclass SocketClient {\n    constructor() {\n        this.socket = null;\n        this.port = null; // Store the current port\n        this.connectionCallbacks = {\n            connect: [],\n            disconnect: [],\n            error: [],\n            event: []\n        };\n\n        // Connection state\n        this.isConnected = false;\n        this.isConnecting = false;\n        this.lastConnectTime = null;\n        this.disconnectTime = null;\n\n        // Event processing\n        this.events = [];\n        this.sessions = new Map();\n        this.currentSessionId = null;\n\n        // Event queue for disconnection periods\n        this.eventQueue = [];\n        this.maxQueueSize = 100;\n        \n        // Retry configuration\n        this.retryAttempts = 0;\n        this.maxRetryAttempts = 3;\n        this.retryDelays = [1000, 2000, 4000]; // Exponential backoff\n        this.pendingEmissions = new Map(); // Track pending emissions for retry\n        \n        // Health monitoring\n        this.lastPingTime = null;\n        this.lastPongTime = null;\n        this.pingTimeout = 40000; // 40 seconds (server sends every 30s)\n        this.healthCheckInterval = null;\n        \n        // Start periodic status check as fallback mechanism\n        this.startStatusCheckFallback();\n        this.startHealthMonitoring();\n    }\n\n    /**\n     * Connect to Socket.IO server\n     * @param {string} port - Port number to connect to\n     */\n    connect(port = '8765') {\n        // Store the port for later use\n        this.port = port;\n        const url = `http://localhost:${port}`;\n\n        // Prevent multiple simultaneous connections\n        if (this.socket && (this.socket.connected || this.socket.connecting)) {\n            console.log('Already connected or connecting, disconnecting first...');\n            this.socket.disconnect();\n            // Wait a moment for cleanup\n            setTimeout(() => this.doConnect(url), 100);\n            return;\n        }\n\n        this.doConnect(url);\n    }\n\n    /**\n     * Perform the actual connection\n     * @param {string} url - Socket.IO server URL\n     */\n    doConnect(url) {\n        console.log(`Connecting to Socket.IO server at ${url}`);\n        \n        // Check if io is available\n        if (typeof io === 'undefined') {\n            console.error('Socket.IO library not loaded! Make sure socket.io.min.js is loaded before this script.');\n            this.notifyConnectionStatus('Socket.IO library not loaded', 'error');\n            return;\n        }\n        \n        this.isConnecting = true;\n        this.notifyConnectionStatus('Connecting...', 'connecting');\n\n        this.socket = io(url, {\n            autoConnect: true,\n            reconnection: true,\n            reconnectionDelay: 1000,\n            reconnectionDelayMax: 10000,\n            maxReconnectionAttempts: 10,\n            timeout: 10000,\n            forceNew: true,\n            transports: ['websocket', 'polling']\n        });\n\n        this.setupSocketHandlers();\n    }\n\n    /**\n     * Setup Socket.IO event handlers\n     */\n    setupSocketHandlers() {\n        this.socket.on('connect', () => {\n            console.log('Connected to Socket.IO server');\n            const previouslyConnected = this.isConnected;\n            this.isConnected = true;\n            this.isConnecting = false;\n            this.lastConnectTime = Date.now();\n            this.retryAttempts = 0; // Reset retry counter on successful connect\n            \n            // Calculate downtime if this is a reconnection\n            if (this.disconnectTime && previouslyConnected === false) {\n                const downtime = (Date.now() - this.disconnectTime) / 1000;\n                console.log(`Reconnected after ${downtime.toFixed(1)}s downtime`);\n                \n                // Flush queued events after reconnection\n                this.flushEventQueue();\n            }\n            \n            this.notifyConnectionStatus('Connected', 'connected');\n\n            // Emit connect callback\n            this.connectionCallbacks.connect.forEach(callback =>\n                callback(this.socket.id)\n            );\n\n            this.requestStatus();\n            // History is now automatically sent by server on connection\n            // No need to explicitly request it\n        });\n\n        this.socket.on('disconnect', (reason) => {\n            console.log('Disconnected from server:', reason);\n            this.isConnected = false;\n            this.isConnecting = false;\n            this.disconnectTime = Date.now();\n            \n            // Calculate uptime\n            if (this.lastConnectTime) {\n                const uptime = (Date.now() - this.lastConnectTime) / 1000;\n                console.log(`Connection uptime was ${uptime.toFixed(1)}s`);\n            }\n            \n            this.notifyConnectionStatus(`Disconnected: ${reason}`, 'disconnected');\n\n            // Emit disconnect callback\n            this.connectionCallbacks.disconnect.forEach(callback =>\n                callback(reason)\n            );\n            \n            // Start auto-reconnect if it was an unexpected disconnect\n            if (reason === 'transport close' || reason === 'ping timeout') {\n                this.scheduleReconnect();\n            }\n        });\n\n        this.socket.on('connect_error', (error) => {\n            console.error('Connection error:', error);\n            this.isConnecting = false;\n            const errorMsg = error.message || error.description || 'Unknown error';\n            this.notifyConnectionStatus(`Connection Error: ${errorMsg}`, 'disconnected');\n\n            // Add error event\n            this.addEvent({\n                type: 'connection.error',\n                timestamp: new Date().toISOString(),\n                data: { \n                    error: errorMsg, \n                    url: this.socket.io.uri,\n                    retry_attempt: this.retryAttempts\n                }\n            });\n\n            // Emit error callback\n            this.connectionCallbacks.error.forEach(callback =>\n                callback(errorMsg)\n            );\n            \n            // Schedule reconnect with backoff\n            this.scheduleReconnect();\n        });\n\n        // Primary event handler - this is what the server actually emits\n        this.socket.on('claude_event', (data) => {\n            // console.log('Received claude_event:', data);\n\n            // Transform event to match expected format\n            const transformedEvent = this.transformEvent(data);\n            // console.log('Transformed event:', transformedEvent);\n            this.addEvent(transformedEvent);\n        });\n\n        // Add ping/pong handlers for health monitoring\n        this.socket.on('ping', (data) => {\n            // console.log('Received ping from server');\n            this.lastPingTime = Date.now();\n            \n            // Send pong response immediately\n            this.socket.emit('pong', { \n                timestamp: data.timestamp,\n                client_time: Date.now()\n            });\n        });\n        \n        // Session and event handlers (legacy/fallback)\n        this.socket.on('session.started', (data) => {\n            this.addEvent({ type: 'session', subtype: 'started', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('session.ended', (data) => {\n            this.addEvent({ type: 'session', subtype: 'ended', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.request', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'request', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('claude.response', (data) => {\n            this.addEvent({ type: 'claude', subtype: 'response', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.loaded', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'loaded', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('agent.executed', (data) => {\n            this.addEvent({ type: 'agent', subtype: 'executed', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.pre', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'pre', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('hook.post', (data) => {\n            this.addEvent({ type: 'hook', subtype: 'post', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('todo.updated', (data) => {\n            this.addEvent({ type: 'todo', subtype: 'updated', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('memory.operation', (data) => {\n            this.addEvent({ type: 'memory', subtype: 'operation', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('log.entry', (data) => {\n            this.addEvent({ type: 'log', subtype: 'entry', timestamp: new Date().toISOString(), data });\n        });\n\n        this.socket.on('history', (data) => {\n            console.log('Received event history:', data);\n            if (data && Array.isArray(data.events)) {\n                console.log(`Processing ${data.events.length} historical events (${data.count} sent, ${data.total_available} total available)`);\n                // Add events in the order received (should already be chronological - oldest first)\n                // Transform each historical event to match expected format\n                data.events.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n                console.log(`Event history loaded: ${data.events.length} events added to dashboard`);\n            } else if (Array.isArray(data)) {\n                // Handle legacy format for backward compatibility\n                console.log('Received legacy event history format:', data.length, 'events');\n                data.forEach(event => {\n                    const transformedEvent = this.transformEvent(event);\n                    this.addEvent(transformedEvent, false);\n                });\n                this.notifyEventUpdate();\n            }\n        });\n\n        this.socket.on('system.status', (data) => {\n            console.log('Received system status:', data);\n            if (data.sessions) {\n                this.updateSessions(data.sessions);\n            }\n            if (data.current_session) {\n                this.currentSessionId = data.current_session;\n            }\n        });\n    }\n\n    /**\n     * Disconnect from Socket.IO server\n     */\n    disconnect() {\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.port = null; // Clear the stored port\n        this.isConnected = false;\n        this.isConnecting = false;\n    }\n\n    /**\n     * Emit an event with retry support\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     * @param {Object} options - Options for retry behavior\n     */\n    emitWithRetry(event, data = null, options = {}) {\n        const { \n            maxRetries = 3,\n            retryDelays = [1000, 2000, 4000],\n            onSuccess = null,\n            onFailure = null\n        } = options;\n        \n        const emissionId = `${event}_${Date.now()}_${Math.random()}`;\n        \n        const attemptEmission = (attemptNum = 0) => {\n            if (!this.socket || !this.socket.connected) {\n                // Queue for later if disconnected\n                if (attemptNum === 0) {\n                    this.queueEvent(event, data);\n                    console.log(`Queued ${event} for later emission (disconnected)`);\n                    if (onFailure) onFailure('disconnected');\n                }\n                return;\n            }\n            \n            try {\n                // Attempt emission\n                this.socket.emit(event, data);\n                console.log(`Emitted ${event} successfully`);\n                \n                // Remove from pending\n                this.pendingEmissions.delete(emissionId);\n                \n                if (onSuccess) onSuccess();\n                \n            } catch (error) {\n                console.error(`Failed to emit ${event} (attempt ${attemptNum + 1}):`, error);\n                \n                if (attemptNum < maxRetries - 1) {\n                    const delay = retryDelays[attemptNum] || retryDelays[retryDelays.length - 1];\n                    console.log(`Retrying ${event} in ${delay}ms...`);\n                    \n                    // Store pending emission\n                    this.pendingEmissions.set(emissionId, {\n                        event,\n                        data,\n                        attemptNum: attemptNum + 1,\n                        scheduledTime: Date.now() + delay\n                    });\n                    \n                    setTimeout(() => attemptEmission(attemptNum + 1), delay);\n                } else {\n                    console.error(`Failed to emit ${event} after ${maxRetries} attempts`);\n                    this.pendingEmissions.delete(emissionId);\n                    if (onFailure) onFailure('max_retries_exceeded');\n                }\n            }\n        };\n        \n        attemptEmission();\n    }\n    \n    /**\n     * Queue an event for later emission\n     * @param {string} event - Event name\n     * @param {any} data - Event data\n     */\n    queueEvent(event, data) {\n        if (this.eventQueue.length >= this.maxQueueSize) {\n            // Remove oldest event if queue is full\n            const removed = this.eventQueue.shift();\n            console.warn(`Event queue full, dropped oldest event: ${removed.event}`);\n        }\n        \n        this.eventQueue.push({\n            event,\n            data,\n            timestamp: Date.now()\n        });\n    }\n    \n    /**\n     * Flush queued events after reconnection\n     */\n    flushEventQueue() {\n        if (this.eventQueue.length === 0) return;\n        \n        console.log(`Flushing ${this.eventQueue.length} queued events...`);\n        const events = [...this.eventQueue];\n        this.eventQueue = [];\n        \n        // Emit each queued event with a small delay between them\n        events.forEach((item, index) => {\n            setTimeout(() => {\n                if (this.socket && this.socket.connected) {\n                    this.socket.emit(item.event, item.data);\n                    console.log(`Flushed queued event: ${item.event}`);\n                }\n            }, index * 100); // 100ms between each event\n        });\n    }\n    \n    /**\n     * Schedule a reconnection attempt with exponential backoff\n     */\n    scheduleReconnect() {\n        if (this.retryAttempts >= this.maxRetryAttempts) {\n            console.log('Max reconnection attempts reached, stopping auto-reconnect');\n            this.notifyConnectionStatus('Reconnection failed', 'disconnected');\n            return;\n        }\n        \n        const delay = this.retryDelays[this.retryAttempts] || this.retryDelays[this.retryDelays.length - 1];\n        this.retryAttempts++;\n        \n        console.log(`Scheduling reconnect attempt ${this.retryAttempts}/${this.maxRetryAttempts} in ${delay}ms...`);\n        this.notifyConnectionStatus(`Reconnecting in ${delay/1000}s...`, 'connecting');\n        \n        setTimeout(() => {\n            if (!this.isConnected && this.port) {\n                console.log(`Attempting reconnection ${this.retryAttempts}/${this.maxRetryAttempts}...`);\n                this.connect(this.port);\n            }\n        }, delay);\n    }\n    \n    /**\n     * Request server status\n     */\n    requestStatus() {\n        if (this.socket && this.socket.connected) {\n            console.log('Requesting server status...');\n            this.emitWithRetry('request.status', null, {\n                maxRetries: 2,\n                retryDelays: [500, 1000]\n            });\n        }\n    }\n\n    /**\n     * Request event history from server\n     * @param {Object} options - History request options\n     * @param {number} options.limit - Maximum number of events to retrieve (default: 50)\n     * @param {Array<string>} options.event_types - Optional filter by event types\n     */\n    requestHistory(options = {}) {\n        if (this.socket && this.socket.connected) {\n            const params = {\n                limit: options.limit || 50,\n                event_types: options.event_types || []\n            };\n            console.log('Requesting event history...', params);\n            this.emitWithRetry('get_history', params, {\n                maxRetries: 3,\n                retryDelays: [1000, 2000, 3000],\n                onFailure: (reason) => {\n                    console.error(`Failed to request history: ${reason}`);\n                }\n            });\n        } else {\n            console.warn('Cannot request history: not connected to server');\n        }\n    }\n\n    /**\n     * Add event to local storage and notify listeners\n     * @param {Object} eventData - Event data\n     * @param {boolean} notify - Whether to notify listeners (default: true)\n     */\n    addEvent(eventData, notify = true) {\n        // Ensure event has required fields\n        if (!eventData.timestamp) {\n            eventData.timestamp = new Date().toISOString();\n        }\n        if (!eventData.id) {\n            eventData.id = Date.now() + Math.random();\n        }\n\n        this.events.push(eventData);\n\n        // Update session tracking\n        if (eventData.data && eventData.data.session_id) {\n            const sessionId = eventData.data.session_id;\n            if (!this.sessions.has(sessionId)) {\n                this.sessions.set(sessionId, {\n                    id: sessionId,\n                    startTime: eventData.timestamp,\n                    lastActivity: eventData.timestamp,\n                    eventCount: 0\n                });\n            }\n            const session = this.sessions.get(sessionId);\n            session.lastActivity = eventData.timestamp;\n            session.eventCount++;\n        }\n\n        if (notify) {\n            this.notifyEventUpdate();\n        }\n    }\n\n    /**\n     * Update sessions from server data\n     * @param {Array} sessionsData - Sessions data from server\n     */\n    updateSessions(sessionsData) {\n        if (Array.isArray(sessionsData)) {\n            sessionsData.forEach(session => {\n                this.sessions.set(session.id, session);\n            });\n        }\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.events = [];\n        this.sessions.clear();\n        this.notifyEventUpdate();\n    }\n\n    /**\n     * Clear events and request fresh history from server\n     * @param {Object} options - History request options (same as requestHistory)\n     */\n    refreshHistory(options = {}) {\n        this.clearEvents();\n        this.requestHistory(options);\n    }\n\n    /**\n     * Get filtered events by session\n     * @param {string} sessionId - Session ID to filter by (null for all)\n     * @returns {Array} Filtered events\n     */\n    getEventsBySession(sessionId = null) {\n        if (!sessionId) {\n            return this.events;\n        }\n        return this.events.filter(event =>\n            event.data && event.data.session_id === sessionId\n        );\n    }\n\n    /**\n     * Register callback for connection events\n     * @param {string} eventType - Type of event (connect, disconnect, error)\n     * @param {Function} callback - Callback function\n     */\n    onConnection(eventType, callback) {\n        if (this.connectionCallbacks[eventType]) {\n            this.connectionCallbacks[eventType].push(callback);\n        }\n    }\n\n    /**\n     * Register callback for event updates\n     * @param {Function} callback - Callback function\n     */\n    onEventUpdate(callback) {\n        this.connectionCallbacks.event.push(callback);\n    }\n\n    /**\n     * Notify connection status change\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    notifyConnectionStatus(status, type) {\n        console.log(`SocketClient: Connection status changed to '${status}' (${type})`);\n\n        // Direct DOM update - immediate and reliable\n        this.updateConnectionStatusDOM(status, type);\n\n        // Also dispatch custom event for other modules\n        document.dispatchEvent(new CustomEvent('socketConnectionStatus', {\n            detail: { status, type }\n        }));\n    }\n\n    /**\n     * Directly update the connection status DOM element\n     * @param {string} status - Status message\n     * @param {string} type - Status type (connected, disconnected, connecting)\n     */\n    updateConnectionStatusDOM(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Update the text content while preserving the indicator span\n            statusElement.innerHTML = `<span>●</span> ${status}`;\n\n            // Update the CSS class for styling\n            statusElement.className = `status-badge status-${type}`;\n\n            console.log(`SocketClient: Direct DOM update - status: '${status}' (${type})`);\n        } else {\n            console.warn('SocketClient: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Notify event update\n     */\n    notifyEventUpdate() {\n        this.connectionCallbacks.event.forEach(callback =>\n            callback(this.events, this.sessions)\n        );\n\n        // Also dispatch custom event\n        document.dispatchEvent(new CustomEvent('socketEventUpdate', {\n            detail: { events: this.events, sessions: this.sessions }\n        }));\n    }\n\n    /**\n     * Get connection state\n     * @returns {Object} Connection state\n     */\n    getConnectionState() {\n        return {\n            isConnected: this.isConnected,\n            isConnecting: this.isConnecting,\n            socketId: this.socket ? this.socket.id : null\n        };\n    }\n\n    /**\n     * Transform received event to match expected dashboard format\n     * @param {Object} eventData - Raw event data from server\n     * @returns {Object} Transformed event\n     */\n    transformEvent(eventData) {\n        // Handle multiple event structures:\n        // 1. Hook events: { type: 'hook.pre_tool', timestamp: '...', data: {...} }\n        // 2. Legacy events: { event: 'TestStart', timestamp: '...', ... }\n        // 3. Standard events: { type: 'session', subtype: 'started', ... }\n\n        if (!eventData) {\n            return eventData; // Return as-is if null/undefined\n        }\n\n        let transformedEvent = { ...eventData };\n\n        // Handle legacy format with 'event' field but no 'type'\n        if (!eventData.type && eventData.event) {\n            // Map common event names to proper type/subtype\n            const eventName = eventData.event;\n            \n            // Check for known event patterns\n            if (eventName === 'TestStart' || eventName === 'TestEnd') {\n                transformedEvent.type = 'test';\n                transformedEvent.subtype = eventName.toLowerCase().replace('test', '');\n            } else if (eventName === 'SubagentStart' || eventName === 'SubagentStop') {\n                transformedEvent.type = 'subagent';\n                transformedEvent.subtype = eventName.toLowerCase().replace('subagent', '');\n            } else if (eventName === 'ToolCall') {\n                transformedEvent.type = 'tool';\n                transformedEvent.subtype = 'call';\n            } else if (eventName === 'UserPrompt') {\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = 'user_prompt';\n            } else {\n                // Generic fallback for unknown event names\n                // Use 'unknown' for type and the actual eventName for subtype\n                transformedEvent.type = 'unknown';\n                transformedEvent.subtype = eventName.toLowerCase();\n                \n                // Prevent duplicate type/subtype values\n                if (transformedEvent.type === transformedEvent.subtype) {\n                    transformedEvent.subtype = 'event';\n                }\n            }\n            \n            // Remove the 'event' field to avoid confusion\n            delete transformedEvent.event;\n        }\n        // Handle standard format with 'type' field\n        else if (eventData.type) {\n            const type = eventData.type;\n            \n            // Transform 'hook.subtype' format to separate type and subtype\n            if (type.startsWith('hook.')) {\n                const subtype = type.substring(5); // Remove 'hook.' prefix\n                transformedEvent.type = 'hook';\n                transformedEvent.subtype = subtype;\n            }\n            // Transform other dotted types like 'session.started' -> type: 'session', subtype: 'started'\n            else if (type.includes('.')) {\n                const [mainType, ...subtypeParts] = type.split('.');\n                transformedEvent.type = mainType;\n                transformedEvent.subtype = subtypeParts.join('.');\n            }\n        }\n        // If no type and no event field, mark as unknown\n        else {\n            transformedEvent.type = 'unknown';\n            transformedEvent.subtype = '';\n        }\n\n        // Store original event name for display purposes (before any transformation)\n        if (!eventData.type && eventData.event) {\n            transformedEvent.originalEventName = eventData.event;\n        } else if (eventData.type) {\n            transformedEvent.originalEventName = eventData.type;\n        }\n\n        // Extract and flatten data fields to top level for dashboard compatibility\n        // The dashboard expects fields like tool_name, agent_type, etc. at the top level\n        if (eventData.data && typeof eventData.data === 'object') {\n            // Protected fields that should never be overwritten by data fields\n            const protectedFields = ['type', 'subtype', 'timestamp', 'id', 'event', 'event_type', 'originalEventName'];\n            \n            // Copy all data fields to the top level, except protected ones\n            Object.keys(eventData.data).forEach(key => {\n                // Only copy if not a protected field\n                if (!protectedFields.includes(key)) {\n                    transformedEvent[key] = eventData.data[key];\n                } else {\n                    // Log warning if data field would overwrite a protected field\n                    console.warn(`Protected field '${key}' in data object was not copied to top level to preserve event structure`);\n                }\n            });\n            \n            // Keep the original data object for backward compatibility\n            transformedEvent.data = eventData.data;\n        }\n\n        // Debug logging for tool events\n        if (transformedEvent.type === 'hook' && (transformedEvent.subtype === 'pre_tool' || transformedEvent.subtype === 'post_tool')) {\n            console.log('Transformed tool event:', {\n                type: transformedEvent.type,\n                subtype: transformedEvent.subtype,\n                tool_name: transformedEvent.tool_name,\n                has_data: !!transformedEvent.data,\n                keys: Object.keys(transformedEvent).filter(k => k !== 'data')\n            });\n        }\n\n        return transformedEvent;\n    }\n\n    /**\n     * Get current events and sessions\n     * @returns {Object} Current state\n     */\n    getState() {\n        return {\n            events: this.events,\n            sessions: this.sessions,\n            currentSessionId: this.currentSessionId\n        };\n    }\n\n    /**\n     * Start health monitoring\n     * Detects stale connections and triggers reconnection\n     */\n    startHealthMonitoring() {\n        this.healthCheckInterval = setInterval(() => {\n            if (this.isConnected && this.lastPingTime) {\n                const timeSinceLastPing = Date.now() - this.lastPingTime;\n                \n                if (timeSinceLastPing > this.pingTimeout) {\n                    console.warn(`No ping from server for ${timeSinceLastPing/1000}s, connection may be stale`);\n                    \n                    // Force reconnection\n                    if (this.socket) {\n                        console.log('Forcing reconnection due to stale connection...');\n                        this.socket.disconnect();\n                        setTimeout(() => {\n                            if (this.port) {\n                                this.connect(this.port);\n                            }\n                        }, 1000);\n                    }\n                }\n            }\n        }, 10000); // Check every 10 seconds\n    }\n    \n    /**\n     * Stop health monitoring\n     */\n    stopHealthMonitoring() {\n        if (this.healthCheckInterval) {\n            clearInterval(this.healthCheckInterval);\n            this.healthCheckInterval = null;\n        }\n    }\n    \n    /**\n     * Start periodic status check as fallback mechanism\n     * This ensures the UI stays in sync with actual socket state\n     */\n    startStatusCheckFallback() {\n        // Check status every 2 seconds\n        setInterval(() => {\n            this.checkAndUpdateStatus();\n        }, 2000);\n\n        // Initial check after DOM is ready\n        if (document.readyState === 'loading') {\n            document.addEventListener('DOMContentLoaded', () => {\n                setTimeout(() => this.checkAndUpdateStatus(), 100);\n            });\n        } else {\n            setTimeout(() => this.checkAndUpdateStatus(), 100);\n        }\n    }\n\n    /**\n     * Check actual socket state and update UI if necessary\n     */\n    checkAndUpdateStatus() {\n        let actualStatus = 'Disconnected';\n        let actualType = 'disconnected';\n\n        if (this.socket) {\n            if (this.socket.connected) {\n                actualStatus = 'Connected';\n                actualType = 'connected';\n                this.isConnected = true;\n                this.isConnecting = false;\n            } else if (this.socket.connecting || this.isConnecting) {\n                actualStatus = 'Connecting...';\n                actualType = 'connecting';\n                this.isConnected = false;\n            } else {\n                actualStatus = 'Disconnected';\n                actualType = 'disconnected';\n                this.isConnected = false;\n                this.isConnecting = false;\n            }\n        }\n\n        // Check if UI needs updating\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            const currentText = statusElement.textContent.replace('●', '').trim();\n            const currentClass = statusElement.className;\n            const expectedClass = `status-badge status-${actualType}`;\n\n            // Update if status text or class doesn't match\n            if (currentText !== actualStatus || currentClass !== expectedClass) {\n                console.log(`SocketClient: Fallback update - was '${currentText}' (${currentClass}), now '${actualStatus}' (${expectedClass})`);\n                this.updateConnectionStatusDOM(actualStatus, actualType);\n            }\n        }\n    }\n\n    /**\n     * Clean up resources\n     */\n    destroy() {\n        this.stopHealthMonitoring();\n        if (this.socket) {\n            this.socket.disconnect();\n            this.socket = null;\n        }\n        this.eventQueue = [];\n        this.pendingEmissions.clear();\n    }\n    \n    /**\n     * Get connection metrics\n     * @returns {Object} Connection metrics\n     */\n    getConnectionMetrics() {\n        return {\n            isConnected: this.isConnected,\n            uptime: this.lastConnectTime ? (Date.now() - this.lastConnectTime) / 1000 : 0,\n            lastPing: this.lastPingTime ? (Date.now() - this.lastPingTime) / 1000 : null,\n            queuedEvents: this.eventQueue.length,\n            pendingEmissions: this.pendingEmissions.size,\n            retryAttempts: this.retryAttempts\n        };\n    }\n}\n\n// ES6 Module export\nexport { SocketClient };\nexport default SocketClient;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.SocketClient = SocketClient;\n","/**\n * Socket Manager Module\n *\n * Handles all socket connection management, event dispatching, and connection state.\n * Provides a centralized interface for socket operations across the dashboard.\n *\n * WHY: Extracted from main dashboard to centralize socket connection logic and\n * provide better separation of concerns. This allows for easier testing and\n * maintenance of connection handling code.\n *\n * DESIGN DECISION: Acts as a wrapper around SocketClient to provide dashboard-specific\n * connection management while maintaining the existing SocketClient interface.\n * Uses event dispatching to notify other modules of connection state changes.\n */\n\n// Import SocketClient (assuming it will be converted to ES6 modules too)\nimport { SocketClient } from '../socket-client.js';\nclass SocketManager {\n    constructor() {\n        this.socketClient = null;\n        this.connectionCallbacks = new Set();\n        this.eventUpdateCallbacks = new Set();\n\n        // Initialize socket client\n        this.socketClient = new SocketClient();\n\n        // Make socketClient globally available (for backward compatibility)\n        window.socketClient = this.socketClient;\n\n        this.setupSocketEventHandlers();\n\n        // Force initial status update after a short delay to ensure DOM is ready\n        setTimeout(() => {\n            this.updateInitialConnectionStatus();\n        }, 100);\n\n        console.log('Socket manager initialized');\n    }\n\n    /**\n     * Set up socket event handlers for connection status and events\n     */\n    setupSocketEventHandlers() {\n        // Listen for connection status changes\n        document.addEventListener('socketConnectionStatus', (e) => {\n            console.log(`SocketManager: Processing connection status update: ${e.detail.status} (${e.detail.type})`);\n            this.handleConnectionStatusChange(e.detail.status, e.detail.type);\n\n            // Notify all registered callbacks\n            this.connectionCallbacks.forEach(callback => {\n                try {\n                    callback(e.detail.status, e.detail.type);\n                } catch (error) {\n                    console.error('Error in connection callback:', error);\n                }\n            });\n        });\n\n        // Set up event update handling\n        if (this.socketClient) {\n            this.socketClient.onEventUpdate((events) => {\n                // Notify all registered callbacks\n                this.eventUpdateCallbacks.forEach(callback => {\n                    try {\n                        callback(events);\n                    } catch (error) {\n                        console.error('Error in event update callback:', error);\n                    }\n                });\n            });\n        }\n    }\n\n    /**\n     * Handle connection status changes\n     * @param {string} status - Connection status text\n     * @param {string} type - Connection type ('connected', 'disconnected', etc.)\n     */\n    handleConnectionStatusChange(status, type) {\n        this.updateConnectionStatus(status, type);\n\n        // Set up git branch listener when connected\n        if (type === 'connected' && this.socketClient && this.socketClient.socket) {\n            this.setupGitBranchListener();\n        }\n    }\n\n    /**\n     * Update initial connection status on dashboard load\n     */\n    updateInitialConnectionStatus() {\n        console.log('SocketManager: Updating initial connection status');\n\n        // Force status check on socket client (uses fallback mechanism)\n        if (this.socketClient && typeof this.socketClient.checkAndUpdateStatus === 'function') {\n            console.log('SocketManager: Using socket client checkAndUpdateStatus method');\n            this.socketClient.checkAndUpdateStatus();\n        } else if (this.socketClient && this.socketClient.socket) {\n            console.log('SocketManager: Checking socket state directly', {\n                connected: this.socketClient.socket.connected,\n                connecting: this.socketClient.socket.connecting,\n                isConnecting: this.socketClient.isConnecting,\n                isConnected: this.socketClient.isConnected\n            });\n\n            if (this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket is already connected, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            } else if (this.socketClient.isConnecting || this.socketClient.socket.connecting) {\n                console.log('SocketManager: Socket is connecting, updating status');\n                this.updateConnectionStatus('Connecting...', 'connecting');\n            } else {\n                console.log('SocketManager: Socket is disconnected, updating status');\n                this.updateConnectionStatus('Disconnected', 'disconnected');\n            }\n        } else {\n            console.log('SocketManager: No socket client or socket found, setting disconnected status');\n            this.updateConnectionStatus('Disconnected', 'disconnected');\n        }\n\n        // Additional fallback - check again after a longer delay in case connection is still establishing\n        setTimeout(() => {\n            console.log('SocketManager: Secondary status check after 1 second');\n            if (this.socketClient && this.socketClient.socket && this.socketClient.socket.connected) {\n                console.log('SocketManager: Socket connected in secondary check, updating status');\n                this.updateConnectionStatus('Connected', 'connected');\n            }\n        }, 1000);\n    }\n\n    /**\n     * Set up git branch response listener for connected socket\n     */\n    setupGitBranchListener() {\n        // Remove any existing listener first\n        this.socketClient.socket.off('git_branch_response');\n\n        // Add the listener\n        this.socketClient.socket.on('git_branch_response', (data) => {\n            if (data.success) {\n                const footerBranch = document.getElementById('footer-git-branch');\n                if (footerBranch) {\n                    footerBranch.textContent = data.branch || 'unknown';\n                }\n                if (footerBranch) {\n                    footerBranch.style.display = 'inline';\n                }\n            } else {\n                console.error('Git branch request failed:', data.error);\n            }\n        });\n    }\n\n    /**\n     * Update connection status display\n     * @param {string} status - Status text to display\n     * @param {string} type - Status type for styling\n     */\n    updateConnectionStatus(status, type) {\n        const statusElement = document.getElementById('connection-status');\n        if (statusElement) {\n            // Check if there's a span indicator first\n            const indicator = statusElement.querySelector('span');\n            if (indicator) {\n                // If there's a span, update the text content after the span\n                const statusIndicator = type === 'connected' ? '●' : '●';\n                statusElement.innerHTML = `<span>${statusIndicator}</span> ${status}`;\n            } else {\n                // If no span, just update text content\n                statusElement.textContent = status;\n            }\n\n            statusElement.className = `status-badge status-${type}`;\n            console.log(`SocketManager: UI updated - status: '${status}' (${type})`);\n        } else {\n            console.error('SocketManager: Could not find connection-status element in DOM');\n        }\n    }\n\n    /**\n     * Connect to socket server\n     * @param {number} port - Port number to connect to\n     */\n    connect(port) {\n        if (this.socketClient) {\n            this.socketClient.connect(port);\n        }\n    }\n\n    /**\n     * Disconnect from socket server\n     */\n    disconnect() {\n        if (this.socketClient) {\n            this.socketClient.disconnect();\n        }\n    }\n\n    /**\n     * Check if socket is connected\n     * @returns {boolean} - True if connected\n     */\n    isConnected() {\n        return this.socketClient && this.socketClient.isConnected;\n    }\n\n    /**\n     * Check if socket is connecting\n     * @returns {boolean} - True if connecting\n     */\n    isConnecting() {\n        return this.socketClient && this.socketClient.isConnecting;\n    }\n\n    /**\n     * Get the underlying socket client\n     * @returns {SocketClient} - The socket client instance\n     */\n    getSocketClient() {\n        return this.socketClient;\n    }\n\n    /**\n     * Get the raw socket connection\n     * @returns {Socket|null} - The raw socket or null\n     */\n    getSocket() {\n        return this.socketClient ? this.socketClient.socket : null;\n    }\n\n    /**\n     * Register a callback for connection status changes\n     * @param {Function} callback - Callback function(status, type)\n     */\n    onConnectionStatusChange(callback) {\n        this.connectionCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister a connection status callback\n     * @param {Function} callback - Callback to remove\n     */\n    offConnectionStatusChange(callback) {\n        this.connectionCallbacks.delete(callback);\n    }\n\n    /**\n     * Register a callback for event updates\n     * @param {Function} callback - Callback function(events)\n     */\n    onEventUpdate(callback) {\n        this.eventUpdateCallbacks.add(callback);\n    }\n\n    /**\n     * Unregister an event update callback\n     * @param {Function} callback - Callback to remove\n     */\n    offEventUpdate(callback) {\n        this.eventUpdateCallbacks.delete(callback);\n    }\n\n    /**\n     * Toggle connection controls visibility\n     */\n    toggleConnectionControls() {\n        const controlsRow = document.getElementById('connection-controls-row');\n        const toggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (controlsRow && toggleBtn) {\n            const isVisible = controlsRow.classList.contains('show');\n\n            if (isVisible) {\n                controlsRow.classList.remove('show');\n                controlsRow.style.display = 'none';\n                toggleBtn.textContent = 'Connection Settings';\n            } else {\n                controlsRow.classList.add('show');\n                controlsRow.style.display = 'block';\n                toggleBtn.textContent = 'Hide Settings';\n            }\n        }\n    }\n\n    /**\n     * Setup connection control event handlers\n     * Called during dashboard initialization\n     */\n    setupConnectionControls() {\n        const connectBtn = document.getElementById('connect-btn');\n        const disconnectBtn = document.getElementById('disconnect-btn');\n        const connectionToggleBtn = document.getElementById('connection-toggle-btn');\n\n        if (connectBtn) {\n            connectBtn.addEventListener('click', () => {\n                const port = document.getElementById('port-input').value || 8765;\n                this.connect(port);\n            });\n        }\n\n        if (disconnectBtn) {\n            disconnectBtn.addEventListener('click', () => {\n                this.disconnect();\n            });\n        }\n\n        if (connectionToggleBtn) {\n            connectionToggleBtn.addEventListener('click', () => {\n                this.toggleConnectionControls();\n            });\n        }\n    }\n\n    /**\n     * Initialize connection from URL parameters\n     * @param {URLSearchParams} params - URL search parameters\n     */\n    initializeFromURL(params) {\n        const port = params.get('port');\n        const portInput = document.getElementById('port-input');\n\n        // Determine the port to use:\n        // 1. URL parameter 'port'\n        // 2. Current page port (if served via HTTP)\n        // 3. Default port value from input field\n        // 4. Fallback to 8765\n        let connectPort = port;\n        if (!connectPort && window.location.protocol === 'http:') {\n            connectPort = window.location.port || '8765';\n        }\n        if (!connectPort) {\n            connectPort = portInput?.value || '8765';\n        }\n\n        // Update the port input field with the determined port\n        if (portInput) {\n            portInput.value = connectPort;\n        }\n\n        // Auto-connect by default unless explicitly disabled\n        const shouldAutoConnect = params.get('connect') !== 'false';\n        if (shouldAutoConnect && !this.isConnected() && !this.isConnecting()) {\n            this.connect(connectPort);\n        }\n    }\n}\n\n// ES6 Module export\nexport { SocketManager };\nexport default SocketManager;\n","/**\n * UI State Manager Module\n *\n * Manages UI state including tab switching, card selection, keyboard navigation,\n * and visual feedback across the dashboard interface.\n *\n * WHY: Extracted from main dashboard to centralize UI state management and\n * provide better separation between business logic and UI state. This makes\n * the UI behavior more predictable and easier to test.\n *\n * DESIGN DECISION: Maintains centralized state for current tab, selected cards,\n * and navigation context while providing a clean API for other modules to\n * interact with UI state changes.\n */\nclass UIStateManager {\n    constructor() {\n        // Current active tab\n        this.currentTab = 'events';\n\n        // Auto-scroll behavior\n        this.autoScroll = true;\n\n        // Selection state - tracks the currently selected card across all tabs\n        this.selectedCard = {\n            tab: null,        // which tab the selection is in\n            index: null,      // index of selected item in that tab\n            type: null,       // 'event', 'agent', 'tool', 'file'\n            data: null        // the actual data object\n        };\n\n        // Navigation state for each tab\n        this.tabNavigation = {\n            events: { selectedIndex: -1, items: [] },\n            agents: { selectedIndex: -1, items: [] },\n            tools: { selectedIndex: -1, items: [] },\n            files: { selectedIndex: -1, items: [] }\n        };\n\n        this.setupEventHandlers();\n        console.log('UI state manager initialized');\n    }\n\n    /**\n     * Set up event handlers for UI interactions\n     */\n    setupEventHandlers() {\n        this.setupTabNavigation();\n        this.setupUnifiedKeyboardNavigation();\n    }\n\n    /**\n     * Set up tab navigation event listeners\n     */\n    setupTabNavigation() {\n        // Tab buttons\n        document.querySelectorAll('.tab-button').forEach(button => {\n            button.addEventListener('click', () => {\n                const tabName = this.getTabNameFromButton(button);\n                this.switchTab(tabName);\n            });\n        });\n    }\n\n    /**\n     * Set up unified keyboard navigation across all tabs\n     */\n    setupUnifiedKeyboardNavigation() {\n        document.addEventListener('keydown', (e) => {\n            // Only handle if not in an input field\n            if (document.activeElement &&\n                ['INPUT', 'TEXTAREA', 'SELECT'].includes(document.activeElement.tagName)) {\n                return;\n            }\n\n            if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {\n                e.preventDefault();\n                this.handleUnifiedArrowNavigation(e.key === 'ArrowDown' ? 1 : -1);\n            } else if (e.key === 'Enter') {\n                e.preventDefault();\n                this.handleUnifiedEnterKey();\n            } else if (e.key === 'Escape') {\n                this.clearUnifiedSelection();\n            }\n        });\n    }\n\n    /**\n     * Get tab name from button element\n     * @param {HTMLElement} button - Tab button element\n     * @returns {string} - Tab name\n     */\n    getTabNameFromButton(button) {\n        const text = button.textContent.toLowerCase();\n        if (text.includes('events')) return 'events';\n        if (text.includes('agents')) return 'agents';\n        if (text.includes('tools')) return 'tools';\n        if (text.includes('files')) return 'files';\n        return 'events';\n    }\n\n    /**\n     * Switch to specified tab\n     * @param {string} tabName - Name of tab to switch to\n     */\n    switchTab(tabName) {\n        console.log(`[DEBUG] switchTab called with tabName: ${tabName}`);\n        const previousTab = this.currentTab;\n        this.currentTab = tabName;\n\n        // Update tab button active states\n        document.querySelectorAll('.tab-button').forEach(btn => {\n            btn.classList.remove('active');\n            if (this.getTabNameFromButton(btn) === tabName) {\n                btn.classList.add('active');\n            }\n        });\n\n        // Show/hide tab content using CSS classes\n        document.querySelectorAll('.tab-content').forEach(content => {\n            content.classList.remove('active');\n        });\n\n        const activeTab = document.getElementById(`${tabName}-tab`);\n        if (activeTab) {\n            activeTab.classList.add('active');\n        }\n\n        // Clear previous selections when switching tabs\n        this.clearUnifiedSelection();\n\n        // Trigger tab change event for other modules\n        document.dispatchEvent(new CustomEvent('tabChanged', {\n            detail: {\n                newTab: tabName,\n                previousTab: previousTab\n            }\n        }));\n\n        // Auto-scroll to bottom after a brief delay to ensure content is rendered\n        setTimeout(() => {\n            if (this.autoScroll) {\n                this.scrollCurrentTabToBottom();\n            }\n        }, 100);\n    }\n\n    /**\n     * Handle unified arrow navigation across tabs\n     * @param {number} direction - Navigation direction (1 for down, -1 for up)\n     */\n    handleUnifiedArrowNavigation(direction) {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let newIndex = tabNav.selectedIndex + direction;\n\n        // Handle bounds\n        if (tabNav.items.length === 0) return;\n\n        if (newIndex < 0) {\n            newIndex = tabNav.items.length - 1;\n        } else if (newIndex >= tabNav.items.length) {\n            newIndex = 0;\n        }\n\n        this.selectCardByIndex(this.currentTab, newIndex);\n    }\n\n    /**\n     * Handle unified Enter key across all tabs\n     */\n    handleUnifiedEnterKey() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav || tabNav.selectedIndex === -1) return;\n\n        const selectedElement = tabNav.items[tabNav.selectedIndex];\n        if (selectedElement && selectedElement.onclick) {\n            selectedElement.onclick();\n        }\n    }\n\n    /**\n     * Clear all unified selection states\n     */\n    clearUnifiedSelection() {\n        // Clear all tab navigation states\n        Object.keys(this.tabNavigation).forEach(tabName => {\n            this.tabNavigation[tabName].selectedIndex = -1;\n        });\n\n        // Clear card selection\n        this.clearCardSelection();\n    }\n\n    /**\n     * Update tab navigation items for current tab\n     * Should be called after tab content is rendered\n     */\n    updateTabNavigationItems() {\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (!tabNav) return;\n\n        let containerSelector;\n        switch (this.currentTab) {\n            case 'events':\n                containerSelector = '#events-list .event-item';\n                break;\n            case 'agents':\n                containerSelector = '#agents-list .event-item';\n                break;\n            case 'tools':\n                containerSelector = '#tools-list .event-item';\n                break;\n            case 'files':\n                containerSelector = '#files-list .event-item';\n                break;\n        }\n\n        if (containerSelector) {\n            tabNav.items = Array.from(document.querySelectorAll(containerSelector));\n        }\n    }\n\n    /**\n     * Select card by index for specified tab\n     * @param {string} tabName - Tab name\n     * @param {number} index - Index of item to select\n     */\n    selectCardByIndex(tabName, index) {\n        const tabNav = this.tabNavigation[tabName];\n        if (!tabNav || index < 0 || index >= tabNav.items.length) return;\n\n        // Update navigation state\n        tabNav.selectedIndex = index;\n\n        // Update visual selection\n        this.updateUnifiedSelectionUI();\n\n        // If this is a different tab selection, record the card selection\n        const selectedElement = tabNav.items[index];\n        if (selectedElement) {\n            // Extract data from the element to populate selectedCard\n            this.selectCard(tabName, index, this.getCardType(tabName), index);\n        }\n\n        // Show details for the selected item\n        this.showCardDetails(tabName, index);\n    }\n\n    /**\n     * Update visual selection UI for unified navigation\n     */\n    updateUnifiedSelectionUI() {\n        // Clear all existing selections\n        document.querySelectorAll('.event-item.keyboard-selected').forEach(el => {\n            el.classList.remove('keyboard-selected');\n        });\n\n        // Apply selection to current tab's selected item\n        const tabNav = this.tabNavigation[this.currentTab];\n        if (tabNav && tabNav.selectedIndex !== -1 && tabNav.items[tabNav.selectedIndex]) {\n            tabNav.items[tabNav.selectedIndex].classList.add('keyboard-selected');\n        }\n    }\n\n    /**\n     * Show card details for specified tab and index\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     */\n    showCardDetails(tabName, index) {\n        // Dispatch event for other modules to handle\n        document.dispatchEvent(new CustomEvent('showCardDetails', {\n            detail: {\n                tabName: tabName,\n                index: index\n            }\n        }));\n    }\n\n    /**\n     * Select a specific card\n     * @param {string} tabName - Tab name\n     * @param {number} index - Item index\n     * @param {string} type - Item type\n     * @param {*} data - Item data\n     */\n    selectCard(tabName, index, type, data) {\n        // Clear previous selection\n        this.clearCardSelection();\n\n        // Update selection state\n        this.selectedCard = {\n            tab: tabName,\n            index: index,\n            type: type,\n            data: data\n        };\n\n        this.updateCardSelectionUI();\n\n        console.log('Card selected:', this.selectedCard);\n    }\n\n    /**\n     * Clear card selection\n     */\n    clearCardSelection() {\n        // Clear visual selection from all tabs\n        document.querySelectorAll('.event-item.selected, .file-item.selected').forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Reset selection state\n        this.selectedCard = {\n            tab: null,\n            index: null,\n            type: null,\n            data: null\n        };\n    }\n\n    /**\n     * Update card selection UI\n     */\n    updateCardSelectionUI() {\n        if (!this.selectedCard.tab || this.selectedCard.index === null) return;\n\n        // Get the list container for the selected tab\n        let listContainer;\n        switch (this.selectedCard.tab) {\n            case 'events':\n                listContainer = document.getElementById('events-list');\n                break;\n            case 'agents':\n                listContainer = document.getElementById('agents-list');\n                break;\n            case 'tools':\n                listContainer = document.getElementById('tools-list');\n                break;\n            case 'files':\n                listContainer = document.getElementById('files-list');\n                break;\n        }\n\n        if (listContainer) {\n            const items = listContainer.querySelectorAll('.event-item, .file-item');\n            if (items[this.selectedCard.index]) {\n                items[this.selectedCard.index].classList.add('selected');\n            }\n        }\n    }\n\n    /**\n     * Get card type based on tab name\n     * @param {string} tabName - Tab name\n     * @returns {string} - Card type\n     */\n    getCardType(tabName) {\n        switch (tabName) {\n            case 'events': return 'event';\n            case 'agents': return 'agent';\n            case 'tools': return 'tool';\n            case 'files': return 'file';\n            default: return 'unknown';\n        }\n    }\n\n    /**\n     * Scroll current tab to bottom\n     */\n    scrollCurrentTabToBottom() {\n        const tabId = `${this.currentTab}-list`;\n        const element = document.getElementById(tabId);\n        if (element && this.autoScroll) {\n            element.scrollTop = element.scrollHeight;\n        }\n    }\n\n    /**\n     * Clear selection for cleanup\n     */\n    clearSelection() {\n        this.clearCardSelection();\n        this.clearUnifiedSelection();\n    }\n\n    /**\n     * Get current tab name\n     * @returns {string} - Current tab name\n     */\n    getCurrentTab() {\n        return this.currentTab;\n    }\n\n    /**\n     * Get selected card info\n     * @returns {Object} - Selected card state\n     */\n    getSelectedCard() {\n        return { ...this.selectedCard };\n    }\n\n    /**\n     * Get tab navigation state\n     * @returns {Object} - Tab navigation state\n     */\n    getTabNavigation() {\n        return { ...this.tabNavigation };\n    }\n\n    /**\n     * Set auto-scroll behavior\n     * @param {boolean} enabled - Whether to enable auto-scroll\n     */\n    setAutoScroll(enabled) {\n        this.autoScroll = enabled;\n    }\n\n    /**\n     * Get auto-scroll state\n     * @returns {boolean} - Auto-scroll enabled state\n     */\n    getAutoScroll() {\n        return this.autoScroll;\n    }\n}\n// ES6 Module export\nexport { UIStateManager };\nexport default UIStateManager;\n"],"names":["io","window","SocketClient","constructor","this","socket","port","connectionCallbacks","connect","disconnect","error","event","isConnected","isConnecting","lastConnectTime","disconnectTime","events","sessions","Map","currentSessionId","eventQueue","maxQueueSize","retryAttempts","maxRetryAttempts","retryDelays","pendingEmissions","lastPingTime","lastPongTime","pingTimeout","healthCheckInterval","startStatusCheckFallback","startHealthMonitoring","url","connected","connecting","console","log","setTimeout","doConnect","notifyConnectionStatus","autoConnect","reconnection","reconnectionDelay","reconnectionDelayMax","maxReconnectionAttempts","timeout","forceNew","transports","setupSocketHandlers","on","previouslyConnected","Date","now","downtime","toFixed","flushEventQueue","forEach","callback","id","requestStatus","reason","uptime","scheduleReconnect","errorMsg","message","description","addEvent","type","timestamp","toISOString","data","uri","retry_attempt","transformedEvent","transformEvent","emit","client_time","subtype","Array","isArray","length","count","total_available","notifyEventUpdate","updateSessions","current_session","emitWithRetry","options","maxRetries","onSuccess","onFailure","emissionId","Math","random","attemptEmission","attemptNum","delete","delay","set","scheduledTime","queueEvent","removed","shift","warn","push","item","index","requestHistory","params","limit","event_types","eventData","notify","session_id","sessionId","has","startTime","lastActivity","eventCount","session","get","sessionsData","clearEvents","clear","refreshHistory","getEventsBySession","filter","onConnection","eventType","onEventUpdate","status","updateConnectionStatusDOM","document","dispatchEvent","CustomEvent","detail","statusElement","getElementById","innerHTML","className","getConnectionState","socketId","eventName","toLowerCase","replace","startsWith","substring","includes","mainType","subtypeParts","split","join","originalEventName","protectedFields","Object","keys","key","tool_name","has_data","k","getState","setInterval","timeSinceLastPing","stopHealthMonitoring","clearInterval","checkAndUpdateStatus","readyState","addEventListener","actualStatus","actualType","currentText","textContent","trim","currentClass","expectedClass","destroy","getConnectionMetrics","lastPing","queuedEvents","size","SocketManager","socketClient","Set","eventUpdateCallbacks","setupSocketEventHandlers","updateInitialConnectionStatus","e","handleConnectionStatusChange","updateConnectionStatus","setupGitBranchListener","off","success","footerBranch","branch","style","display","querySelector","statusIndicator","getSocketClient","getSocket","onConnectionStatusChange","add","offConnectionStatusChange","offEventUpdate","toggleConnectionControls","controlsRow","toggleBtn","classList","contains","remove","setupConnectionControls","connectBtn","disconnectBtn","connectionToggleBtn","value","initializeFromURL","portInput","connectPort","location","protocol","UIStateManager","currentTab","autoScroll","selectedCard","tab","tabNavigation","selectedIndex","items","agents","tools","files","setupEventHandlers","setupTabNavigation","setupUnifiedKeyboardNavigation","querySelectorAll","button","tabName","getTabNameFromButton","switchTab","activeElement","tagName","preventDefault","handleUnifiedArrowNavigation","handleUnifiedEnterKey","clearUnifiedSelection","text","previousTab","btn","content","activeTab","newTab","scrollCurrentTabToBottom","direction","tabNav","newIndex","selectCardByIndex","selectedElement","onclick","clearCardSelection","updateTabNavigationItems","containerSelector","from","updateUnifiedSelectionUI","selectCard","getCardType","showCardDetails","el","updateCardSelectionUI","listContainer","tabId","element","scrollTop","scrollHeight","clearSelection","getCurrentTab","getSelectedCard","getTabNavigation","setAutoScroll","enabled","getAutoScroll"],"mappings":"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"}