{"version":3,"file":"module-viewer.js","sources":["../../js/components/module-viewer.js"],"sourcesContent":["/**\n * Module Viewer Component\n * Displays detailed information about selected events organized by class/type\n * Now uses UnifiedDataViewer for consistent data formatting\n */\n\nimport { UnifiedDataViewer } from './unified-data-viewer.js';\n\nclass ModuleViewer {\n    constructor(containerId) {\n        this.container = document.getElementById(containerId);\n        this.dataContainer = null;\n        this.jsonContainer = null;\n        this.currentEvent = null;\n        this.eventsByClass = new Map();\n\n        // Global JSON visibility state - persisted across all events\n        // When true, all events show JSON expanded; when false, all collapsed\n        this.globalJsonExpanded = localStorage.getItem('dashboard-json-expanded') === 'true';\n        \n        // Track if keyboard listener has been added to avoid duplicates\n        this.keyboardListenerAdded = false;\n        \n        // Initialize unified data viewer\n        this.unifiedViewer = new UnifiedDataViewer('module-data-content');\n\n        this.init();\n    }\n\n    /**\n     * Initialize the module viewer\n     */\n    init() {\n        this.setupContainers();\n        this.setupEventHandlers();\n        this.showEmptyState();\n    }\n\n    /**\n     * Setup container references for the two-pane layout\n     */\n    setupContainers() {\n        this.dataContainer = document.getElementById('module-data-content');\n        this.jsonContainer = null; // No longer used - JSON is handled via collapsible sections\n\n        if (!this.dataContainer) {\n            console.error('Module viewer data container not found');\n        }\n    }\n\n    /**\n     * Setup event handlers\n     */\n    setupEventHandlers() {\n        // Listen for event selection\n        document.addEventListener('eventSelected', (e) => {\n            this.showEventDetails(e.detail.event);\n        });\n\n        // Listen for selection cleared\n        document.addEventListener('eventSelectionCleared', () => {\n            this.showEmptyState();\n        });\n\n        // Listen for socket event updates to maintain event classification\n        document.addEventListener('socketEventUpdate', (e) => {\n            this.updateEventsByClass(e.detail.events);\n        });\n    }\n\n    /**\n     * Show empty state when no event is selected\n     */\n    showEmptyState() {\n        if (this.dataContainer) {\n            this.dataContainer.innerHTML = `\n                <div class=\"module-empty\">\n                    <p>Click on an event to view structured data</p>\n                    <p class=\"module-hint\">Data is organized by event type</p>\n                </div>\n            `;\n        }\n\n        // JSON container no longer exists - handled via collapsible sections\n\n        this.currentEvent = null;\n    }\n\n    /**\n     * Show details for a selected event using UnifiedDataViewer\n     * @param {Object} event - The selected event\n     */\n    showEventDetails(event) {\n        this.currentEvent = event;\n        \n        if (!this.unifiedViewer) {\n            console.warn('ModuleViewer: UnifiedDataViewer not available');\n            // Fallback to legacy rendering\n            this.renderStructuredData(event);\n            this.renderJsonData(event);\n            return;\n        }\n        \n        // Use unified viewer to display event data\n        this.unifiedViewer.display(event, 'event');\n    }\n\n    /**\n     * Render structured data in the data pane with collapsible JSON section\n     * @param {Object} event - The event to render\n     */\n    renderStructuredData(event) {\n        if (!this.dataContainer) return;\n\n        // Create contextual header\n        const contextualHeader = this.createContextualHeader(event);\n\n        // Create structured view based on event type\n        const structuredView = this.createEventStructuredView(event);\n\n        // Create collapsible JSON section\n        const collapsibleJsonSection = this.createCollapsibleJsonSection(event);\n\n        // Combine all sections in data container\n        this.dataContainer.innerHTML = contextualHeader + structuredView + collapsibleJsonSection;\n\n        // Initialize JSON toggle functionality\n        this.initializeJsonToggle();\n    }\n\n    /**\n     * Render JSON data in the JSON pane (legacy support - now using collapsible section)\n     * @param {Object} event - The event to render\n     */\n    renderJsonData(event) {\n        // JSON is now integrated into data container as collapsible section\n        // Hide the JSON pane completely by clearing it\n        // JSON container no longer exists - handled via collapsible sections\n    }\n\n    /**\n     * Ingest method that determines how to render event(s)\n     * @param {Object|Array} eventData - Single event or array of events\n     */\n    ingest(eventData) {\n        if (Array.isArray(eventData)) {\n            // Handle multiple events - for now, show the first one\n            if (eventData.length > 0) {\n                this.showEventDetails(eventData[0]);\n            } else {\n                this.showEmptyState();\n            }\n        } else if (eventData && typeof eventData === 'object') {\n            // Handle single event\n            this.showEventDetails(eventData);\n        } else {\n            // Invalid data\n            this.showEmptyState();\n        }\n    }\n\n    /**\n     * Update events grouped by class for analysis\n     * @param {Array} events - All events\n     */\n    updateEventsByClass(events) {\n        this.eventsByClass.clear();\n\n        events.forEach(event => {\n            const eventClass = this.getEventClass(event);\n            if (!this.eventsByClass.has(eventClass)) {\n                this.eventsByClass.set(eventClass, []);\n            }\n            this.eventsByClass.get(eventClass).push(event);\n        });\n    }\n\n    /**\n     * Get event class/category for grouping\n     * @param {Object} event - Event object\n     * @returns {string} Event class\n     */\n    getEventClass(event) {\n        if (!event.type) return 'unknown';\n\n        // Group similar event types\n        switch (event.type) {\n            case 'session':\n                return 'Session Management';\n            case 'claude':\n                return 'Claude Interactions';\n            case 'agent':\n                return 'Agent Operations';\n            case 'hook':\n                return 'Hook System';\n            case 'todo':\n                return 'Task Management';\n            case 'memory':\n                return 'Memory Operations';\n            case 'log':\n                return 'System Logs';\n            case 'connection':\n                return 'Connection Events';\n            default:\n                return 'Other Events';\n        }\n    }\n\n    /**\n     * Create contextual header for the structured data\n     * @param {Object} event - Event to display\n     * @returns {string} HTML content\n     */\n    createContextualHeader(event) {\n        const timestamp = this.formatTimestamp(event.timestamp);\n        const data = event.data || {};\n        let headerText = '';\n\n        // Determine header text based on event type\n        switch (event.type) {\n            case 'hook':\n                // For Tools: \"ToolName: [Agent] [time]\"\n                const toolName = this.extractToolName(data);\n                const agent = this.extractAgent(event) || 'Unknown';\n                if (toolName) {\n                    headerText = `${toolName}: ${agent} ${timestamp}`;\n                } else {\n                    const hookName = this.getHookDisplayName(event, data);\n                    headerText = `${hookName}: ${agent} ${timestamp}`;\n                }\n                break;\n\n            case 'agent':\n                // For Agents: \"Agent: [AgentType] [time]\"\n                const agentType = data.agent_type || data.name || 'Unknown';\n                headerText = `Agent: ${agentType} ${timestamp}`;\n                break;\n\n            case 'todo':\n                // For TodoWrite: \"TodoWrite: [Agent] [time]\"\n                const todoAgent = this.extractAgent(event) || 'PM';\n                headerText = `TodoWrite: ${todoAgent} ${timestamp}`;\n                break;\n\n            case 'memory':\n                // For Memory: \"Memory: [Operation] [time]\"\n                const operation = data.operation || 'Unknown';\n                headerText = `Memory: ${operation} ${timestamp}`;\n                break;\n\n            case 'session':\n            case 'claude':\n            case 'log':\n            case 'connection':\n                // For Events: \"Event: [Type.Subtype] [time]\"\n                const eventType = event.type;\n                const subtype = event.subtype || 'default';\n                headerText = `Event: ${eventType}.${subtype} ${timestamp}`;\n                break;\n\n            default:\n                // For Files and other events: \"File: [filename] [time]\" or generic\n                const fileName = this.extractFileName(data);\n                if (fileName) {\n                    headerText = `File: ${fileName} ${timestamp}`;\n                } else {\n                    const eventType = event.type || 'Unknown';\n                    const subtype = event.subtype || 'default';\n                    headerText = `Event: ${eventType}.${subtype} ${timestamp}`;\n                }\n                break;\n        }\n\n        return `\n            <div class=\"contextual-header\">\n                <h3 class=\"contextual-header-text\">${headerText}</h3>\n            </div>\n        `;\n    }\n\n    /**\n     * Create structured view for an event\n     * @param {Object} event - Event to display\n     * @returns {string} HTML content\n     */\n    createEventStructuredView(event) {\n        const eventClass = this.getEventClass(event);\n        const relatedEvents = this.eventsByClass.get(eventClass) || [];\n        const eventCount = relatedEvents.length;\n\n        let content = `\n            <div class=\"structured-view-section\">\n                ${this.createEventDetailCard(event.type, event, eventCount)}\n            </div>\n        `;\n\n        // Add type-specific content\n        switch (event.type) {\n            case 'agent':\n                content += this.createAgentStructuredView(event);\n                break;\n            case 'hook':\n                // Check if this is actually a Task delegation (agent-related hook)\n                if (event.data?.tool_name === 'Task' && event.data?.tool_parameters?.subagent_type) {\n                    content += this.createAgentStructuredView(event);\n                } else {\n                    content += this.createHookStructuredView(event);\n                }\n                break;\n            case 'todo':\n                content += this.createTodoStructuredView(event);\n                break;\n            case 'memory':\n                content += this.createMemoryStructuredView(event);\n                break;\n            case 'claude':\n                content += this.createClaudeStructuredView(event);\n                break;\n            case 'session':\n                content += this.createSessionStructuredView(event);\n                break;\n            default:\n                content += this.createGenericStructuredView(event);\n                break;\n        }\n\n        // Note: JSON section is now rendered separately in the JSON pane\n        return content;\n    }\n\n    /**\n     * Create event detail card\n     */\n    createEventDetailCard(eventType, event, count) {\n        const timestamp = new Date(event.timestamp).toLocaleString();\n        const eventIcon = this.getEventIcon(eventType);\n\n        return `\n            <div class=\"event-detail-card\">\n                <div class=\"event-detail-header\">\n                    <div class=\"event-detail-title\">\n                        ${eventIcon} ${eventType || 'Unknown'}.${event.subtype || 'default'}\n                    </div>\n                    <div class=\"event-detail-time\">${timestamp}</div>\n                </div>\n                <div class=\"event-detail-content\">\n                    ${this.createProperty('Event ID', event.id || 'N/A')}\n                    ${this.createProperty('Type', `${eventType}.${event.subtype || 'default'}`)}\n                    ${this.createProperty('Class Events', count)}\n                    ${event.data && event.data.session_id ?\n                        this.createProperty('Session', event.data.session_id) : ''}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create agent-specific structured view\n     */\n    createAgentStructuredView(event) {\n        const data = event.data || {};\n\n        // Handle Task delegation events (which appear as hook events but contain agent info)\n        if (event.type === 'hook' && data.tool_name === 'Task' && data.tool_parameters?.subagent_type) {\n            const taskData = data.tool_parameters;\n            return `\n                <div class=\"structured-view-section\">\n                    <div class=\"structured-data\">\n                        ${this.createProperty('Agent Type', taskData.subagent_type)}\n                        ${this.createProperty('Task Type', 'Subagent Delegation')}\n                        ${this.createProperty('Phase', event.subtype || 'pre_tool')}\n                        ${taskData.description ? this.createProperty('Description', taskData.description) : ''}\n                        ${taskData.prompt ? this.createProperty('Prompt Preview', this.truncateText(taskData.prompt, 200)) : ''}\n                        ${data.session_id ? this.createProperty('Session ID', data.session_id) : ''}\n                        ${data.working_directory ? this.createProperty('Working Directory', data.working_directory) : ''}\n                    </div>\n                    ${taskData.prompt ? `\n                        <div class=\"prompt-section\">\n                            <div class=\"contextual-header\">\n                                <h3 class=\"contextual-header-text\">📝 Task Prompt</h3>\n                            </div>\n                            <div class=\"structured-data\">\n                                <div class=\"task-prompt\" style=\"white-space: pre-wrap; max-height: 300px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 6px; font-family: monospace; font-size: 12px; line-height: 1.4;\">\n                                    ${taskData.prompt}\n                                </div>\n                            </div>\n                        </div>\n                    ` : ''}\n                </div>\n            `;\n        }\n\n        // Handle regular agent events\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Agent Type', data.agent_type || data.subagent_type || 'Unknown')}\n                    ${this.createProperty('Name', data.name || 'N/A')}\n                    ${this.createProperty('Phase', event.subtype || 'N/A')}\n                    ${data.config ? this.createProperty('Config', typeof data.config === 'object' ? Object.keys(data.config).join(', ') : String(data.config)) : ''}\n                    ${data.capabilities ? this.createProperty('Capabilities', data.capabilities.join(', ')) : ''}\n                    ${data.result ? this.createProperty('Result', typeof data.result === 'object' ? '[Object]' : String(data.result)) : ''}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create hook-specific structured view\n     */\n    createHookStructuredView(event) {\n        const data = event.data || {};\n\n        // Extract file path information from tool parameters\n        const filePath = this.extractFilePathFromHook(data);\n        const toolInfo = this.extractToolInfoFromHook(data);\n\n        // Note: Git diff functionality moved to Files tab only\n        // Events tab no longer shows git diff buttons\n\n        // Create inline tool result content if available (without separate section header)\n        const toolResultContent = this.createInlineToolResultContent(data, event);\n\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Hook Name', this.getHookDisplayName(event, data))}\n                    ${this.createProperty('Event Type', data.event_type || event.subtype || 'N/A')}\n                    ${filePath ? this.createProperty('File Path', filePath) : ''}\n                    ${toolInfo.tool_name ? this.createProperty('Tool', toolInfo.tool_name) : ''}\n                    ${toolInfo.operation_type ? this.createProperty('Operation', toolInfo.operation_type) : ''}\n                    ${data.session_id ? this.createProperty('Session ID', data.session_id) : ''}\n                    ${data.working_directory ? this.createProperty('Working Directory', data.working_directory) : ''}\n                    ${data.duration_ms ? this.createProperty('Duration', `${data.duration_ms}ms`) : ''}\n                    ${toolResultContent}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create inline tool result content (no separate section header)\n     * @param {Object} data - Event data\n     * @param {Object} event - Full event object (optional, for phase checking)\n     * @returns {string} HTML content for inline tool result display\n     */\n    createInlineToolResultContent(data, event = null) {\n        const resultSummary = data.result_summary;\n\n        // Determine if this is a post-tool event\n        // Check multiple possible locations for the event phase\n        const eventPhase = event?.subtype || data.event_type || data.phase;\n        const isPostTool = eventPhase === 'post_tool' || eventPhase?.includes('post');\n\n        // Debug logging to help troubleshoot tool result display issues\n        if (window.DEBUG_TOOL_RESULTS) {\n            console.log('🔧 createInlineToolResultContent debug:', {\n                hasResultSummary: !!resultSummary,\n                eventPhase,\n                isPostTool,\n                eventSubtype: event?.subtype,\n                dataEventType: data.event_type,\n                dataPhase: data.phase,\n                toolName: data.tool_name,\n                resultSummaryKeys: resultSummary ? Object.keys(resultSummary) : []\n            });\n        }\n\n        // Only show results if we have result data and this is a post-tool event\n        // OR if we have result_summary regardless of phase (some events may not have proper phase info)\n        if (!resultSummary) {\n            return '';\n        }\n\n        // If we know this is a pre-tool event, don't show results\n        if (eventPhase === 'pre_tool' || (eventPhase?.includes('pre') && !eventPhase?.includes('post'))) {\n            return '';\n        }\n\n        let resultContent = '';\n\n        // Add output preview if available\n        if (resultSummary.has_output && resultSummary.output_preview) {\n            resultContent += `\n                ${this.createProperty('Output', this.truncateText(resultSummary.output_preview, 200))}\n                ${resultSummary.output_lines ? this.createProperty('Output Lines', resultSummary.output_lines) : ''}\n            `;\n        }\n\n        // Add error preview if available\n        if (resultSummary.has_error && resultSummary.error_preview) {\n            resultContent += `\n                ${this.createProperty('Error', this.truncateText(resultSummary.error_preview, 200))}\n            `;\n        }\n\n        // If no specific output or error, but we have other result info\n        if (!resultSummary.has_output && !resultSummary.has_error && Object.keys(resultSummary).length > 3) {\n            // Show other result fields\n            const otherFields = Object.entries(resultSummary)\n                .filter(([key, value]) => !['has_output', 'has_error', 'exit_code'].includes(key) && value !== undefined)\n                .map(([key, value]) => this.createProperty(this.formatFieldName(key), String(value)))\n                .join('');\n\n            resultContent += otherFields;\n        }\n\n        return resultContent;\n    }\n\n    /**\n     * Create tool result section if result data is available\n     * @param {Object} data - Event data\n     * @param {Object} event - Full event object (optional, for phase checking)\n     * @returns {string} HTML content for tool result section\n     */\n    createToolResultSection(data, event = null) {\n        const resultSummary = data.result_summary;\n\n        // Determine if this is a post-tool event\n        // Check multiple possible locations for the event phase\n        const eventPhase = event?.subtype || data.event_type || data.phase;\n        const isPostTool = eventPhase === 'post_tool' || eventPhase?.includes('post');\n\n        // Debug logging to help troubleshoot tool result display issues\n        if (window.DEBUG_TOOL_RESULTS) {\n            console.log('🔧 createToolResultSection debug:', {\n                hasResultSummary: !!resultSummary,\n                eventPhase,\n                isPostTool,\n                eventSubtype: event?.subtype,\n                dataEventType: data.event_type,\n                dataPhase: data.phase,\n                toolName: data.tool_name,\n                resultSummaryKeys: resultSummary ? Object.keys(resultSummary) : []\n            });\n        }\n\n        // Only show results if we have result data and this is a post-tool event\n        // OR if we have result_summary regardless of phase (some events may not have proper phase info)\n        if (!resultSummary) {\n            return '';\n        }\n\n        // If we know this is a pre-tool event, don't show results\n        if (eventPhase === 'pre_tool' || (eventPhase?.includes('pre') && !eventPhase?.includes('post'))) {\n            return '';\n        }\n\n        // Determine result status and icon\n        let statusIcon = '⏳';\n        let statusClass = 'tool-running';\n        let statusText = 'Unknown';\n\n        if (data.success === true) {\n            statusIcon = '✅';\n            statusClass = 'tool-success';\n            statusText = 'Success';\n        } else if (data.success === false) {\n            statusIcon = '❌';\n            statusClass = 'tool-failure';\n            statusText = 'Failed';\n        } else if (data.exit_code === 0) {\n            statusIcon = '✅';\n            statusClass = 'tool-success';\n            statusText = 'Completed';\n        } else if (data.exit_code === 2) {\n            statusIcon = '⚠️';\n            statusClass = 'tool-blocked';\n            statusText = 'Blocked';\n        } else if (data.exit_code !== undefined && data.exit_code !== 0) {\n            statusIcon = '❌';\n            statusClass = 'tool-failure';\n            statusText = 'Error';\n        }\n\n        let resultContent = '';\n\n        // Add basic result info\n        resultContent += `\n            <div class=\"tool-result-status ${statusClass}\">\n                <span class=\"tool-result-icon\">${statusIcon}</span>\n                <span class=\"tool-result-text\">${statusText}</span>\n                ${data.exit_code !== undefined ? `<span class=\"tool-exit-code\">Exit Code: ${data.exit_code}</span>` : ''}\n            </div>\n        `;\n\n        // Add output preview if available\n        if (resultSummary.has_output && resultSummary.output_preview) {\n            resultContent += `\n                <div class=\"tool-result-output\">\n                    <div class=\"tool-result-label\">📄 Output:</div>\n                    <div class=\"tool-result-preview\">\n                        <pre>${this.escapeHtml(resultSummary.output_preview)}</pre>\n                    </div>\n                    ${resultSummary.output_lines ? `<div class=\"tool-result-meta\">Lines: ${resultSummary.output_lines}</div>` : ''}\n                </div>\n            `;\n        }\n\n        // Add error preview if available\n        if (resultSummary.has_error && resultSummary.error_preview) {\n            resultContent += `\n                <div class=\"tool-result-error\">\n                    <div class=\"tool-result-label\">⚠️ Error:</div>\n                    <div class=\"tool-result-preview error-preview\">\n                        <pre>${this.escapeHtml(resultSummary.error_preview)}</pre>\n                    </div>\n                </div>\n            `;\n        }\n\n        // If no specific output or error, but we have other result info\n        if (!resultSummary.has_output && !resultSummary.has_error && Object.keys(resultSummary).length > 3) {\n            // Show other result fields\n            const otherFields = Object.entries(resultSummary)\n                .filter(([key, value]) => !['has_output', 'has_error', 'exit_code'].includes(key) && value !== undefined)\n                .map(([key, value]) => this.createProperty(this.formatFieldName(key), String(value)))\n                .join('');\n\n            if (otherFields) {\n                resultContent += `\n                    <div class=\"tool-result-other\">\n                        <div class=\"tool-result-label\">📊 Result Details:</div>\n                        <div class=\"structured-data\">\n                            ${otherFields}\n                        </div>\n                    </div>\n                `;\n            }\n        }\n\n        // Only return content if we have something to show\n        if (!resultContent.trim()) {\n            return '';\n        }\n\n        return `\n            <div class=\"tool-result-section\">\n                <div class=\"contextual-header\">\n                    <h3 class=\"contextual-header-text\">🔧 Tool Result</h3>\n                </div>\n                <div class=\"tool-result-content\">\n                    ${resultContent}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Check if this is a write operation that modifies files\n     * @param {string} toolName - Name of the tool used\n     * @param {Object} data - Event data\n     * @returns {boolean} True if this is a write operation\n     */\n    isWriteOperation(toolName, data) {\n        // Common write operation tool names\n        const writeTools = [\n            'Write',\n            'Edit',\n            'MultiEdit',\n            'NotebookEdit'\n        ];\n\n        if (writeTools.includes(toolName)) {\n            return true;\n        }\n\n        // Check for write-related parameters in the data\n        if (data.tool_parameters) {\n            const params = data.tool_parameters;\n\n            // Check for content or editing parameters\n            if (params.content || params.new_string || params.edits) {\n                return true;\n            }\n\n            // Check for file modification indicators\n            if (params.edit_mode && params.edit_mode !== 'read') {\n                return true;\n            }\n        }\n\n        // Check event subtype for write operations\n        if (data.event_type === 'post_tool' || data.event_type === 'pre_tool') {\n            // Additional heuristics based on tool usage patterns\n            if (toolName && (\n                toolName.toLowerCase().includes('write') ||\n                toolName.toLowerCase().includes('edit') ||\n                toolName.toLowerCase().includes('modify')\n            )) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    /**\n     * Determines if a file operation is read-only or modifies the file\n     * @param {string} operation - The operation type\n     * @returns {boolean} True if operation is read-only, false if it modifies the file\n     */\n    isReadOnlyOperation(operation) {\n        if (!operation) return true; // Default to read-only for safety\n\n        const readOnlyOperations = ['read'];\n        const editOperations = ['write', 'edit', 'multiedit', 'create', 'delete', 'move', 'copy'];\n\n        const opLower = operation.toLowerCase();\n\n        // Explicitly read-only operations\n        if (readOnlyOperations.includes(opLower)) {\n            return true;\n        }\n\n        // Explicitly edit operations\n        if (editOperations.includes(opLower)) {\n            return false;\n        }\n\n        // Default to read-only for unknown operations\n        return true;\n    }\n\n    /**\n     * Create todo-specific structured view\n     */\n    createTodoStructuredView(event) {\n        const data = event.data || {};\n\n        let content = '';\n\n        // Add todo checklist if available - start directly with checklist\n        if (data.todos && Array.isArray(data.todos)) {\n            content += `\n                <div class=\"todo-checklist\">\n                    ${data.todos.map(todo => `\n                        <div class=\"todo-item todo-${todo.status || 'pending'}\">\n                            <span class=\"todo-status\">${this.getTodoStatusIcon(todo.status)}</span>\n                            <span class=\"todo-content\">${todo.content || 'No content'}</span>\n                            <span class=\"todo-priority priority-${todo.priority || 'medium'}\">${this.getTodoPriorityIcon(todo.priority)}</span>\n                        </div>\n                    `).join('')}\n                </div>\n            `;\n        }\n\n        return content;\n    }\n\n    /**\n     * Create memory-specific structured view\n     */\n    createMemoryStructuredView(event) {\n        const data = event.data || {};\n\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Operation', data.operation || 'Unknown')}\n                    ${this.createProperty('Key', data.key || 'N/A')}\n                    ${data.value ? this.createProperty('Value', typeof data.value === 'object' ? '[Object]' : String(data.value)) : ''}\n                    ${data.namespace ? this.createProperty('Namespace', data.namespace) : ''}\n                    ${data.metadata ? this.createProperty('Metadata', typeof data.metadata === 'object' ? '[Object]' : String(data.metadata)) : ''}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create Claude-specific structured view\n     */\n    createClaudeStructuredView(event) {\n        const data = event.data || {};\n\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Type', event.subtype || 'N/A')}\n                    ${data.prompt ? this.createProperty('Prompt', this.truncateText(data.prompt, 200)) : ''}\n                    ${data.message ? this.createProperty('Message', this.truncateText(data.message, 200)) : ''}\n                    ${data.response ? this.createProperty('Response', this.truncateText(data.response, 200)) : ''}\n                    ${data.content ? this.createProperty('Content', this.truncateText(data.content, 200)) : ''}\n                    ${data.tokens ? this.createProperty('Tokens', data.tokens) : ''}\n                    ${data.model ? this.createProperty('Model', data.model) : ''}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create session-specific structured view\n     */\n    createSessionStructuredView(event) {\n        const data = event.data || {};\n\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Action', event.subtype || 'N/A')}\n                    ${this.createProperty('Session ID', data.session_id || 'N/A')}\n                    ${data.working_directory ? this.createProperty('Working Dir', data.working_directory) : ''}\n                    ${data.git_branch ? this.createProperty('Git Branch', data.git_branch) : ''}\n                    ${data.agent_type ? this.createProperty('Agent Type', data.agent_type) : ''}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create generic structured view\n     */\n    createGenericStructuredView(event) {\n        const data = event.data || {};\n        const keys = Object.keys(data);\n\n        if (keys.length === 0) {\n            return '';\n        }\n\n        return `\n            <div class=\"structured-view-section\">\n                <div class=\"structured-data\">\n                    ${keys.map(key =>\n                        this.createProperty(key, typeof data[key] === 'object' ?\n                            '[Object]' : String(data[key]))\n                    ).join('')}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create collapsible JSON section that appears below main content\n     * WHY: Uses global state to maintain consistent JSON visibility across all events\n     * DESIGN DECISION: Sticky toggle improves debugging workflow by maintaining JSON\n     * visibility preference as user navigates through different events\n     * @param {Object} event - The event to render\n     * @returns {string} HTML content\n     */\n    createCollapsibleJsonSection(event) {\n        const uniqueId = 'json-section-' + Math.random().toString(36).substr(2, 9);\n        const jsonString = this.formatJSON(event);\n        \n        // Use global state to determine initial visibility\n        const isExpanded = this.globalJsonExpanded;\n        const display = isExpanded ? 'block' : 'none';\n        const arrow = isExpanded ? '▲' : '▼';\n        const ariaExpanded = isExpanded ? 'true' : 'false';\n        \n        return `\n            <div class=\"collapsible-json-section\" id=\"${uniqueId}\">\n                <div class=\"json-toggle-header\"\n                     onclick=\"window.moduleViewer.toggleJsonSection()\"\n                     role=\"button\"\n                     tabindex=\"0\"\n                     aria-expanded=\"${ariaExpanded}\"\n                     onkeydown=\"if(event.key==='Enter'||event.key===' '){window.moduleViewer.toggleJsonSection();event.preventDefault();}\">\n                    <span class=\"json-toggle-text\">Raw JSON</span>\n                    <span class=\"json-toggle-arrow\">${arrow}</span>\n                </div>\n                <div class=\"json-content-collapsible\" style=\"display: ${display};\" aria-hidden=\"${!isExpanded}\">\n                    <div class=\"json-display\" onclick=\"window.moduleViewer.copyJsonToClipboard(event)\">\n                        <pre>${jsonString}</pre>\n                    </div>\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Copy JSON content to clipboard\n     * @param {Event} event - Click event\n     */\n    async copyJsonToClipboard(event) {\n        // Only trigger on the copy icon area (top-right corner)\n        const rect = event.currentTarget.getBoundingClientRect();\n        const clickX = event.clientX - rect.left;\n        const clickY = event.clientY - rect.top;\n\n        // Check if click is in the top-right corner (copy icon area)\n        if (clickX > rect.width - 50 && clickY < 30) {\n            const preElement = event.currentTarget.querySelector('pre');\n            if (preElement) {\n                try {\n                    await navigator.clipboard.writeText(preElement.textContent);\n                    this.showNotification('JSON copied to clipboard', 'success');\n                } catch (err) {\n                    console.error('Failed to copy JSON:', err);\n                    this.showNotification('Failed to copy JSON', 'error');\n                }\n            }\n            event.stopPropagation();\n        }\n    }\n\n    /**\n     * Initialize JSON toggle functionality\n     * WHY: Ensures newly rendered events respect the current global JSON visibility state\n     */\n    initializeJsonToggle() {\n        // Make sure the moduleViewer is available globally for onclick handlers\n        window.moduleViewer = this;\n\n        // Apply global state to newly rendered JSON sections\n        // This ensures new events respect the current global state\n        if (this.globalJsonExpanded) {\n            // Small delay to ensure DOM is ready\n            setTimeout(() => {\n                this.updateAllJsonSections();\n            }, 0);\n        }\n\n        // Add keyboard navigation support (only add once to avoid duplicates)\n        if (!this.keyboardListenerAdded) {\n            this.keyboardListenerAdded = true;\n            document.addEventListener('keydown', (e) => {\n                if (e.target.classList.contains('json-toggle-header')) {\n                    if (e.key === 'Enter' || e.key === ' ') {\n                        this.toggleJsonSection();\n                        e.preventDefault();\n                    }\n                }\n            });\n        }\n    }\n\n    /**\n     * Toggle JSON section visibility globally - affects ALL events\n     * WHY: Sticky toggle maintains user preference across all events for better debugging\n     * DESIGN DECISION: Uses localStorage to persist preference across page refreshes\n     */\n    toggleJsonSection() {\n        // Toggle the global state\n        this.globalJsonExpanded = !this.globalJsonExpanded;\n        \n        // Persist the preference to localStorage\n        localStorage.setItem('dashboard-json-expanded', this.globalJsonExpanded.toString());\n        \n        // Update ALL JSON sections on the page\n        this.updateAllJsonSections();\n        \n        // Dispatch event to notify other components of the change\n        document.dispatchEvent(new CustomEvent('jsonToggleChanged', {\n            detail: { expanded: this.globalJsonExpanded }\n        }));\n    }\n\n    /**\n     * Update all JSON sections on the page to match global state\n     * WHY: Ensures consistent JSON visibility across all displayed events\n     */\n    updateAllJsonSections() {\n        // Find all JSON content sections and toggle headers\n        const allJsonContents = document.querySelectorAll('.json-content-collapsible');\n        const allArrows = document.querySelectorAll('.json-toggle-arrow');\n        const allHeaders = document.querySelectorAll('.json-toggle-header');\n        \n        // Update each JSON section\n        allJsonContents.forEach((jsonContent, index) => {\n            if (this.globalJsonExpanded) {\n                // Show JSON content\n                jsonContent.style.display = 'block';\n                jsonContent.setAttribute('aria-hidden', 'false');\n                if (allArrows[index]) {\n                    allArrows[index].textContent = '▲';\n                }\n                if (allHeaders[index]) {\n                    allHeaders[index].setAttribute('aria-expanded', 'true');\n                }\n            } else {\n                // Hide JSON content\n                jsonContent.style.display = 'none';\n                jsonContent.setAttribute('aria-hidden', 'true');\n                if (allArrows[index]) {\n                    allArrows[index].textContent = '▼';\n                }\n                if (allHeaders[index]) {\n                    allHeaders[index].setAttribute('aria-expanded', 'false');\n                }\n            }\n        });\n        \n        // If expanded and there's content, scroll the first visible one into view\n        if (this.globalJsonExpanded && allJsonContents.length > 0) {\n            setTimeout(() => {\n                const firstVisible = allJsonContents[0];\n                if (firstVisible) {\n                    firstVisible.scrollIntoView({ behavior: 'smooth', block: 'nearest' });\n                }\n            }, 100);\n        }\n    }\n\n    /**\n     * Create a property display element with optional file path detection\n     */\n    createProperty(key, value) {\n        const displayValue = this.truncateText(String(value), 300);\n\n        // Check if this is a file path property that should be clickable\n        if (this.isFilePathProperty(key, value)) {\n            return `\n                <div class=\"event-property\">\n                    <span class=\"event-property-key\">${key}:</span>\n                    <span class=\"event-property-value\">\n                        ${this.createClickableFilePath(value)}\n                    </span>\n                </div>\n            `;\n        }\n\n        return `\n            <div class=\"event-property\">\n                <span class=\"event-property-key\">${key}:</span>\n                <span class=\"event-property-value\">${displayValue}</span>\n            </div>\n        `;\n    }\n\n    /**\n     * Check if a property represents a file path that should be clickable\n     * @param {string} key - Property key\n     * @param {string} value - Property value\n     * @returns {boolean} True if this should be a clickable file path\n     */\n    isFilePathProperty(key, value) {\n        const filePathKeys = [\n            'File Path',\n            'file_path',\n            'notebook_path',\n            'Full Path',\n            'Working Directory',\n            'working_directory'\n        ];\n\n        // Check if key indicates a file path\n        if (filePathKeys.some(pathKey => key.toLowerCase().includes(pathKey.toLowerCase()))) {\n            // Ensure value looks like a file path (contains / or \\\\ and has reasonable length)\n            const strValue = String(value);\n            return strValue.length > 0 &&\n                   (strValue.includes('/') || strValue.includes('\\\\')) &&\n                   strValue.length < 500; // Reasonable path length limit\n        }\n\n        return false;\n    }\n\n    /**\n     * Create a clickable file path element\n     * @param {string} filePath - The file path to make clickable\n     * @returns {string} HTML for clickable file path\n     */\n    createClickableFilePath(filePath) {\n        const displayPath = this.truncateText(String(filePath), 300);\n        const escapedPath = filePath.replace(/'/g, \"\\\\'\");\n\n        return `\n            <span class=\"clickable-file-path\"\n                  onclick=\"showFileViewerModal('${escapedPath}')\"\n                  title=\"Click to view file contents with syntax highlighting&#10;Path: ${filePath}\">\n                ${displayPath}\n            </span>\n        `;\n    }\n\n    /**\n     * Get icon for event type\n     */\n    getEventIcon(eventType) {\n        const icons = {\n            session: '📱',\n            claude: '🤖',\n            agent: '🎯',\n            hook: '🔗',\n            todo: '✅',\n            memory: '🧠',\n            log: '📝',\n            connection: '🔌',\n            unknown: '❓'\n        };\n        return icons[eventType] || icons.unknown;\n    }\n\n    /**\n     * Get todo status icon\n     */\n    getTodoStatusIcon(status) {\n        const icons = {\n            completed: '✅',\n            'in_progress': '🔄',\n            pending: '⏳',\n            cancelled: '❌'\n        };\n        return icons[status] || icons.pending;\n    }\n\n    /**\n     * Get todo priority icon\n     */\n    getTodoPriorityIcon(priority) {\n        const icons = {\n            high: '🔴',\n            medium: '🟡',\n            low: '🟢'\n        };\n        return icons[priority] || icons.medium;\n    }\n\n    /**\n     * Get meaningful hook display name from event data\n     */\n    getHookDisplayName(event, data) {\n        // First check if there's a specific hook name in the data\n        if (data.hook_name) return data.hook_name;\n        if (data.name) return data.name;\n\n        // Use event.subtype or data.event_type to determine hook name\n        const eventType = event.subtype || data.event_type;\n\n        // Map hook event types to meaningful display names\n        const hookNames = {\n            'user_prompt': 'User Prompt',\n            'pre_tool': 'Tool Execution (Pre)',\n            'post_tool': 'Tool Execution (Post)',\n            'notification': 'Notification',\n            'stop': 'Session Stop',\n            'subagent_stop': 'Subagent Stop'\n        };\n\n        if (hookNames[eventType]) {\n            return hookNames[eventType];\n        }\n\n        // If it's a compound event type like \"hook.user_prompt\", extract the part after \"hook.\"\n        if (typeof event.type === 'string' && event.type.startsWith('hook.')) {\n            const hookType = event.type.replace('hook.', '');\n            if (hookNames[hookType]) {\n                return hookNames[hookType];\n            }\n        }\n\n        // Fallback to formatting the event type nicely\n        if (eventType) {\n            return eventType.split('_')\n                .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n                .join(' ');\n        }\n\n        return 'Unknown Hook';\n    }\n\n    /**\n     * Extract file path from hook event data\n     */\n    extractFilePathFromHook(data) {\n        // Check tool parameters for file path\n        if (data.tool_parameters && data.tool_parameters.file_path) {\n            return data.tool_parameters.file_path;\n        }\n\n        // Check direct file_path field\n        if (data.file_path) {\n            return data.file_path;\n        }\n\n        // Check nested in other common locations\n        if (data.tool_input && data.tool_input.file_path) {\n            return data.tool_input.file_path;\n        }\n\n        // Check for notebook path (alternative field name)\n        if (data.tool_parameters && data.tool_parameters.notebook_path) {\n            return data.tool_parameters.notebook_path;\n        }\n\n        return null;\n    }\n\n    /**\n     * Extract tool information from hook event data\n     */\n    extractToolInfoFromHook(data) {\n        return {\n            tool_name: data.tool_name || (data.tool_parameters && data.tool_parameters.tool_name),\n            operation_type: data.operation_type || (data.tool_parameters && data.tool_parameters.operation_type)\n        };\n    }\n\n    /**\n     * Truncate text to specified length\n     */\n    truncateText(text, maxLength) {\n        if (!text || text.length <= maxLength) return text;\n        return text.substring(0, maxLength) + '...';\n    }\n    \n    /**\n     * Format operation details object for display\n     * @param {Object} details - Details object containing operation information\n     * @returns {string} Formatted HTML string\n     */\n    formatOperationDetails(details) {\n        if (!details || typeof details !== 'object') {\n            return '';\n        }\n        \n        let formattedDetails = '';\n        \n        // Display the bash command if available\n        if (details.parameters && details.parameters.command) {\n            formattedDetails += `<br><strong>Command:</strong> <code>${this.escapeHtml(details.parameters.command)}</code>`;\n        }\n        \n        // Display success/error status\n        if (details.success !== undefined) {\n            formattedDetails += `<br><strong>Status:</strong> ${details.success ? '✅ Success' : '❌ Failed'}`;\n        }\n        \n        // Display exit code if available\n        if (details.exit_code !== undefined && details.exit_code !== null) {\n            formattedDetails += `<br><strong>Exit Code:</strong> ${details.exit_code}`;\n        }\n        \n        // Display duration if available\n        if (details.duration_ms !== undefined && details.duration_ms !== null) {\n            const duration = details.duration_ms > 1000 \n                ? `${(details.duration_ms / 1000).toFixed(2)}s` \n                : `${details.duration_ms}ms`;\n            formattedDetails += `<br><strong>Duration:</strong> ${duration}`;\n        }\n        \n        // Display error message if available\n        if (details.error) {\n            formattedDetails += `<br><strong>Error:</strong> ${this.escapeHtml(this.truncateText(details.error, 200))}`;\n        }\n        \n        return formattedDetails;\n    }\n    \n    /**\n     * Escape HTML to prevent XSS\n     */\n    escapeHtml(text) {\n        if (!text) return '';\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    /**\n     * Format JSON for display\n     */\n    formatJSON(obj) {\n        try {\n            return JSON.stringify(obj, null, 2);\n        } catch (e) {\n            return String(obj);\n        }\n    }\n\n    /**\n     * Format timestamp for display\n     * @param {string|number} timestamp - Timestamp to format\n     * @returns {string} Formatted time\n     */\n    formatTimestamp(timestamp) {\n        if (!timestamp) return 'Unknown time';\n\n        try {\n            const date = new Date(timestamp);\n            return date.toLocaleTimeString('en-US', {\n                hour: 'numeric',\n                minute: '2-digit',\n                second: '2-digit',\n                hour12: true\n            });\n        } catch (e) {\n            return 'Invalid time';\n        }\n    }\n\n    /**\n     * Escape HTML characters to prevent XSS\n     * @param {string} text - Text to escape\n     * @returns {string} Escaped text\n     */\n    escapeHtml(text) {\n        if (!text) return '';\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    /**\n     * Format field name for display (convert snake_case to Title Case)\n     * @param {string} fieldName - Field name to format\n     * @returns {string} Formatted field name\n     */\n    formatFieldName(fieldName) {\n        return fieldName\n            .split('_')\n            .map(word => word.charAt(0).toUpperCase() + word.slice(1))\n            .join(' ');\n    }\n\n    /**\n     * Extract tool name from event data\n     * @param {Object} data - Event data\n     * @returns {string|null} Tool name\n     */\n    extractToolName(data) {\n        // Check various locations where tool name might be stored\n        if (data.tool_name) return data.tool_name;\n        if (data.tool_parameters && data.tool_parameters.tool_name) return data.tool_parameters.tool_name;\n        if (data.tool_input && data.tool_input.tool_name) return data.tool_input.tool_name;\n\n        // Try to infer from other fields\n        if (data.tool_parameters) {\n            // Common tool patterns\n            if (data.tool_parameters.file_path || data.tool_parameters.notebook_path) {\n                return 'FileOperation';\n            }\n            if (data.tool_parameters.pattern) {\n                return 'Search';\n            }\n            if (data.tool_parameters.command) {\n                return 'Bash';\n            }\n            if (data.tool_parameters.todos) {\n                return 'TodoWrite';\n            }\n        }\n\n        return null;\n    }\n\n    /**\n     * Extract agent information from event data\n     * @param {Object} data - Event data\n     * @returns {string|null} Agent identifier\n     */\n    extractAgent(data) {\n        // First check if we have enhanced inference data from dashboard\n        if (data._agentName && data._agentName !== 'Unknown Agent') {\n            return data._agentName;\n        }\n\n        // Check inference data if available\n        if (data._inference && data._inference.agentName && data._inference.agentName !== 'Unknown') {\n            return data._inference.agentName;\n        }\n\n        // Check various locations where agent info might be stored\n        if (data.agent) return data.agent;\n        if (data.agent_type) return data.agent_type;\n        if (data.agent_name) return data.agent_name;\n\n        // Check session data\n        if (data.session_id && typeof data.session_id === 'string') {\n            // Extract agent from session ID if it contains agent info\n            const sessionParts = data.session_id.split('_');\n            if (sessionParts.length > 1) {\n                return sessionParts[0].toUpperCase();\n            }\n        }\n\n        // Infer from context\n        if (data.todos) return 'PM'; // TodoWrite typically from PM agent\n        if (data.tool_name === 'TodoWrite') return 'PM';\n\n        return null;\n    }\n\n    /**\n     * Extract file name from event data\n     * @param {Object} data - Event data\n     * @returns {string|null} File name\n     */\n    extractFileName(data) {\n        const filePath = this.extractFilePathFromHook(data);\n        if (filePath) {\n            // Extract just the filename from the full path\n            const pathParts = filePath.split('/');\n            return pathParts[pathParts.length - 1];\n        }\n\n        // Check other common file fields\n        if (data.filename) return data.filename;\n        if (data.file) return data.file;\n\n        return null;\n    }\n\n    /**\n     * Clear the module viewer\n     */\n    clear() {\n        if (this.unifiedViewer) {\n            this.unifiedViewer.clear();\n        }\n        this.showEmptyState();\n    }\n\n    /**\n     * Show tool call details (backward compatibility method)\n     * @param {Object} toolCall - The tool call data\n     * @param {string} toolCallKey - The tool call key\n     */\n    showToolCall(toolCall, toolCallKey) {\n        if (!toolCall) {\n            this.showEmptyState();\n            return;\n        }\n\n        const toolName = toolCall.tool_name || 'Unknown Tool';\n        const agentName = toolCall.agent_type || 'PM';\n        const timestamp = this.formatTimestamp(toolCall.timestamp);\n\n        // Extract information from pre and post events\n        const preEvent = toolCall.pre_event;\n        const postEvent = toolCall.post_event;\n\n        // Get parameters from pre-event\n        const parameters = preEvent?.tool_parameters || {};\n        const target = preEvent ? this.extractToolTarget(toolName, parameters) : 'Unknown target';\n\n        // Get execution results from post-event\n        const duration = toolCall.duration_ms ? `${toolCall.duration_ms}ms` : '-';\n        const success = toolCall.success !== undefined ? toolCall.success : null;\n        const exitCode = toolCall.exit_code !== undefined ? toolCall.exit_code : null;\n\n        // Format result summary\n        let resultSummary = toolCall.result_summary || 'No summary available';\n        let formattedResultSummary = '';\n\n        if (typeof resultSummary === 'object' && resultSummary !== null) {\n            const parts = [];\n            if (resultSummary.exit_code !== undefined) {\n                parts.push(`Exit Code: ${resultSummary.exit_code}`);\n            }\n            if (resultSummary.has_output !== undefined) {\n                parts.push(`Has Output: ${resultSummary.has_output ? 'Yes' : 'No'}`);\n            }\n            if (resultSummary.has_error !== undefined) {\n                parts.push(`Has Error: ${resultSummary.has_error ? 'Yes' : 'No'}`);\n            }\n            if (resultSummary.output_lines !== undefined) {\n                parts.push(`Output Lines: ${resultSummary.output_lines}`);\n            }\n            if (resultSummary.output_preview) {\n                parts.push(`Output Preview: ${resultSummary.output_preview}`);\n            }\n            if (resultSummary.error_preview) {\n                parts.push(`Error Preview: ${resultSummary.error_preview}`);\n            }\n            formattedResultSummary = parts.join('\\n');\n        } else {\n            formattedResultSummary = String(resultSummary);\n        }\n\n        // Status information\n        let statusIcon = '⏳';\n        let statusText = 'Running...';\n        let statusClass = 'tool-running';\n\n        if (postEvent) {\n            if (success === true) {\n                statusIcon = '✅';\n                statusText = 'Success';\n                statusClass = 'tool-success';\n            } else if (success === false) {\n                statusIcon = '❌';\n                statusText = 'Failed';\n                statusClass = 'tool-failure';\n            } else {\n                statusIcon = '⏳';\n                statusText = 'Completed';\n                statusClass = 'tool-completed';\n            }\n        }\n\n        // Create contextual header\n        const contextualHeader = `\n            <div class=\"contextual-header\">\n                <h3 class=\"contextual-header-text\">${toolName}: ${agentName} ${timestamp}</h3>\n            </div>\n        `;\n\n        // Special handling for TodoWrite\n        if (toolName === 'TodoWrite' && parameters.todos) {\n            const todoContent = `\n                <div class=\"todo-checklist\">\n                    ${parameters.todos.map(todo => {\n                        const statusIcon = this.getTodoStatusIcon(todo.status);\n                        const priorityIcon = this.getTodoPriorityIcon(todo.priority);\n\n                        return `\n                            <div class=\"todo-item todo-${todo.status || 'pending'}\">\n                                <span class=\"todo-status\">${statusIcon}</span>\n                                <span class=\"todo-content\">${todo.content || 'No content'}</span>\n                                <span class=\"todo-priority priority-${todo.priority || 'medium'}\">${priorityIcon}</span>\n                            </div>\n                        `;\n                    }).join('')}\n                </div>\n            `;\n\n            // Create collapsible JSON section\n            const toolCallData = {\n                toolCall: toolCall,\n                preEvent: preEvent,\n                postEvent: postEvent\n            };\n            const collapsibleJsonSection = this.createCollapsibleJsonSection(toolCallData);\n\n            if (this.dataContainer) {\n                this.dataContainer.innerHTML = contextualHeader + todoContent + collapsibleJsonSection;\n            }\n\n            // Initialize JSON toggle functionality\n            this.initializeJsonToggle();\n        } else if (toolName === 'Grep' || toolName === 'Search' || (parameters && parameters.pattern && !parameters.file_path)) {\n            // Special handling for search operations (Grep tool or any tool with pattern parameter)\n            const searchPattern = parameters.pattern || 'No pattern specified';\n            const searchPath = parameters.path || parameters.directory || '.';\n            const searchType = parameters.type || parameters.glob || 'all files';\n            \n            // Extract search results from result_summary\n            let searchResultsContent = '';\n            if (toolCall.result_summary) {\n                if (typeof toolCall.result_summary === 'string') {\n                    searchResultsContent = toolCall.result_summary;\n                } else if (toolCall.result_summary.output_preview) {\n                    searchResultsContent = toolCall.result_summary.output_preview;\n                } else {\n                    searchResultsContent = JSON.stringify(toolCall.result_summary, null, 2);\n                }\n            }\n\n            const content = `\n                <div class=\"structured-view-section\">\n                    <div class=\"tool-call-details\">\n                        <div class=\"tool-call-info ${statusClass}\">\n                            <div class=\"structured-field\">\n                                <strong>Tool Name:</strong> ${toolName}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Agent:</strong> ${agentName}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Status:</strong> ${statusIcon} ${statusText}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Search Pattern:</strong> <code>${searchPattern}</code>\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Search Path:</strong> ${searchPath}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>File Type:</strong> ${searchType}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Started:</strong> ${new Date(toolCall.timestamp).toLocaleString()}\n                            </div>\n                            ${duration && duration !== '-' ? `\n                                <div class=\"structured-field\">\n                                    <strong>Duration:</strong> ${duration}\n                                </div>\n                            ` : ''}\n                        </div>\n\n                        <div class=\"search-view-action\" style=\"margin-top: 20px;\">\n                            <button class=\"btn-view-search\" data-search-params='${JSON.stringify(parameters)}' data-search-results='${JSON.stringify(searchResultsContent).replace(/'/g, \"&#39;\")}' onclick=\"window.showSearchViewerModal(JSON.parse(this.getAttribute('data-search-params')), JSON.parse(this.getAttribute('data-search-results')))\">\n                                🔍 View Search Details\n                            </button>\n                        </div>\n\n                        ${this.createToolResultFromToolCall(toolCall)}\n                    </div>\n                </div>\n            `;\n\n            // Create collapsible JSON section\n            const toolCallData = {\n                toolCall: toolCall,\n                preEvent: preEvent,\n                postEvent: postEvent\n            };\n            const collapsibleJsonSection = this.createCollapsibleJsonSection(toolCallData);\n\n            if (this.dataContainer) {\n                this.dataContainer.innerHTML = contextualHeader + content + collapsibleJsonSection;\n            }\n\n            // Initialize JSON toggle functionality\n            this.initializeJsonToggle();\n        } else {\n            // For other tools, show detailed information\n            const content = `\n                <div class=\"structured-view-section\">\n                    <div class=\"tool-call-details\">\n                        <div class=\"tool-call-info ${statusClass}\">\n                            <div class=\"structured-field\">\n                                <strong>Tool Name:</strong> ${toolName}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Agent:</strong> ${agentName}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Status:</strong> ${statusIcon} ${statusText}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Target:</strong> ${target}\n                            </div>\n                            <div class=\"structured-field\">\n                                <strong>Started:</strong> ${new Date(toolCall.timestamp).toLocaleString()}\n                            </div>\n                            ${duration && duration !== '-' ? `\n                                <div class=\"structured-field\">\n                                    <strong>Duration:</strong> ${duration}\n                                </div>\n                            ` : ''}\n                            ${toolCall.session_id ? `\n                                <div class=\"structured-field\">\n                                    <strong>Session ID:</strong> ${toolCall.session_id}\n                                </div>\n                            ` : ''}\n                        </div>\n\n                        ${this.createToolResultFromToolCall(toolCall)}\n                    </div>\n                </div>\n            `;\n\n            // Create collapsible JSON section\n            const toolCallData = {\n                toolCall: toolCall,\n                preEvent: preEvent,\n                postEvent: postEvent\n            };\n            const collapsibleJsonSection = this.createCollapsibleJsonSection(toolCallData);\n\n            if (this.dataContainer) {\n                this.dataContainer.innerHTML = contextualHeader + content + collapsibleJsonSection;\n            }\n\n            // Initialize JSON toggle functionality\n            this.initializeJsonToggle();\n        }\n\n        // Hide JSON pane since data is integrated above\n        // JSON container no longer exists - handled via collapsible sections\n    }\n\n    /**\n     * Show file operations using UnifiedDataViewer for consistency\n     * @param {Object} fileData - The file operations data\n     * @param {string} filePath - The file path\n     */\n    showFileOperations(fileData, filePath) {\n        if (!fileData || !filePath) {\n            this.showEmptyState();\n            return;\n        }\n\n        // Initialize UnifiedDataViewer if not already available\n        if (!this.unifiedViewer) {\n            this.unifiedViewer = new UnifiedDataViewer('module-data-content');\n        }\n\n        // Convert file data to standardized format\n        const standardizedFileData = {\n            file_path: filePath,\n            operations: fileData.operations || [],\n            lastOperation: fileData.lastOperation,\n            ...fileData // Preserve any additional data\n        };\n\n        // Use UnifiedDataViewer for consistent display\n        this.unifiedViewer.display(standardizedFileData, 'file_operation');\n\n        // Update module header for consistency\n        const moduleHeader = document.querySelector('.module-data-header h5');\n        if (moduleHeader) {\n            const fileName = filePath.split('/').pop() || filePath;\n            moduleHeader.textContent = `📄 File: ${fileName}`;\n        }\n\n        // Check git tracking status and show track control if needed\n        this.checkAndShowTrackControl(filePath);\n    }\n\n    /**\n     * Show error message (backward compatibility method)\n     * @param {string} title - Error title\n     * @param {string} message - Error message\n     */\n    showErrorMessage(title, message) {\n        const content = `\n            <div class=\"module-error\">\n                <div class=\"error-header\">\n                    <h3>❌ ${title}</h3>\n                </div>\n                <div class=\"error-message\">\n                    <p>${message}</p>\n                </div>\n            </div>\n        `;\n\n        // Create collapsible JSON section for error data\n        const errorData = { title, message };\n        const collapsibleJsonSection = this.createCollapsibleJsonSection(errorData);\n\n        if (this.dataContainer) {\n            this.dataContainer.innerHTML = content + collapsibleJsonSection;\n        }\n\n        // Initialize JSON toggle functionality\n        this.initializeJsonToggle();\n\n        // JSON container no longer exists - handled via collapsible sections\n    }\n\n    /**\n     * Show agent event details (backward compatibility method)\n     * @param {Object} event - The agent event\n     * @param {number} index - Event index\n     */\n    showAgentEvent(event, index) {\n        // Show comprehensive agent-specific data instead of just single event\n        this.showAgentSpecificDetails(event, index);\n    }\n\n    /**\n     * Show comprehensive agent-specific details including prompt, todos, and tools\n     * @param {Object} event - The selected agent event\n     * @param {number} index - Event index\n     */\n    showAgentSpecificDetails(event, index) {\n        if (!event) {\n            this.showEmptyState();\n            return;\n        }\n\n        // Get agent inference to determine which agent this is\n        const agentInference = window.dashboard?.agentInference;\n        const eventViewer = window.dashboard?.eventViewer;\n\n        if (!agentInference || !eventViewer) {\n            console.warn('AgentInference or EventViewer not available, falling back to single event view');\n            this.showEventDetails(event);\n            return;\n        }\n\n        const inference = agentInference.getInferredAgentForEvent(event);\n        const agentName = inference?.agentName || this.extractAgent(event) || 'Unknown';\n\n        // Get all events from this agent\n        const allEvents = eventViewer.events || [];\n        const agentEvents = this.getAgentSpecificEvents(allEvents, agentName, agentInference);\n\n        console.log(`Showing details for agent: ${agentName}, found ${agentEvents.length} related events`);\n\n        // Extract agent-specific data\n        const agentData = this.extractAgentSpecificData(agentName, agentEvents);\n\n        // Render agent-specific view\n        this.renderAgentSpecificView(agentName, agentData, event);\n    }\n\n    /**\n     * Get all events related to a specific agent\n     * @param {Array} allEvents - All events\n     * @param {string} agentName - Name of the agent to filter for\n     * @param {Object} agentInference - Agent inference system\n     * @returns {Array} - Events related to this agent\n     */\n    getAgentSpecificEvents(allEvents, agentName, agentInference) {\n        return allEvents.filter(event => {\n            // Use agent inference to determine if this event belongs to the agent\n            const inference = agentInference.getInferredAgentForEvent(event);\n            const eventAgentName = inference?.agentName || this.extractAgent(event) || 'Unknown';\n\n            // Match agent names (case insensitive)\n            return eventAgentName.toLowerCase() === agentName.toLowerCase();\n        });\n    }\n\n    /**\n     * Extract agent-specific data from events\n     * @param {string} agentName - Name of the agent\n     * @param {Array} agentEvents - Events from this agent\n     * @returns {Object} - Extracted agent data\n     */\n    extractAgentSpecificData(agentName, agentEvents) {\n        const data = {\n            agentName: agentName,\n            totalEvents: agentEvents.length,\n            prompt: null,\n            todos: [],\n            toolsCalled: [],\n            sessions: new Set(),\n            firstSeen: null,\n            lastSeen: null,\n            eventTypes: new Set()\n        };\n\n        agentEvents.forEach(event => {\n            const eventData = event.data || {};\n            const timestamp = new Date(event.timestamp);\n\n            // Track timing\n            if (!data.firstSeen || timestamp < data.firstSeen) {\n                data.firstSeen = timestamp;\n            }\n            if (!data.lastSeen || timestamp > data.lastSeen) {\n                data.lastSeen = timestamp;\n            }\n\n            // Track sessions\n            if (event.session_id || eventData.session_id) {\n                data.sessions.add(event.session_id || eventData.session_id);\n            }\n\n            // Track event types\n            const eventType = event.hook_event_name || event.type || 'unknown';\n            data.eventTypes.add(eventType);\n\n            // Extract prompt from Task delegation events\n            if (event.type === 'hook' && eventData.tool_name === 'Task' && eventData.tool_parameters) {\n                const taskParams = eventData.tool_parameters;\n                if (taskParams.prompt && !data.prompt) {\n                    data.prompt = taskParams.prompt;\n                }\n                if (taskParams.description && !data.description) {\n                    data.description = taskParams.description;\n                }\n                if (taskParams.subagent_type === agentName && taskParams.prompt) {\n                    // Prefer prompts that match the specific agent\n                    data.prompt = taskParams.prompt;\n                }\n            }\n\n            // Also check for agent-specific prompts in other event types\n            if (eventData.prompt && (eventData.agent_type === agentName || eventData.subagent_type === agentName)) {\n                data.prompt = eventData.prompt;\n            }\n\n            // Extract todos from TodoWrite events\n            if (event.type === 'todo' || (event.type === 'hook' && eventData.tool_name === 'TodoWrite')) {\n                const todos = eventData.todos || eventData.tool_parameters?.todos;\n                if (todos && Array.isArray(todos)) {\n                    // Merge todos, keeping the most recent status for each\n                    todos.forEach(todo => {\n                        const existingIndex = data.todos.findIndex(t => t.id === todo.id || t.content === todo.content);\n                        if (existingIndex >= 0) {\n                            // Update existing todo with newer data\n                            data.todos[existingIndex] = { ...data.todos[existingIndex], ...todo, timestamp };\n                        } else {\n                            // Add new todo\n                            data.todos.push({ ...todo, timestamp });\n                        }\n                    });\n                }\n            }\n\n            // Extract tool calls - collect pre and post events separately first\n            if (event.type === 'hook' && eventData.tool_name) {\n                const phase = event.subtype || eventData.event_type;\n                const toolCallId = this.generateToolCallId(eventData.tool_name, eventData.tool_parameters, timestamp);\n\n                if (phase === 'pre_tool') {\n                    // Store pre-tool event data\n                    if (!data._preToolEvents) data._preToolEvents = new Map();\n                    data._preToolEvents.set(toolCallId, {\n                        toolName: eventData.tool_name,\n                        timestamp: timestamp,\n                        target: this.extractToolTarget(eventData.tool_name, eventData.tool_parameters, null),\n                        parameters: eventData.tool_parameters\n                    });\n                } else if (phase === 'post_tool') {\n                    // Store post-tool event data\n                    if (!data._postToolEvents) data._postToolEvents = new Map();\n                    data._postToolEvents.set(toolCallId, {\n                        toolName: eventData.tool_name,\n                        timestamp: timestamp,\n                        success: eventData.success,\n                        duration: eventData.duration_ms,\n                        resultSummary: eventData.result_summary,\n                        exitCode: eventData.exit_code\n                    });\n                }\n            }\n        });\n\n        // Sort todos by timestamp (most recent first)\n        data.todos.sort((a, b) => (b.timestamp || 0) - (a.timestamp || 0));\n\n        // Consolidate pre and post tool events into single tool calls\n        data.toolsCalled = this.consolidateToolCalls(data._preToolEvents, data._postToolEvents);\n\n        // Clean up temporary data\n        delete data._preToolEvents;\n        delete data._postToolEvents;\n\n        // Sort tools by timestamp (most recent first)\n        data.toolsCalled.sort((a, b) => b.timestamp - a.timestamp);\n\n        return data;\n    }\n\n    /**\n     * Generate a unique ID for a tool call to match pre and post events\n     * @param {string} toolName - Name of the tool\n     * @param {Object} parameters - Tool parameters\n     * @param {Date} timestamp - Timestamp of the event\n     * @returns {string} - Unique tool call ID\n     */\n    generateToolCallId(toolName, parameters, timestamp) {\n        // Create a unique identifier based on tool name, key parameters, and approximate timestamp\n        // Use a wider time window to account for timing differences between pre/post events\n        const timeWindow = Math.floor(timestamp.getTime() / 5000); // Group by 5-second windows\n\n        // Include key parameters that uniquely identify a tool call\n        let paramKey = '';\n        if (parameters) {\n            // Include important parameters that distinguish tool calls\n            const keyParams = [];\n            if (parameters.file_path) keyParams.push(parameters.file_path);\n            if (parameters.command) keyParams.push(parameters.command.substring(0, 50));\n            if (parameters.pattern) keyParams.push(parameters.pattern);\n            if (parameters.subagent_type) keyParams.push(parameters.subagent_type);\n            if (parameters.notebook_path) keyParams.push(parameters.notebook_path);\n            if (parameters.url) keyParams.push(parameters.url);\n            if (parameters.prompt) keyParams.push(parameters.prompt.substring(0, 30));\n\n            paramKey = keyParams.join('|');\n        }\n\n        // If no specific parameters, use just tool name and time window\n        if (!paramKey) {\n            paramKey = 'default';\n        }\n\n        return `${toolName}:${timeWindow}:${paramKey}`;\n    }\n\n    /**\n     * Consolidate pre and post tool events into single consolidated tool calls\n     * @param {Map} preToolEvents - Map of pre-tool events by tool call ID\n     * @param {Map} postToolEvents - Map of post-tool events by tool call ID\n     * @returns {Array} - Array of consolidated tool calls\n     */\n    consolidateToolCalls(preToolEvents, postToolEvents) {\n        const consolidatedCalls = [];\n        const processedIds = new Set();\n\n        if (!preToolEvents) preToolEvents = new Map();\n        if (!postToolEvents) postToolEvents = new Map();\n\n        // Process all pre-tool events first\n        for (const [toolCallId, preEvent] of preToolEvents) {\n            if (processedIds.has(toolCallId)) continue;\n\n            const postEvent = postToolEvents.get(toolCallId);\n\n            // Create consolidated tool call\n            const consolidatedCall = {\n                toolName: preEvent.toolName,\n                timestamp: preEvent.timestamp, // Use pre-tool timestamp as the start time\n                target: preEvent.target,\n                parameters: preEvent.parameters,\n                status: this.determineToolCallStatus(preEvent, postEvent),\n                statusIcon: this.getToolCallStatusIcon(preEvent, postEvent),\n                phase: postEvent ? 'completed' : 'running'\n            };\n\n            // Add post-event data if available\n            if (postEvent) {\n                consolidatedCall.success = postEvent.success;\n                consolidatedCall.duration = postEvent.duration;\n                consolidatedCall.resultSummary = postEvent.resultSummary;\n                consolidatedCall.exitCode = postEvent.exitCode;\n                consolidatedCall.completedAt = postEvent.timestamp;\n            }\n\n            consolidatedCalls.push(consolidatedCall);\n            processedIds.add(toolCallId);\n        }\n\n        // Process any post-tool events that don't have matching pre-tool events (edge case)\n        for (const [toolCallId, postEvent] of postToolEvents) {\n            if (processedIds.has(toolCallId)) continue;\n\n            // This is a post-tool event without a corresponding pre-tool event\n            const consolidatedCall = {\n                toolName: postEvent.toolName,\n                timestamp: postEvent.timestamp,\n                target: 'Unknown target', // We don't have pre-event data\n                parameters: null,\n                status: this.determineToolCallStatus(null, postEvent),\n                statusIcon: this.getToolCallStatusIcon(null, postEvent),\n                phase: 'completed',\n                success: postEvent.success,\n                duration: postEvent.duration,\n                resultSummary: postEvent.resultSummary,\n                exitCode: postEvent.exitCode,\n                completedAt: postEvent.timestamp\n            };\n\n            consolidatedCalls.push(consolidatedCall);\n            processedIds.add(toolCallId);\n        }\n\n        return consolidatedCalls;\n    }\n\n    /**\n     * Determine the status of a tool call based on pre and post events\n     * @param {Object} preEvent - Pre-tool event data\n     * @param {Object} postEvent - Post-tool event data\n     * @returns {string} - Status text\n     */\n    determineToolCallStatus(preEvent, postEvent) {\n        if (!postEvent) {\n            return 'Running...';\n        }\n\n        if (postEvent.success === true) {\n            return 'Success';\n        } else if (postEvent.success === false) {\n            return 'Failed';\n        } else if (postEvent.exitCode === 0) {\n            return 'Completed';\n        } else if (postEvent.exitCode === 2) {\n            return 'Blocked';\n        } else if (postEvent.exitCode !== undefined && postEvent.exitCode !== 0) {\n            return 'Error';\n        }\n\n        return 'Completed';\n    }\n\n    /**\n     * Get the status icon for a tool call\n     * @param {Object} preEvent - Pre-tool event data\n     * @param {Object} postEvent - Post-tool event data\n     * @returns {string} - Status icon\n     */\n    getToolCallStatusIcon(preEvent, postEvent) {\n        if (!postEvent) {\n            return '⏳'; // Still running\n        }\n\n        if (postEvent.success === true) {\n            return '✅'; // Success\n        } else if (postEvent.success === false) {\n            return '❌'; // Failed\n        } else if (postEvent.exitCode === 0) {\n            return '✅'; // Completed successfully\n        } else if (postEvent.exitCode === 2) {\n            return '⚠️'; // Blocked\n        } else if (postEvent.exitCode !== undefined && postEvent.exitCode !== 0) {\n            return '❌'; // Error\n        }\n\n        return '✅'; // Default to success for completed calls\n    }\n\n    /**\n     * Estimate token count for text using a simple approximation\n     * @param {string} text - Text to estimate tokens for\n     * @returns {number} - Estimated token count\n     */\n    estimateTokenCount(text) {\n        if (!text || typeof text !== 'string') return 0;\n\n        // Simple token estimation: words * 1.3 (accounts for subwords)\n        // Alternative: characters / 4 (common rule of thumb)\n        const wordCount = text.trim().split(/\\s+/).length;\n        const charBasedEstimate = Math.ceil(text.length / 4);\n\n        // Use the higher of the two estimates for safety\n        return Math.max(wordCount * 1.3, charBasedEstimate);\n    }\n\n    /**\n     * Trim excessive whitespace from text while preserving structure\n     * @param {string} text - Text to trim\n     * @returns {string} - Trimmed text\n     */\n    trimPromptWhitespace(text) {\n        if (!text || typeof text !== 'string') return '';\n\n        // Remove leading/trailing whitespace from the entire text\n        text = text.trim();\n\n        // Reduce multiple consecutive newlines to maximum of 2\n        text = text.replace(/\\n\\s*\\n\\s*\\n+/g, '\\n\\n');\n\n        // Trim whitespace from each line while preserving intentional indentation\n        text = text.split('\\n').map(line => {\n            // Only trim trailing whitespace, preserve leading whitespace for structure\n            return line.replace(/\\s+$/, '');\n        }).join('\\n');\n\n        return text;\n    }\n\n    /**\n     * Render agent-specific view with comprehensive data\n     * @param {string} agentName - Name of the agent\n     * @param {Object} agentData - Extracted agent data\n     * @param {Object} originalEvent - The original clicked event\n     */\n    renderAgentSpecificView(agentName, agentData, originalEvent) {\n        // Create contextual header\n        const timestamp = this.formatTimestamp(originalEvent.timestamp);\n        const contextualHeader = `\n            <div class=\"contextual-header\">\n                <h3 class=\"contextual-header-text\">🤖 ${agentName} Agent Details ${timestamp}</h3>\n            </div>\n        `;\n\n        // Build comprehensive agent view\n        let content = `\n            <div class=\"agent-overview-section\">\n                <div class=\"structured-data\">\n                    ${this.createProperty('Agent Name', agentName)}\n                    ${this.createProperty('Total Events', agentData.totalEvents)}\n                    ${this.createProperty('Active Sessions', agentData.sessions.size)}\n                    ${this.createProperty('Event Types', Array.from(agentData.eventTypes).join(', '))}\n                    ${agentData.firstSeen ? this.createProperty('First Seen', agentData.firstSeen.toLocaleString()) : ''}\n                    ${agentData.lastSeen ? this.createProperty('Last Seen', agentData.lastSeen.toLocaleString()) : ''}\n                </div>\n            </div>\n        `;\n\n        // Add prompt section if available\n        if (agentData.prompt) {\n            const trimmedPrompt = this.trimPromptWhitespace(agentData.prompt);\n            const tokenCount = Math.round(this.estimateTokenCount(trimmedPrompt));\n            const wordCount = trimmedPrompt.trim().split(/\\s+/).length;\n\n            content += `\n                <div class=\"agent-prompt-section\">\n                    <div class=\"contextual-header\">\n                        <h3 class=\"contextual-header-text\">📝 Agent Task Prompt</h3>\n                        <div class=\"prompt-stats\" style=\"font-size: 11px; color: #64748b; margin-top: 4px;\">\n                            ~${tokenCount} tokens • ${wordCount} words • ${trimmedPrompt.length} characters\n                        </div>\n                    </div>\n                    <div class=\"structured-data\">\n                        <div class=\"agent-prompt\" style=\"white-space: pre-wrap; max-height: 300px; overflow-y: auto; padding: 10px; background: #f8fafc; border-radius: 6px; font-family: monospace; font-size: 12px; line-height: 1.4; border: 1px solid #e2e8f0;\">\n                            ${this.escapeHtml(trimmedPrompt)}\n                        </div>\n                    </div>\n                </div>\n            `;\n        }\n\n        // Add todos section if available\n        if (agentData.todos.length > 0) {\n            content += `\n                <div class=\"agent-todos-section\">\n                    <div class=\"contextual-header\">\n                        <h3 class=\"contextual-header-text\">✅ Agent Todo List (${agentData.todos.length} items)</h3>\n                    </div>\n                    <div class=\"todo-checklist\">\n                        ${agentData.todos.map(todo => `\n                            <div class=\"todo-item todo-${todo.status || 'pending'}\">\n                                <span class=\"todo-status\">${this.getTodoStatusIcon(todo.status)}</span>\n                                <span class=\"todo-content\">${todo.content || 'No content'}</span>\n                                <span class=\"todo-priority priority-${todo.priority || 'medium'}\">${this.getTodoPriorityIcon(todo.priority)}</span>\n                                ${todo.timestamp ? `<span class=\"todo-timestamp\">${new Date(todo.timestamp).toLocaleTimeString()}</span>` : ''}\n                            </div>\n                        `).join('')}\n                    </div>\n                </div>\n            `;\n        }\n\n        // Add tools section if available\n        if (agentData.toolsCalled.length > 0) {\n            content += `\n                <div class=\"agent-tools-section\">\n                    <div class=\"contextual-header\">\n                        <h3 class=\"contextual-header-text\">🔧 Tools Called by Agent (${agentData.toolsCalled.length} calls)</h3>\n                    </div>\n                    <div class=\"tools-list\">\n                        ${agentData.toolsCalled.map(tool => {\n                            // Determine CSS class for status\n                            let statusClass = '';\n                            if (tool.statusIcon === '✅') statusClass = 'status-success';\n                            else if (tool.statusIcon === '❌') statusClass = 'status-failed';\n                            else if (tool.statusIcon === '⚠️') statusClass = 'status-blocked';\n                            else if (tool.statusIcon === '⏳') statusClass = 'status-running';\n\n                            return `\n                                <div class=\"tool-call-item\">\n                                    <div class=\"tool-call-header\">\n                                        <div style=\"display: flex; align-items: center; gap: 12px; flex: 1;\">\n                                            <span class=\"tool-name\">🔧 ${tool.toolName}</span>\n                                            <span class=\"tool-agent\">${agentName}</span>\n                                            <span class=\"tool-status-indicator ${statusClass}\">${tool.statusIcon} ${tool.status}</span>\n                                        </div>\n                                        <span class=\"tool-timestamp\" style=\"margin-left: auto;\">${tool.timestamp.toLocaleTimeString()}</span>\n                                    </div>\n                                    <div class=\"tool-call-details\">\n                                        ${tool.target ? `<span class=\"tool-target\">Target: ${tool.target}</span>` : ''}\n                                        ${tool.duration ? `<span class=\"tool-duration\">Duration: ${tool.duration}ms</span>` : ''}\n                                        ${tool.completedAt && tool.completedAt !== tool.timestamp ? `<span class=\"tool-completed\">Completed: ${tool.completedAt.toLocaleTimeString()}</span>` : ''}\n                                    </div>\n                                </div>\n                            `;\n                        }).join('')}\n                    </div>\n                </div>\n            `;\n        }\n\n        // Create collapsible JSON section for agent data\n        const agentJsonData = {\n            agentName: agentName,\n            agentData: agentData,\n            originalEvent: originalEvent\n        };\n        const collapsibleJsonSection = this.createCollapsibleJsonSection(agentJsonData);\n\n        // Show structured data with JSON section in data pane\n        if (this.dataContainer) {\n            this.dataContainer.innerHTML = contextualHeader + content + collapsibleJsonSection;\n        }\n\n        // Initialize JSON toggle functionality\n        this.initializeJsonToggle();\n\n        // Hide JSON pane since data is integrated above\n        // JSON container no longer exists - handled via collapsible sections\n    }\n\n    /**\n     * Create tool result section for backward compatibility with showToolCall method\n     * @param {Object} toolCall - Tool call data\n     * @returns {string} HTML content for tool result section\n     */\n    createToolResultFromToolCall(toolCall) {\n        // Check if we have result data\n        if (!toolCall.result_summary) {\n            return '';\n        }\n\n        // Convert toolCall data to match the format expected by createInlineToolResultContent\n        const mockData = {\n            event_type: 'post_tool',\n            result_summary: toolCall.result_summary,\n            success: toolCall.success,\n            exit_code: toolCall.exit_code\n        };\n\n        // Create a mock event object with proper subtype\n        const mockEvent = {\n            subtype: 'post_tool'\n        };\n\n        // Get inline result content\n        const inlineContent = this.createInlineToolResultContent(mockData, mockEvent);\n\n        // If we have content, wrap it in a simple section\n        if (inlineContent.trim()) {\n            return `\n                <div class=\"tool-result-inline\">\n                    <div class=\"structured-data\">\n                        ${inlineContent}\n                    </div>\n                </div>\n            `;\n        }\n\n        return '';\n    }\n\n    /**\n     * Extract tool target from tool name and parameters\n     * @param {string} toolName - Name of the tool\n     * @param {Object} parameters - Tool parameters\n     * @param {Object} altParameters - Alternative parameters\n     * @returns {string} - Tool target description\n     */\n    extractToolTarget(toolName, parameters, altParameters) {\n        const params = parameters || altParameters || {};\n\n        switch (toolName?.toLowerCase()) {\n            case 'write':\n            case 'read':\n            case 'edit':\n            case 'multiedit':\n                return params.file_path || 'Unknown file';\n            case 'bash':\n                return params.command ? `${params.command.substring(0, 50)}${params.command.length > 50 ? '...' : ''}` : 'Unknown command';\n            case 'grep':\n                return params.pattern ? `Pattern: ${params.pattern}` : 'Unknown pattern';\n            case 'glob':\n                return params.pattern ? `Pattern: ${params.pattern}` : 'Unknown glob';\n            case 'todowrite':\n                return `${params.todos?.length || 0} todos`;\n            case 'task':\n                return params.subagent_type || params.agent_type || 'Subagent delegation';\n            default:\n                // Try to find a meaningful parameter\n                if (params.file_path) return params.file_path;\n                if (params.pattern) return `Pattern: ${params.pattern}`;\n                if (params.command) return `Command: ${params.command.substring(0, 30)}...`;\n                if (params.path) return params.path;\n                return 'Unknown target';\n        }\n    }\n\n\n    /**\n     * Get operation icon for file operations\n     * @param {string} operation - Operation type\n     * @returns {string} - Icon for the operation\n     */\n    getOperationIcon(operation) {\n        const icons = {\n            'read': '👁️',\n            'write': '✏️',\n            'edit': '📝',\n            'multiedit': '📝',\n            'create': '🆕',\n            'delete': '🗑️',\n            'move': '📦',\n            'copy': '📋'\n        };\n        return icons[operation?.toLowerCase()] || '📄';\n    }\n\n    /**\n     * Get current event\n     */\n    getCurrentEvent() {\n        return this.currentEvent;\n    }\n\n    /**\n     * Check git tracking status and show track control if needed\n     * @param {string} filePath - Path to the file to check\n     */\n    async checkAndShowTrackControl(filePath) {\n        if (!filePath) return;\n\n        try {\n            // Get the Socket.IO client\n            const socket = window.socket || window.dashboard?.socketClient?.socket;\n            if (!socket) {\n                console.warn('No socket connection available for git tracking check');\n                return;\n            }\n\n            // Get working directory from dashboard with proper fallback\n            let workingDir = window.dashboard?.currentWorkingDir;\n\n            // Don't use 'Unknown' as a working directory\n            if (!workingDir || workingDir === 'Unknown' || workingDir.trim() === '') {\n                // Try to get from footer element\n                const footerDir = document.getElementById('footer-working-dir');\n                if (footerDir?.textContent?.trim() && footerDir.textContent.trim() !== 'Unknown') {\n                    workingDir = footerDir.textContent.trim();\n                } else {\n                    // Final fallback to current directory\n                    workingDir = '.';\n                }\n                console.log('[MODULE-VIEWER-DEBUG] Working directory fallback used:', workingDir);\n            }\n\n            // Set up one-time listener for tracking status response\n            const responsePromise = new Promise((resolve, reject) => {\n                const responseHandler = (data) => {\n                    if (data.file_path === filePath) {\n                        socket.off('file_tracked_response', responseHandler);\n                        resolve(data);\n                    }\n                };\n\n                socket.on('file_tracked_response', responseHandler);\n\n                // Timeout after 5 seconds\n                setTimeout(() => {\n                    socket.off('file_tracked_response', responseHandler);\n                    reject(new Error('Request timeout'));\n                }, 5000);\n            });\n\n            // Send tracking status request\n            socket.emit('check_file_tracked', {\n                file_path: filePath,\n                working_dir: workingDir\n            });\n\n            // Wait for response\n            const result = await responsePromise;\n            this.displayTrackingStatus(filePath, result);\n\n        } catch (error) {\n            console.error('Error checking file tracking status:', error);\n            this.displayTrackingStatus(filePath, {\n                success: false,\n                error: error.message,\n                file_path: filePath\n            });\n        }\n    }\n\n    /**\n     * Display tracking status and show track control if needed\n     * @param {string} filePath - Path to the file\n     * @param {Object} result - Result from tracking status check\n     */\n    displayTrackingStatus(filePath, result) {\n        const statusElementId = `git-track-status-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}`;\n        const statusElement = document.getElementById(statusElementId);\n\n        if (!statusElement) return;\n\n        if (result.success && result.is_tracked === false) {\n            // File is not tracked - show track button\n            statusElement.innerHTML = `\n                <div class=\"untracked-file-notice\">\n                    <span class=\"untracked-icon\">⚠️</span>\n                    <span class=\"untracked-text\">This file is not tracked by git</span>\n                    <button class=\"track-file-button\"\n                            onclick=\"window.moduleViewer.trackFile('${filePath}')\"\n                            title=\"Add this file to git tracking\">\n                        <span class=\"git-icon\">📁</span> Track File\n                    </button>\n                </div>\n            `;\n        } else if (result.success && result.is_tracked === true) {\n            // File is tracked - show status\n            statusElement.innerHTML = `\n                <div class=\"tracked-file-notice\">\n                    <span class=\"tracked-icon\">✅</span>\n                    <span class=\"tracked-text\">This file is tracked by git</span>\n                </div>\n            `;\n        } else if (!result.success) {\n            // Error checking status\n            statusElement.innerHTML = `\n                <div class=\"tracking-error-notice\">\n                    <span class=\"error-icon\">❌</span>\n                    <span class=\"error-text\">Could not check git status: ${result.error || 'Unknown error'}</span>\n                </div>\n            `;\n        }\n    }\n\n    /**\n     * Track a file using git add\n     * @param {string} filePath - Path to the file to track\n     */\n    async trackFile(filePath) {\n        if (!filePath) return;\n\n        try {\n            // Get the Socket.IO client\n            const socket = window.socket || window.dashboard?.socketClient?.socket;\n            if (!socket) {\n                console.warn('No socket connection available for git add');\n                return;\n            }\n\n            // Get working directory from dashboard with proper fallback\n            let workingDir = window.dashboard?.currentWorkingDir;\n\n            // Don't use 'Unknown' as a working directory\n            if (!workingDir || workingDir === 'Unknown' || workingDir.trim() === '') {\n                // Try to get from footer element\n                const footerDir = document.getElementById('footer-working-dir');\n                if (footerDir?.textContent?.trim() && footerDir.textContent.trim() !== 'Unknown') {\n                    workingDir = footerDir.textContent.trim();\n                } else {\n                    // Final fallback to current directory\n                    workingDir = '.';\n                }\n                console.log('[MODULE-VIEWER-DEBUG] Working directory fallback used:', workingDir);\n            }\n\n            // Update button to show loading state\n            const statusElementId = `git-track-status-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}`;\n            const statusElement = document.getElementById(statusElementId);\n\n            if (statusElement) {\n                statusElement.innerHTML = `\n                    <div class=\"tracking-file-notice\">\n                        <span class=\"loading-icon\">⏳</span>\n                        <span class=\"loading-text\">Adding file to git tracking...</span>\n                    </div>\n                `;\n            }\n\n            // Set up one-time listener for git add response\n            const responsePromise = new Promise((resolve, reject) => {\n                const responseHandler = (data) => {\n                    if (data.file_path === filePath) {\n                        socket.off('git_add_response', responseHandler);\n                        resolve(data);\n                    }\n                };\n\n                socket.on('git_add_response', responseHandler);\n\n                // Timeout after 10 seconds\n                setTimeout(() => {\n                    socket.off('git_add_response', responseHandler);\n                    reject(new Error('Request timeout'));\n                }, 10000);\n            });\n\n            // Send git add request\n            socket.emit('git_add_file', {\n                file_path: filePath,\n                working_dir: workingDir\n            });\n\n            console.log('📁 Git add request sent:', {\n                filePath,\n                workingDir\n            });\n\n            // Wait for response\n            const result = await responsePromise;\n            console.log('📦 Git add result:', result);\n\n            // Update UI based on result\n            if (result.success) {\n                if (statusElement) {\n                    statusElement.innerHTML = `\n                        <div class=\"tracked-file-notice\">\n                            <span class=\"tracked-icon\">✅</span>\n                            <span class=\"tracked-text\">File successfully added to git tracking</span>\n                        </div>\n                    `;\n                }\n\n                // Show success notification\n                this.showNotification('File tracked successfully', 'success');\n            } else {\n                if (statusElement) {\n                    statusElement.innerHTML = `\n                        <div class=\"tracking-error-notice\">\n                            <span class=\"error-icon\">❌</span>\n                            <span class=\"error-text\">Failed to track file: ${result.error || 'Unknown error'}</span>\n                            <button class=\"track-file-button\"\n                                    onclick=\"window.moduleViewer.trackFile('${filePath}')\"\n                                    title=\"Try again\">\n                                <span class=\"git-icon\">📁</span> Retry\n                            </button>\n                        </div>\n                    `;\n                }\n\n                // Show error notification\n                this.showNotification(`Failed to track file: ${result.error}`, 'error');\n            }\n\n        } catch (error) {\n            console.error('❌ Failed to track file:', error);\n\n            // Update UI to show error\n            const statusElementId = `git-track-status-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}`;\n            const statusElement = document.getElementById(statusElementId);\n\n            if (statusElement) {\n                statusElement.innerHTML = `\n                    <div class=\"tracking-error-notice\">\n                        <span class=\"error-icon\">❌</span>\n                        <span class=\"error-text\">Error: ${error.message}</span>\n                        <button class=\"track-file-button\"\n                                onclick=\"window.moduleViewer.trackFile('${filePath}')\"\n                                title=\"Try again\">\n                            <span class=\"git-icon\">📁</span> Retry\n                        </button>\n                    </div>\n                `;\n            }\n\n            // Show error notification\n            this.showNotification(`Error tracking file: ${error.message}`, 'error');\n        }\n    }\n\n\n    /**\n     * Show notification to user\n     * @param {string} message - Message to show\n     * @param {string} type - Type of notification (success, error, info)\n     */\n    showNotification(message, type = 'info') {\n        // Create notification element\n        const notification = document.createElement('div');\n        notification.className = `notification notification-${type}`;\n        notification.innerHTML = `\n            <span class=\"notification-icon\">${type === 'success' ? '✅' : type === 'error' ? '❌' : 'ℹ️'}</span>\n            <span class=\"notification-message\">${message}</span>\n        `;\n\n        // Style the notification\n        notification.style.cssText = `\n            position: fixed;\n            top: 20px;\n            right: 20px;\n            background: ${type === 'success' ? '#d4edda' : type === 'error' ? '#f8d7da' : '#d1ecf1'};\n            color: ${type === 'success' ? '#155724' : type === 'error' ? '#721c24' : '#0c5460'};\n            border: 1px solid ${type === 'success' ? '#c3e6cb' : type === 'error' ? '#f5c6cb' : '#bee5eb'};\n            border-radius: 6px;\n            padding: 12px 16px;\n            font-size: 14px;\n            font-weight: 500;\n            z-index: 2000;\n            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);\n            display: flex;\n            align-items: center;\n            gap: 8px;\n            max-width: 400px;\n            animation: slideIn 0.3s ease-out;\n        `;\n\n        // Add animation styles\n        const style = document.createElement('style');\n        style.textContent = `\n            @keyframes slideIn {\n                from { transform: translateX(100%); opacity: 0; }\n                to { transform: translateX(0); opacity: 1; }\n            }\n            @keyframes slideOut {\n                from { transform: translateX(0); opacity: 1; }\n                to { transform: translateX(100%); opacity: 0; }\n            }\n        `;\n        document.head.appendChild(style);\n\n        // Add to page\n        document.body.appendChild(notification);\n\n        // Remove after 5 seconds\n        setTimeout(() => {\n            notification.style.animation = 'slideOut 0.3s ease-in';\n            setTimeout(() => {\n                if (notification.parentNode) {\n                    notification.parentNode.removeChild(notification);\n                }\n                if (style.parentNode) {\n                    style.parentNode.removeChild(style);\n                }\n            }, 300);\n        }, 5000);\n    }\n\n    /**\n     * Show agent instance details for PM delegations\n     * @param {Object} instance - Agent instance from PM delegation\n     */\n    showAgentInstance(instance) {\n        if (!instance) {\n            this.showEmptyState();\n            return;\n        }\n\n        // Create a synthetic event object to work with existing showAgentSpecificDetails method\n        const syntheticEvent = {\n            type: 'pm_delegation',\n            subtype: instance.agentName,\n            agent_type: instance.agentName,\n            timestamp: instance.timestamp,\n            session_id: instance.sessionId,\n            metadata: {\n                delegation_type: 'explicit',\n                event_count: instance.agentEvents.length,\n                pm_call: instance.pmCall || null,\n                agent_events: instance.agentEvents\n            }\n        };\n\n        console.log('Showing PM delegation details:', instance);\n        this.showAgentSpecificDetails(syntheticEvent, 0);\n    }\n\n    /**\n     * Show implied agent details for agents without explicit PM delegation\n     * @param {Object} impliedInstance - Implied agent instance\n     */\n    showImpliedAgent(impliedInstance) {\n        if (!impliedInstance) {\n            this.showEmptyState();\n            return;\n        }\n\n        // Create a synthetic event object to work with existing showAgentSpecificDetails method\n        const syntheticEvent = {\n            type: 'implied_delegation',\n            subtype: impliedInstance.agentName,\n            agent_type: impliedInstance.agentName,\n            timestamp: impliedInstance.timestamp,\n            session_id: impliedInstance.sessionId,\n            metadata: {\n                delegation_type: 'implied',\n                event_count: impliedInstance.eventCount,\n                pm_call: null,\n                note: 'No explicit PM call found - inferred from agent activity'\n            }\n        };\n\n        console.log('Showing implied agent details:', impliedInstance);\n        this.showAgentSpecificDetails(syntheticEvent, 0);\n    }\n}\n\n// Export for global use\n// ES6 Module export\nexport { ModuleViewer };\nexport default ModuleViewer;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.ModuleViewer = ModuleViewer;\n\n// Debug helper function for troubleshooting tool result display\nwindow.enableToolResultDebugging = function() {\n    window.DEBUG_TOOL_RESULTS = true;\n    console.log('🔧 Tool result debugging enabled. Click on tool events to see debug info.');\n};\n\nwindow.disableToolResultDebugging = function() {\n    window.DEBUG_TOOL_RESULTS = false;\n    console.log('🔧 Tool result debugging disabled.');\n};\n"],"names":["ModuleViewer","constructor","containerId","this","container","document","getElementById","dataContainer","jsonContainer","currentEvent","eventsByClass","Map","globalJsonExpanded","localStorage","getItem","keyboardListenerAdded","unifiedViewer","UnifiedDataViewer","init","setupContainers","setupEventHandlers","showEmptyState","console","error","addEventListener","e","showEventDetails","detail","event","updateEventsByClass","events","innerHTML","warn","renderStructuredData","renderJsonData","display","contextualHeader","createContextualHeader","structuredView","createEventStructuredView","collapsibleJsonSection","createCollapsibleJsonSection","initializeJsonToggle","ingest","eventData","Array","isArray","length","clear","forEach","eventClass","getEventClass","has","set","get","push","type","timestamp","formatTimestamp","data","headerText","toolName","extractToolName","agent","extractAgent","getHookDisplayName","agent_type","name","operation","subtype","fileName","extractFileName","eventCount","content","createEventDetailCard","createAgentStructuredView","tool_name","tool_parameters","subagent_type","createHookStructuredView","createTodoStructuredView","createMemoryStructuredView","createClaudeStructuredView","createSessionStructuredView","createGenericStructuredView","eventType","count","Date","toLocaleString","getEventIcon","createProperty","id","session_id","taskData","description","prompt","truncateText","working_directory","config","Object","keys","join","String","capabilities","result","filePath","extractFilePathFromHook","toolInfo","extractToolInfoFromHook","toolResultContent","createInlineToolResultContent","event_type","operation_type","duration_ms","resultSummary","result_summary","eventPhase","phase","isPostTool","includes","window","DEBUG_TOOL_RESULTS","log","hasResultSummary","eventSubtype","dataEventType","dataPhase","resultSummaryKeys","resultContent","has_output","output_preview","output_lines","has_error","error_preview","entries","filter","key","value","map","formatFieldName","createToolResultSection","statusIcon","statusClass","statusText","success","exit_code","escapeHtml","otherFields","trim","isWriteOperation","params","new_string","edits","edit_mode","toLowerCase","isReadOnlyOperation","opLower","todos","todo","status","getTodoStatusIcon","priority","getTodoPriorityIcon","namespace","metadata","message","response","tokens","model","git_branch","uniqueId","Math","random","toString","substr","jsonString","formatJSON","isExpanded","copyJsonToClipboard","rect","currentTarget","getBoundingClientRect","clickX","clientX","left","clickY","clientY","top","width","preElement","querySelector","navigator","clipboard","writeText","textContent","showNotification","err","stopPropagation","moduleViewer","setTimeout","updateAllJsonSections","target","classList","contains","toggleJsonSection","preventDefault","setItem","dispatchEvent","CustomEvent","expanded","allJsonContents","querySelectorAll","allArrows","allHeaders","jsonContent","index","style","setAttribute","firstVisible","scrollIntoView","behavior","block","displayValue","isFilePathProperty","createClickableFilePath","some","pathKey","strValue","displayPath","replace","icons","session","claude","hook","memory","connection","unknown","completed","in_progress","pending","cancelled","high","medium","low","hook_name","hookNames","user_prompt","pre_tool","post_tool","notification","stop","subagent_stop","startsWith","hookType","split","word","charAt","toUpperCase","slice","file_path","tool_input","notebook_path","text","maxLength","substring","formatOperationDetails","details","formattedDetails","parameters","command","toFixed","div","createElement","obj","JSON","stringify","toLocaleTimeString","hour","minute","second","hour12","fieldName","pattern","_agentName","_inference","agentName","agent_name","sessionParts","pathParts","filename","file","showToolCall","toolCall","toolCallKey","preEvent","pre_event","postEvent","post_event","extractToolTarget","duration","parts","todoContent","priorityIcon","toolCallData","searchPattern","searchPath","path","directory","searchType","glob","searchResultsContent","createToolResultFromToolCall","showFileOperations","fileData","standardizedFileData","operations","lastOperation","moduleHeader","pop","checkAndShowTrackControl","showErrorMessage","title","errorData","showAgentEvent","showAgentSpecificDetails","agentInference","dashboard","eventViewer","inference","getInferredAgentForEvent","allEvents","agentEvents","getAgentSpecificEvents","agentData","extractAgentSpecificData","renderAgentSpecificView","totalEvents","toolsCalled","sessions","Set","firstSeen","lastSeen","eventTypes","add","hook_event_name","taskParams","existingIndex","findIndex","t","toolCallId","generateToolCallId","_preToolEvents","_postToolEvents","exitCode","sort","a","b","consolidateToolCalls","timeWindow","floor","getTime","paramKey","keyParams","url","preToolEvents","postToolEvents","consolidatedCalls","processedIds","consolidatedCall","determineToolCallStatus","getToolCallStatusIcon","completedAt","estimateTokenCount","wordCount","charBasedEstimate","ceil","max","trimPromptWhitespace","line","originalEvent","size","from","trimmedPrompt","round","tool","agentJsonData","mockData","inlineContent","altParameters","getOperationIcon","read","write","edit","multiedit","create","delete","move","copy","getCurrentEvent","socket","socketClient","workingDir","currentWorkingDir","footerDir","responsePromise","Promise","resolve","reject","responseHandler","off","on","Error","emit","working_dir","displayTrackingStatus","statusElementId","statusElement","is_tracked","trackFile","className","cssText","head","appendChild","body","animation","parentNode","removeChild","showAgentInstance","instance","syntheticEvent","sessionId","delegation_type","event_count","pm_call","pmCall","agent_events","showImpliedAgent","impliedInstance","note","enableToolResultDebugging","disableToolResultDebugging"],"mappings":"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"}