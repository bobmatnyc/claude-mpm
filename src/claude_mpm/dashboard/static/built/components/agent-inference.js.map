{"version":3,"file":"agent-inference.js","sources":["../../js/components/agent-inference.js"],"sourcesContent":["/**\n * Agent Inference Module\n *\n * Handles agent inference and processing logic for determining whether events\n * originate from the main agent or subagents based on event patterns and context.\n *\n * WHY: Separated from main dashboard to isolate complex agent inference logic\n * that analyzes event patterns to determine agent context. This provides better\n * maintainability and testability for a critical feature.\n *\n * DESIGN DECISION: This module maintains its own state for inference tracking\n * but relies on the event viewer for source data, keeping clear separation of\n * concerns while enabling delegation context tracking across events.\n */\nclass AgentInference {\n    constructor(eventViewer) {\n        this.eventViewer = eventViewer;\n\n        // Agent inference state tracking\n        this.state = {\n            // Track current subagent delegation context\n            currentDelegation: null,\n            // Map of session_id -> agent context\n            sessionAgents: new Map(),\n            // Map of event indices -> inferred agent\n            eventAgentMap: new Map(),\n            // PM delegation tracking for unique instance views\n            pmDelegations: new Map(), // delegation_id -> delegation context\n            // Map of agent events to their PM delegation\n            agentToDelegation: new Map() // agent_name -> delegation_id\n        };\n\n        console.log('Agent inference system initialized');\n    }\n\n    /**\n     * Initialize the agent inference system\n     * Called when the dashboard initializes\n     */\n    initialize() {\n        this.state = {\n            currentDelegation: null,\n            sessionAgents: new Map(),\n            eventAgentMap: new Map(),\n            pmDelegations: new Map(),\n            agentToDelegation: new Map()\n        };\n    }\n\n    /**\n     * Infer agent context from event payload\n     * Based on production-ready detection from design document\n     * @param {Object} event - Event payload\n     * @returns {Object} - {type: 'main_agent'|'subagent', confidence: 'definitive'|'high'|'medium'|'default', agentName: string}\n     */\n    inferAgentFromEvent(event) {\n        // Handle both direct properties and nested data properties\n        const data = event.data || {};\n        const sessionId = event.session_id || data.session_id || 'unknown';\n        const eventType = event.hook_event_name || data.hook_event_name || event.type || '';\n        const subtype = event.subtype || data.subtype || '';\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Debug logging for first few events to understand structure\n        if (Math.random() < 0.1) {\n            console.log('Agent inference debug:', {\n                eventType,\n                toolName,\n                hasData: !!event.data,\n                dataKeys: Object.keys(data),\n                eventKeys: Object.keys(event),\n                agentType: event.agent_type || data.agent_type,\n                subagentType: event.subagent_type || data.subagent_type\n            });\n        }\n\n        // Direct event detection (highest confidence) - from design doc\n        if (eventType === 'SubagentStop' || subtype === 'subagent_stop') {\n            const agentName = this.extractAgentNameFromEvent(event);\n            // Log SubagentStop events for debugging\n            console.log('SubagentStop event detected:', {\n                agentName: agentName,\n                sessionId: sessionId,\n                eventType: eventType,\n                subtype: subtype,\n                rawAgentType: event.agent_type || data.agent_type\n            });\n            return {\n                type: 'subagent',\n                confidence: 'definitive',\n                agentName: agentName,\n                reason: 'SubagentStop event'\n            };\n        }\n\n        if (eventType === 'Stop' || subtype === 'stop') {\n            return {\n                type: 'main_agent',\n                confidence: 'definitive',\n                agentName: 'PM',\n                reason: 'Stop event'\n            };\n        }\n\n        // Tool-based detection (high confidence) - from design doc\n        if (toolName === 'Task') {\n            const agentName = this.extractSubagentTypeFromTask(event);\n            if (agentName) {\n                // Log Task delegations for debugging\n                console.log('Task delegation detected:', {\n                    agentName: agentName,\n                    sessionId: sessionId,\n                    eventType: eventType\n                });\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: agentName,\n                    reason: 'Task tool with subagent_type'\n                };\n            }\n        }\n\n        // Hook event pattern analysis (high confidence)\n        if (eventType === 'PreToolUse' && toolName === 'Task') {\n            const agentName = this.extractSubagentTypeFromTask(event);\n            if (agentName) {\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: agentName,\n                    reason: 'PreToolUse Task delegation'\n                };\n            }\n        }\n\n        // Session pattern analysis (medium confidence) - from design doc\n        if (sessionId) {\n            const sessionLower = sessionId.toLowerCase();\n            if (['subagent', 'task', 'agent-'].some(pattern => sessionLower.includes(pattern))) {\n                return {\n                    type: 'subagent',\n                    confidence: 'medium',\n                    agentName: 'Subagent',\n                    reason: 'Session ID pattern'\n                };\n            }\n        }\n\n        // Agent type field analysis - check multiple possible locations\n        const agentType = event.agent_type || data.agent_type || event.agent_id || data.agent_id;\n        const subagentType = event.subagent_type || data.subagent_type;\n\n        if (subagentType && subagentType !== 'unknown') {\n            return {\n                type: 'subagent',\n                confidence: 'high',\n                agentName: this.normalizeAgentName(subagentType),\n                reason: 'subagent_type field'\n            };\n        }\n\n        if (agentType && agentType !== 'unknown' && agentType !== 'main') {\n            return {\n                type: 'subagent',\n                confidence: 'medium',\n                agentName: this.normalizeAgentName(agentType),\n                reason: 'agent_type field'\n            };\n        }\n\n        // Check for delegation_details from hook handler\n        if (data.delegation_details?.agent_type) {\n            return {\n                type: 'subagent',\n                confidence: 'high',\n                agentName: this.normalizeAgentName(data.delegation_details.agent_type),\n                reason: 'delegation_details'\n            };\n        }\n\n        // Check if this looks like a Hook event from Socket.IO\n        if (event.type && event.type.startsWith('hook.')) {\n            // Extract the hook type\n            const hookType = event.type.replace('hook.', '');\n\n            // Handle SubagentStart events\n            if (hookType === 'subagent_start' || (data.hook_event_name === 'SubagentStart')) {\n                const rawAgentName = data.agent_type || data.agent_id || 'Subagent';\n                console.log('SubagentStart event from Socket.IO:', {\n                    agentName: rawAgentName,\n                    sessionId: sessionId,\n                    hookType: hookType\n                });\n                return {\n                    type: 'subagent',\n                    confidence: 'definitive',\n                    agentName: this.normalizeAgentName(rawAgentName),\n                    reason: 'Socket.IO hook SubagentStart'\n                };\n            }\n\n            // Handle SubagentStop events\n            if (hookType === 'subagent_stop' || (data.hook_event_name === 'SubagentStop')) {\n                const rawAgentName = data.agent_type || data.agent_id || 'Subagent';\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: this.normalizeAgentName(rawAgentName),\n                    reason: 'Socket.IO hook SubagentStop'\n                };\n            }\n        }\n\n        // Default to main agent (from design doc)\n        return {\n            type: 'main_agent',\n            confidence: 'default',\n            agentName: 'PM',\n            reason: 'default classification'\n        };\n    }\n\n    /**\n     * Normalize agent name from lowercase/underscore format to display format\n     * @param {string} agentName - Raw agent name (e.g., 'engineer', 'test_integration')\n     * @returns {string} - Normalized display name (e.g., 'Engineer Agent', 'Test Integration Agent')\n     */\n    normalizeAgentName(agentName) {\n        if (!agentName) return 'Unknown';\n\n        // Agent name mapping from raw format to display format\n        const agentNameMap = {\n            'engineer': 'Engineer Agent',\n            'research': 'Research Agent',\n            'qa': 'QA Agent',\n            'documentation': 'Documentation Agent',\n            'security': 'Security Agent',\n            'ops': 'Ops Agent',\n            'version_control': 'Version Control Agent',\n            'data_engineer': 'Data Engineer Agent',\n            'test_integration': 'Test Integration Agent',\n            'pm': 'PM Agent'\n        };\n\n        // Check if we have a direct mapping\n        const normalized = agentNameMap[agentName.toLowerCase()];\n        if (normalized) {\n            return normalized;\n        }\n\n        // If no direct mapping, apply basic formatting:\n        // Convert underscore to space, capitalize words, and add \"Agent\" if not present\n        let formatted = agentName\n            .replace(/_/g, ' ')\n            .split(' ')\n            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n            .join(' ');\n\n        // Add \"Agent\" suffix if not already present\n        if (!formatted.toLowerCase().includes('agent')) {\n            formatted += ' Agent';\n        }\n\n        return formatted;\n    }\n\n    /**\n     * Extract subagent type from Task tool parameters\n     * @param {Object} event - Event with Task tool\n     * @returns {string|null} - Subagent type or null\n     */\n    extractSubagentTypeFromTask(event) {\n        let rawAgentName = null;\n\n        // Check tool_parameters directly\n        if (event.tool_parameters?.subagent_type) {\n            rawAgentName = event.tool_parameters.subagent_type;\n        }\n        // Check nested in data.tool_parameters (hook events)\n        else if (event.data?.tool_parameters?.subagent_type) {\n            rawAgentName = event.data.tool_parameters.subagent_type;\n        }\n        // Check delegation_details (new structure)\n        else if (event.data?.delegation_details?.agent_type) {\n            rawAgentName = event.data.delegation_details.agent_type;\n        }\n        // Check tool_input fallback\n        else if (event.tool_input?.subagent_type) {\n            rawAgentName = event.tool_input.subagent_type;\n        }\n\n        // Normalize the agent name before returning\n        return rawAgentName ? this.normalizeAgentName(rawAgentName) : null;\n    }\n\n    /**\n     * Extract agent name from any event\n     * @param {Object} event - Event payload\n     * @returns {string} - Agent name\n     */\n    extractAgentNameFromEvent(event) {\n        // Priority order based on reliability from design doc\n        const data = event.data || {};\n\n        // 1. Task tool subagent_type (highest priority)\n        if (event.tool_name === 'Task' || data.tool_name === 'Task') {\n            const taskAgent = this.extractSubagentTypeFromTask(event);\n            if (taskAgent) return taskAgent;\n        }\n\n        // 2. Direct subagent_type field\n        if (event.subagent_type && event.subagent_type !== 'unknown') {\n            return this.normalizeAgentName(event.subagent_type);\n        }\n        if (data.subagent_type && data.subagent_type !== 'unknown') {\n            return this.normalizeAgentName(data.subagent_type);\n        }\n\n        // 2.5. Check delegation_details\n        if (data.delegation_details?.agent_type && data.delegation_details.agent_type !== 'unknown') {\n            return this.normalizeAgentName(data.delegation_details.agent_type);\n        }\n\n        // 3. Agent type fields (but not 'main' or 'unknown')\n        if (event.agent_type && !['main', 'unknown'].includes(event.agent_type)) {\n            return this.normalizeAgentName(event.agent_type);\n        }\n        if (data.agent_type && !['main', 'unknown'].includes(data.agent_type)) {\n            return this.normalizeAgentName(data.agent_type);\n        }\n\n        // 4. Agent ID field as fallback\n        if (event.agent_id && !['main', 'unknown'].includes(event.agent_id)) {\n            return this.normalizeAgentName(event.agent_id);\n        }\n        if (data.agent_id && !['main', 'unknown'].includes(data.agent_id)) {\n            return this.normalizeAgentName(data.agent_id);\n        }\n\n        // 5. Other fallbacks\n        if (event.agent && event.agent !== 'unknown') {\n            return this.normalizeAgentName(event.agent);\n        }\n\n        if (event.name && event.name !== 'unknown') {\n            return this.normalizeAgentName(event.name);\n        }\n\n        // Default fallback\n        return 'Unknown';\n    }\n\n    /**\n     * Process all events and build agent inference context\n     * This tracks delegation boundaries and agent context throughout the session\n     */\n    processAgentInference() {\n        const events = this.eventViewer.events;\n\n        // Reset inference state\n        this.state.currentDelegation = null;\n        this.state.sessionAgents.clear();\n        this.state.eventAgentMap.clear();\n        this.state.pmDelegations.clear();\n        this.state.agentToDelegation.clear();\n\n        console.log('Processing agent inference for', events.length, 'events');\n\n        // Early return if no events\n        if (!events || events.length === 0) {\n            console.log('No events to process for agent inference');\n            return;\n        }\n\n        // Process events chronologically to track delegation context\n        events.forEach((event, index) => {\n            let finalAgent; // Declare outside try-catch to ensure scope availability\n\n            try {\n                const inference = this.inferAgentFromEvent(event);\n                const sessionId = event.session_id || event.data?.session_id || 'default';\n\n                // Determine agent for this event based on context\n                finalAgent = inference;\n\n                // If we're in a delegation context and this event doesn't have high confidence agent info,\n                // inherit from delegation context\n                if (this.state.currentDelegation &&\n                    inference.confidence === 'default' &&\n                    sessionId === this.state.currentDelegation.sessionId) {\n                    finalAgent = {\n                        type: 'subagent',\n                        confidence: 'inherited',\n                        agentName: this.state.currentDelegation.agentName,\n                        reason: 'inherited from delegation context'\n                    };\n                }\n\n                // Track delegation boundaries and PM delegations\n                if (event.tool_name === 'Task' && inference.type === 'subagent') {\n                    // Start of subagent delegation - create PM delegation entry\n                    const delegationId = `pm_${sessionId}_${index}_${inference.agentName}`;\n                    const pmDelegation = {\n                        id: delegationId,\n                        agentName: inference.agentName,\n                        sessionId: sessionId,\n                        startIndex: index,\n                        endIndex: null,\n                        pmCall: event, // Store the PM call event\n                        timestamp: event.timestamp,\n                        agentEvents: [] // Collect all events from this agent\n                    };\n\n                    this.state.pmDelegations.set(delegationId, pmDelegation);\n                    this.state.agentToDelegation.set(inference.agentName, delegationId);\n\n                    this.state.currentDelegation = {\n                        agentName: inference.agentName,\n                        sessionId: sessionId,\n                        startIndex: index,\n                        endIndex: null,\n                        delegationId: delegationId\n                    };\n                    console.log('Delegation started:', this.state.currentDelegation);\n                } else if (inference.confidence === 'definitive' && inference.reason === 'SubagentStop event') {\n                    // End of subagent delegation\n                    if (this.state.currentDelegation) {\n                        this.state.currentDelegation.endIndex = index;\n\n                        // Update PM delegation end point\n                        const pmDelegation = this.state.pmDelegations.get(this.state.currentDelegation.delegationId);\n                        if (pmDelegation) {\n                            pmDelegation.endIndex = index;\n                        }\n\n                        console.log('Delegation ended:', this.state.currentDelegation);\n                        this.state.currentDelegation = null;\n                    }\n                }\n\n                // Track events within PM delegation context\n                if (this.state.currentDelegation && finalAgent.type === 'subagent') {\n                    const pmDelegation = this.state.pmDelegations.get(this.state.currentDelegation.delegationId);\n                    if (pmDelegation) {\n                        pmDelegation.agentEvents.push({\n                            eventIndex: index,\n                            event: event,\n                            inference: finalAgent\n                        });\n                    }\n                }\n\n                // Store the inference result\n                this.state.eventAgentMap.set(index, finalAgent);\n\n                // Update session agent tracking\n                this.state.sessionAgents.set(sessionId, finalAgent);\n\n                // Debug first few inferences\n                if (index < 5) {\n                    console.log(`Event ${index} agent inference:`, {\n                        event_type: event.type || event.hook_event_name,\n                        subtype: event.subtype,\n                        tool_name: event.tool_name,\n                        inference: finalAgent,\n                        hasData: !!event.data,\n                        agentType: event.agent_type || event.data?.agent_type\n                    });\n                }\n            } catch (error) {\n                console.error(`Error processing event ${index} for agent inference:`, error);\n\n                // Set a default finalAgent if not already set due to error\n                if (!finalAgent) {\n                    finalAgent = {\n                        type: 'main_agent',\n                        confidence: 'error',\n                        agentName: 'PM',\n                        reason: 'error during processing'\n                    };\n                }\n\n                // Store the default inference for this event\n                this.state.eventAgentMap.set(index, finalAgent);\n            }\n        });\n\n        console.log('Agent inference processing complete. Results:', {\n            total_events: events.length,\n            inferred_agents: this.state.eventAgentMap.size,\n            unique_sessions: this.state.sessionAgents.size,\n            pm_delegations: this.state.pmDelegations.size,\n            agent_to_delegation_mappings: this.state.agentToDelegation.size\n        });\n    }\n\n    /**\n     * Get inferred agent for a specific event\n     * @param {number} eventIndex - Index of event in events array\n     * @returns {Object|null} - Agent inference result or null\n     */\n    getInferredAgent(eventIndex) {\n        return this.state.eventAgentMap.get(eventIndex) || null;\n    }\n\n    /**\n     * Get inferred agent for an event object\n     * @param {Object} event - Event object\n     * @returns {Object|null} - Agent inference result or null\n     */\n    getInferredAgentForEvent(event) {\n        const events = this.eventViewer.events;\n\n        // Try to find by exact reference first\n        let eventIndex = events.indexOf(event);\n\n        // If exact match fails, try to find by timestamp or session_id + timestamp\n        if (eventIndex === -1 && event.timestamp) {\n            eventIndex = events.findIndex(e =>\n                e.timestamp === event.timestamp &&\n                e.session_id === event.session_id\n            );\n        }\n\n        // If we still can't find it, perform inline inference\n        if (eventIndex === -1) {\n            console.log('Agent inference: Could not find event in events array, performing inline inference');\n            return this.inferAgentFromEvent(event);\n        }\n\n        // Get cached inference or perform new inference\n        let inference = this.getInferredAgent(eventIndex);\n        if (!inference) {\n            inference = this.inferAgentFromEvent(event);\n            // Cache the result\n            this.state.eventAgentMap.set(eventIndex, inference);\n        }\n\n        return inference;\n    }\n\n    /**\n     * Get current delegation context\n     * @returns {Object|null} - Current delegation or null\n     */\n    getCurrentDelegation() {\n        return this.state.currentDelegation;\n    }\n\n    /**\n     * Get session agents map\n     * @returns {Map} - Map of session IDs to agent contexts\n     */\n    getSessionAgents() {\n        return this.state.sessionAgents;\n    }\n\n    /**\n     * Get event agent map\n     * @returns {Map} - Map of event indices to agent contexts\n     */\n    getEventAgentMap() {\n        return this.state.eventAgentMap;\n    }\n\n    /**\n     * Get PM delegations for unique instance views\n     * @returns {Map} - Map of delegation IDs to PM delegation contexts\n     */\n    getPMDelegations() {\n        return this.state.pmDelegations;\n    }\n\n    /**\n     * Get agent to delegation mapping\n     * @returns {Map} - Map of agent names to delegation IDs\n     */\n    getAgentToDelegationMap() {\n        return this.state.agentToDelegation;\n    }\n\n    /**\n     * Get unique agent instances (one per agent type, consolidating multiple delegations)\n     * This is used for the unique instance view in the agents tab\n     * @returns {Array} - Array of unique agent instances\n     */\n    getUniqueAgentInstances() {\n        const agentMap = new Map(); // agentName -> consolidated data\n\n        // Consolidate all PM delegations by agent name\n        for (const [delegationId, delegation] of this.state.pmDelegations) {\n            const agentName = delegation.agentName;\n\n            if (!agentMap.has(agentName)) {\n                // First delegation for this agent type\n                agentMap.set(agentName, {\n                    id: `consolidated_${agentName}`,\n                    type: 'consolidated_agent',\n                    agentName: agentName,\n                    delegations: [], // Array of all delegations\n                    pmCalls: [], // Array of all PM calls\n                    allEvents: [], // Combined events from all delegations\n                    firstTimestamp: delegation.timestamp,\n                    lastTimestamp: delegation.timestamp,\n                    totalEventCount: delegation.agentEvents.length,\n                    delegationCount: 1\n                });\n            }\n\n            // Add this delegation to the consolidated agent\n            const agent = agentMap.get(agentName);\n            agent.delegations.push({\n                id: delegationId,\n                pmCall: delegation.pmCall,\n                timestamp: delegation.timestamp,\n                eventCount: delegation.agentEvents.length,\n                startIndex: delegation.startIndex,\n                endIndex: delegation.endIndex,\n                events: delegation.agentEvents\n            });\n\n            if (delegation.pmCall) {\n                agent.pmCalls.push(delegation.pmCall);\n            }\n\n            // Merge events from all delegations\n            agent.allEvents = agent.allEvents.concat(delegation.agentEvents);\n\n            // Update consolidated metadata\n            if (new Date(delegation.timestamp) < new Date(agent.firstTimestamp)) {\n                agent.firstTimestamp = delegation.timestamp;\n            }\n            if (new Date(delegation.timestamp) > new Date(agent.lastTimestamp)) {\n                agent.lastTimestamp = delegation.timestamp;\n            }\n\n            agent.totalEventCount += delegation.agentEvents.length;\n            agent.delegationCount++;\n        }\n\n        // Handle agents that appear without explicit PM delegation (implied PM)\n        const events = this.eventViewer.events;\n        for (let index = 0; index < events.length; index++) {\n            const inference = this.getInferredAgent(index);\n            if (inference && inference.type === 'subagent' && !agentMap.has(inference.agentName)) {\n                // Create consolidated agent for implied delegation\n                agentMap.set(inference.agentName, {\n                    id: `consolidated_${inference.agentName}`,\n                    type: 'consolidated_agent',\n                    agentName: inference.agentName,\n                    delegations: [{\n                        id: `implied_pm_${inference.agentName}_${index}`,\n                        pmCall: null,\n                        timestamp: events[index].timestamp,\n                        eventCount: 1,\n                        startIndex: index,\n                        endIndex: null,\n                        events: [{\n                            eventIndex: index,\n                            event: events[index],\n                            inference: inference\n                        }]\n                    }],\n                    pmCalls: [],\n                    allEvents: [{\n                        eventIndex: index,\n                        event: events[index],\n                        inference: inference\n                    }],\n                    firstTimestamp: events[index].timestamp,\n                    lastTimestamp: events[index].timestamp,\n                    totalEventCount: 1,\n                    delegationCount: 1,\n                    isImplied: true\n                });\n            }\n        }\n\n        // Convert map to array and sort by first appearance (timestamp)\n        const uniqueInstances = Array.from(agentMap.values())\n            .sort((a, b) => new Date(a.firstTimestamp) - new Date(b.firstTimestamp));\n\n        console.log('Consolidated unique agents:', {\n            total_unique_agents: uniqueInstances.length,\n            agents: uniqueInstances.map(agent => ({\n                name: agent.agentName,\n                delegations: agent.delegationCount,\n                totalEvents: agent.totalEventCount\n            }))\n        });\n\n        return uniqueInstances;\n    }\n}\n\n// ES6 Module export\nexport { AgentInference };\nexport default AgentInference;\n"],"names":["AgentInference","constructor","eventViewer","this","state","currentDelegation","sessionAgents","Map","eventAgentMap","pmDelegations","agentToDelegation","console","log","initialize","inferAgentFromEvent","event","data","sessionId","session_id","eventType","hook_event_name","type","subtype","toolName","tool_name","Math","random","hasData","dataKeys","Object","keys","eventKeys","agentType","agent_type","subagentType","subagent_type","agentName","extractAgentNameFromEvent","rawAgentType","confidence","reason","extractSubagentTypeFromTask","sessionLower","toLowerCase","some","pattern","includes","agent_id","normalizeAgentName","delegation_details","startsWith","hookType","replace","rawAgentName","normalized","engineer","research","qa","documentation","security","ops","version_control","data_engineer","test_integration","pm","formatted","split","map","word","charAt","toUpperCase","slice","join","tool_parameters","tool_input","taskAgent","agent","name","processAgentInference","events","clear","length","forEach","index","finalAgent","inference","delegationId","pmDelegation","id","startIndex","endIndex","pmCall","timestamp","agentEvents","set","get","push","eventIndex","event_type","error","total_events","inferred_agents","size","unique_sessions","pm_delegations","agent_to_delegation_mappings","getInferredAgent","getInferredAgentForEvent","indexOf","findIndex","e","getCurrentDelegation","getSessionAgents","getEventAgentMap","getPMDelegations","getAgentToDelegationMap","getUniqueAgentInstances","agentMap","delegation","has","delegations","pmCalls","allEvents","firstTimestamp","lastTimestamp","totalEventCount","delegationCount","eventCount","concat","Date","isImplied","uniqueInstances","Array","from","values","sort","a","b","total_unique_agents","agents","totalEvents"],"mappings":"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"}