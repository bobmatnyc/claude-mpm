{"version":3,"file":"agent-inference.js","sources":["../../js/components/agent-inference.js"],"sourcesContent":["/**\n * Agent Inference Module\n *\n * Handles agent inference and processing logic for determining whether events\n * originate from the main agent or subagents based on event patterns and context.\n *\n * WHY: Separated from main dashboard to isolate complex agent inference logic\n * that analyzes event patterns to determine agent context. This provides better\n * maintainability and testability for a critical feature.\n *\n * DESIGN DECISION: This module maintains its own state for inference tracking\n * but relies on the event viewer for source data, keeping clear separation of\n * concerns while enabling delegation context tracking across events.\n */\nclass AgentInference {\n    constructor(eventViewer) {\n        this.eventViewer = eventViewer;\n\n        // Agent inference state tracking\n        this.state = {\n            // Track current subagent delegation context\n            currentDelegation: null,\n            // Map of session_id -> agent context\n            sessionAgents: new Map(),\n            // Map of event indices -> inferred agent\n            eventAgentMap: new Map(),\n            // PM delegation tracking for unique instance views\n            pmDelegations: new Map(), // delegation_id -> delegation context\n            // Map of agent events to their PM delegation\n            agentToDelegation: new Map(), // agent_name -> delegation_id\n            // Track orphan subagent events (SubagentStart without PM Task)\n            orphanSubagents: new Map(), // event_index -> orphan context\n            // Track SubagentStart events for orphan detection\n            subagentStartEvents: new Map() // agent_name -> array of start events\n        };\n\n        console.log('Agent inference system initialized');\n    }\n\n    /**\n     * Initialize the agent inference system\n     * Called when the dashboard initializes\n     */\n    initialize() {\n        this.state = {\n            currentDelegation: null,\n            sessionAgents: new Map(),\n            eventAgentMap: new Map(),\n            pmDelegations: new Map(),\n            agentToDelegation: new Map(),\n            orphanSubagents: new Map(),\n            subagentStartEvents: new Map()\n        };\n    }\n\n    /**\n     * Infer agent context from event payload\n     * Based on production-ready detection from design document\n     * @param {Object} event - Event payload\n     * @returns {Object} - {type: 'main_agent'|'subagent', confidence: 'definitive'|'high'|'medium'|'default', agentName: string}\n     */\n    inferAgentFromEvent(event) {\n        // Handle both direct properties and nested data properties\n        const data = event.data || {};\n        const sessionId = event.session_id || data.session_id || 'unknown';\n        const eventType = event.hook_event_name || data.hook_event_name || event.type || '';\n        const subtype = event.subtype || data.subtype || '';\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Debug logging for first few events to understand structure\n        if (Math.random() < 0.1) {\n            console.log('Agent inference debug:', {\n                eventType,\n                toolName,\n                hasData: !!event.data,\n                dataKeys: Object.keys(data),\n                eventKeys: Object.keys(event),\n                agentType: event.agent_type || data.agent_type,\n                subagentType: event.subagent_type || data.subagent_type\n            });\n        }\n\n        // Direct event detection (highest confidence) - from design doc\n        if (eventType === 'SubagentStop' || subtype === 'subagent_stop') {\n            const agentName = this.extractAgentNameFromEvent(event);\n            // Log SubagentStop events for debugging\n            console.log('SubagentStop event detected:', {\n                agentName: agentName,\n                sessionId: sessionId,\n                eventType: eventType,\n                subtype: subtype,\n                rawAgentType: event.agent_type || data.agent_type\n            });\n            return {\n                type: 'subagent',\n                confidence: 'definitive',\n                agentName: agentName,\n                reason: 'SubagentStop event'\n            };\n        }\n\n        if (eventType === 'Stop' || subtype === 'stop') {\n            return {\n                type: 'main_agent',\n                confidence: 'definitive',\n                agentName: 'PM',\n                reason: 'Stop event'\n            };\n        }\n\n        // Tool-based detection (high confidence) - from design doc\n        if (toolName === 'Task') {\n            const agentName = this.extractSubagentTypeFromTask(event);\n            if (agentName) {\n                // Log Task delegations for debugging\n                console.log('Task delegation detected:', {\n                    agentName: agentName,\n                    sessionId: sessionId,\n                    eventType: eventType\n                });\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: agentName,\n                    reason: 'Task tool with subagent_type'\n                };\n            }\n        }\n\n        // Hook event pattern analysis (high confidence)\n        if (eventType === 'PreToolUse' && toolName === 'Task') {\n            const agentName = this.extractSubagentTypeFromTask(event);\n            if (agentName) {\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: agentName,\n                    reason: 'PreToolUse Task delegation'\n                };\n            }\n        }\n\n        // Session pattern analysis (medium confidence) - from design doc\n        if (sessionId) {\n            const sessionLower = sessionId.toLowerCase();\n            if (['subagent', 'task', 'agent-'].some(pattern => sessionLower.includes(pattern))) {\n                return {\n                    type: 'subagent',\n                    confidence: 'medium',\n                    agentName: 'Subagent',\n                    reason: 'Session ID pattern'\n                };\n            }\n        }\n\n        // Agent type field analysis - check multiple possible locations\n        const agentType = event.agent_type || data.agent_type || event.agent_id || data.agent_id;\n        const subagentType = event.subagent_type || data.subagent_type;\n\n        if (subagentType && subagentType !== 'unknown') {\n            return {\n                type: 'subagent',\n                confidence: 'high',\n                agentName: this.normalizeAgentName(subagentType),\n                reason: 'subagent_type field'\n            };\n        }\n\n        if (agentType && agentType !== 'unknown' && agentType !== 'main') {\n            return {\n                type: 'subagent',\n                confidence: 'medium',\n                agentName: this.normalizeAgentName(agentType),\n                reason: 'agent_type field'\n            };\n        }\n\n        // Check for delegation_details from hook handler\n        if (data.delegation_details?.agent_type) {\n            return {\n                type: 'subagent',\n                confidence: 'high',\n                agentName: this.normalizeAgentName(data.delegation_details.agent_type),\n                reason: 'delegation_details'\n            };\n        }\n\n        // Check if this looks like a Hook event from Socket.IO\n        if (event.type && event.type.startsWith('hook.')) {\n            // Extract the hook type\n            const hookType = event.type.replace('hook.', '');\n\n            // Handle SubagentStart events\n            if (hookType === 'subagent_start' || (data.hook_event_name === 'SubagentStart')) {\n                const rawAgentName = data.agent_type || data.agent_id || 'Subagent';\n                console.log('SubagentStart event from Socket.IO:', {\n                    agentName: rawAgentName,\n                    sessionId: sessionId,\n                    hookType: hookType\n                });\n                return {\n                    type: 'subagent',\n                    confidence: 'definitive',\n                    agentName: this.normalizeAgentName(rawAgentName),\n                    reason: 'Socket.IO hook SubagentStart'\n                };\n            }\n\n            // Handle SubagentStop events\n            if (hookType === 'subagent_stop' || (data.hook_event_name === 'SubagentStop')) {\n                const rawAgentName = data.agent_type || data.agent_id || 'Subagent';\n                return {\n                    type: 'subagent',\n                    confidence: 'high',\n                    agentName: this.normalizeAgentName(rawAgentName),\n                    reason: 'Socket.IO hook SubagentStop'\n                };\n            }\n        }\n\n        // Default to main agent (from design doc)\n        return {\n            type: 'main_agent',\n            confidence: 'default',\n            agentName: 'PM',\n            reason: 'default classification'\n        };\n    }\n\n    /**\n     * Normalize agent name from lowercase/underscore format to display format\n     * @param {string} agentName - Raw agent name (e.g., 'engineer', 'test_integration')\n     * @returns {string} - Normalized display name (e.g., 'Engineer Agent', 'Test Integration Agent')\n     */\n    normalizeAgentName(agentName) {\n        if (!agentName) return 'Unknown';\n\n        // Agent name mapping from raw format to display format\n        const agentNameMap = {\n            'engineer': 'Engineer Agent',\n            'research': 'Research Agent',\n            'qa': 'QA Agent',\n            'documentation': 'Documentation Agent',\n            'security': 'Security Agent',\n            'ops': 'Ops Agent',\n            'version_control': 'Version Control Agent',\n            'data_engineer': 'Data Engineer Agent',\n            'test_integration': 'Test Integration Agent',\n            'pm': 'PM Agent'\n        };\n\n        // Check if we have a direct mapping\n        const normalized = agentNameMap[agentName.toLowerCase()];\n        if (normalized) {\n            return normalized;\n        }\n\n        // If no direct mapping, apply basic formatting:\n        // Convert underscore to space, capitalize words, and add \"Agent\" if not present\n        let formatted = agentName\n            .replace(/_/g, ' ')\n            .split(' ')\n            .map(word => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())\n            .join(' ');\n\n        // Add \"Agent\" suffix if not already present\n        if (!formatted.toLowerCase().includes('agent')) {\n            formatted += ' Agent';\n        }\n\n        return formatted;\n    }\n\n    /**\n     * Extract subagent type from Task tool parameters\n     * @param {Object} event - Event with Task tool\n     * @returns {string|null} - Subagent type or null\n     */\n    extractSubagentTypeFromTask(event) {\n        let rawAgentName = null;\n\n        // Check tool_parameters directly\n        if (event.tool_parameters?.subagent_type) {\n            rawAgentName = event.tool_parameters.subagent_type;\n        }\n        // Check nested in data.tool_parameters (hook events)\n        else if (event.data?.tool_parameters?.subagent_type) {\n            rawAgentName = event.data.tool_parameters.subagent_type;\n        }\n        // Check delegation_details (new structure)\n        else if (event.data?.delegation_details?.agent_type) {\n            rawAgentName = event.data.delegation_details.agent_type;\n        }\n        // Check tool_input fallback\n        else if (event.tool_input?.subagent_type) {\n            rawAgentName = event.tool_input.subagent_type;\n        }\n\n        // Normalize the agent name before returning\n        return rawAgentName ? this.normalizeAgentName(rawAgentName) : null;\n    }\n\n    /**\n     * Extract agent name from any event\n     * @param {Object} event - Event payload\n     * @returns {string} - Agent name\n     */\n    extractAgentNameFromEvent(event) {\n        // Priority order based on reliability from design doc\n        const data = event.data || {};\n\n        // 1. Task tool subagent_type (highest priority)\n        if (event.tool_name === 'Task' || data.tool_name === 'Task') {\n            const taskAgent = this.extractSubagentTypeFromTask(event);\n            if (taskAgent) return taskAgent;\n        }\n\n        // 2. Direct subagent_type field\n        if (event.subagent_type && event.subagent_type !== 'unknown') {\n            return this.normalizeAgentName(event.subagent_type);\n        }\n        if (data.subagent_type && data.subagent_type !== 'unknown') {\n            return this.normalizeAgentName(data.subagent_type);\n        }\n\n        // 2.5. Check delegation_details\n        if (data.delegation_details?.agent_type && data.delegation_details.agent_type !== 'unknown') {\n            return this.normalizeAgentName(data.delegation_details.agent_type);\n        }\n\n        // 3. Agent type fields (but not 'main' or 'unknown')\n        if (event.agent_type && !['main', 'unknown'].includes(event.agent_type)) {\n            return this.normalizeAgentName(event.agent_type);\n        }\n        if (data.agent_type && !['main', 'unknown'].includes(data.agent_type)) {\n            return this.normalizeAgentName(data.agent_type);\n        }\n\n        // 4. Agent ID field as fallback\n        if (event.agent_id && !['main', 'unknown'].includes(event.agent_id)) {\n            return this.normalizeAgentName(event.agent_id);\n        }\n        if (data.agent_id && !['main', 'unknown'].includes(data.agent_id)) {\n            return this.normalizeAgentName(data.agent_id);\n        }\n\n        // 5. Other fallbacks\n        if (event.agent && event.agent !== 'unknown') {\n            return this.normalizeAgentName(event.agent);\n        }\n\n        if (event.name && event.name !== 'unknown') {\n            return this.normalizeAgentName(event.name);\n        }\n\n        // Default fallback\n        return 'Unknown';\n    }\n\n    /**\n     * Process all events and build agent inference context\n     * This tracks delegation boundaries and agent context throughout the session\n     */\n    processAgentInference() {\n        const events = this.eventViewer.events;\n\n        // Reset inference state\n        this.state.currentDelegation = null;\n        this.state.sessionAgents.clear();\n        this.state.eventAgentMap.clear();\n        this.state.pmDelegations.clear();\n        this.state.agentToDelegation.clear();\n        this.state.orphanSubagents.clear();\n        this.state.subagentStartEvents.clear();\n\n        console.log('Processing agent inference for', events.length, 'events');\n\n        // Early return if no events\n        if (!events || events.length === 0) {\n            console.log('No events to process for agent inference');\n            return;\n        }\n\n        // Process events chronologically to track delegation context\n        events.forEach((event, index) => {\n            let finalAgent; // Declare outside try-catch to ensure scope availability\n\n            try {\n                const inference = this.inferAgentFromEvent(event);\n                const sessionId = event.session_id || event.data?.session_id || 'default';\n\n                // Determine agent for this event based on context\n                finalAgent = inference;\n\n                // If we're in a delegation context and this event doesn't have high confidence agent info,\n                // inherit from delegation context\n                if (this.state.currentDelegation &&\n                    inference.confidence === 'default' &&\n                    sessionId === this.state.currentDelegation.sessionId) {\n                    finalAgent = {\n                        type: 'subagent',\n                        confidence: 'inherited',\n                        agentName: this.state.currentDelegation.agentName,\n                        reason: 'inherited from delegation context'\n                    };\n                }\n\n                // Track SubagentStart events for orphan detection\n                const hookEventName = event.hook_event_name || event.data?.hook_event_name || '';\n                const isSubagentStart = hookEventName === 'SubagentStart' || \n                                       event.type === 'hook.subagent_start' ||\n                                       event.subtype === 'subagent_start';\n                \n                if (isSubagentStart && inference.type === 'subagent') {\n                    // Track this SubagentStart event\n                    if (!this.state.subagentStartEvents.has(inference.agentName)) {\n                        this.state.subagentStartEvents.set(inference.agentName, []);\n                    }\n                    this.state.subagentStartEvents.get(inference.agentName).push({\n                        eventIndex: index,\n                        event: event,\n                        timestamp: event.timestamp,\n                        sessionId: sessionId\n                    });\n                }\n\n                // Track delegation boundaries and PM delegations\n                if (event.tool_name === 'Task' && inference.type === 'subagent') {\n                    // Start of subagent delegation - create PM delegation entry\n                    const delegationId = `pm_${sessionId}_${index}_${inference.agentName}`;\n                    const pmDelegation = {\n                        id: delegationId,\n                        agentName: inference.agentName,\n                        sessionId: sessionId,\n                        startIndex: index,\n                        endIndex: null,\n                        pmCall: event, // Store the PM call event\n                        timestamp: event.timestamp,\n                        agentEvents: [] // Collect all events from this agent\n                    };\n\n                    this.state.pmDelegations.set(delegationId, pmDelegation);\n                    this.state.agentToDelegation.set(inference.agentName, delegationId);\n\n                    this.state.currentDelegation = {\n                        agentName: inference.agentName,\n                        sessionId: sessionId,\n                        startIndex: index,\n                        endIndex: null,\n                        delegationId: delegationId\n                    };\n                    console.log('Delegation started:', this.state.currentDelegation);\n                } else if (inference.confidence === 'definitive' && inference.reason === 'SubagentStop event') {\n                    // End of subagent delegation\n                    if (this.state.currentDelegation) {\n                        this.state.currentDelegation.endIndex = index;\n\n                        // Update PM delegation end point\n                        const pmDelegation = this.state.pmDelegations.get(this.state.currentDelegation.delegationId);\n                        if (pmDelegation) {\n                            pmDelegation.endIndex = index;\n                        }\n\n                        console.log('Delegation ended:', this.state.currentDelegation);\n                        this.state.currentDelegation = null;\n                    }\n                }\n\n                // Track events within PM delegation context\n                if (this.state.currentDelegation && finalAgent.type === 'subagent') {\n                    const pmDelegation = this.state.pmDelegations.get(this.state.currentDelegation.delegationId);\n                    if (pmDelegation) {\n                        pmDelegation.agentEvents.push({\n                            eventIndex: index,\n                            event: event,\n                            inference: finalAgent\n                        });\n                    }\n                }\n\n                // Store the inference result\n                this.state.eventAgentMap.set(index, finalAgent);\n\n                // Update session agent tracking\n                this.state.sessionAgents.set(sessionId, finalAgent);\n\n                // Debug first few inferences\n                if (index < 5) {\n                    console.log(`Event ${index} agent inference:`, {\n                        event_type: event.type || event.hook_event_name,\n                        subtype: event.subtype,\n                        tool_name: event.tool_name,\n                        inference: finalAgent,\n                        hasData: !!event.data,\n                        agentType: event.agent_type || event.data?.agent_type\n                    });\n                }\n            } catch (error) {\n                console.error(`Error processing event ${index} for agent inference:`, error);\n\n                // Set a default finalAgent if not already set due to error\n                if (!finalAgent) {\n                    finalAgent = {\n                        type: 'main_agent',\n                        confidence: 'error',\n                        agentName: 'PM',\n                        reason: 'error during processing'\n                    };\n                }\n\n                // Store the default inference for this event\n                this.state.eventAgentMap.set(index, finalAgent);\n            }\n        });\n\n        // Identify orphan subagents after all events are processed\n        this.identifyOrphanSubagents(events);\n\n        console.log('Agent inference processing complete. Results:', {\n            total_events: events.length,\n            inferred_agents: this.state.eventAgentMap.size,\n            unique_sessions: this.state.sessionAgents.size,\n            pm_delegations: this.state.pmDelegations.size,\n            agent_to_delegation_mappings: this.state.agentToDelegation.size,\n            orphan_subagents: this.state.orphanSubagents.size\n        });\n    }\n\n    /**\n     * Get inferred agent for a specific event\n     * @param {number} eventIndex - Index of event in events array\n     * @returns {Object|null} - Agent inference result or null\n     */\n    getInferredAgent(eventIndex) {\n        return this.state.eventAgentMap.get(eventIndex) || null;\n    }\n\n    /**\n     * Get inferred agent for an event object\n     * @param {Object} event - Event object\n     * @returns {Object|null} - Agent inference result or null\n     */\n    getInferredAgentForEvent(event) {\n        const events = this.eventViewer.events;\n\n        // Try to find by exact reference first\n        let eventIndex = events.indexOf(event);\n\n        // If exact match fails, try to find by timestamp or session_id + timestamp\n        if (eventIndex === -1 && event.timestamp) {\n            eventIndex = events.findIndex(e =>\n                e.timestamp === event.timestamp &&\n                e.session_id === event.session_id\n            );\n        }\n\n        // If we still can't find it, perform inline inference\n        if (eventIndex === -1) {\n            console.log('Agent inference: Could not find event in events array, performing inline inference');\n            return this.inferAgentFromEvent(event);\n        }\n\n        // Get cached inference or perform new inference\n        let inference = this.getInferredAgent(eventIndex);\n        if (!inference) {\n            inference = this.inferAgentFromEvent(event);\n            // Cache the result\n            this.state.eventAgentMap.set(eventIndex, inference);\n        }\n\n        return inference;\n    }\n\n    /**\n     * Get current delegation context\n     * @returns {Object|null} - Current delegation or null\n     */\n    getCurrentDelegation() {\n        return this.state.currentDelegation;\n    }\n\n    /**\n     * Get session agents map\n     * @returns {Map} - Map of session IDs to agent contexts\n     */\n    getSessionAgents() {\n        return this.state.sessionAgents;\n    }\n\n    /**\n     * Get event agent map\n     * @returns {Map} - Map of event indices to agent contexts\n     */\n    getEventAgentMap() {\n        return this.state.eventAgentMap;\n    }\n\n    /**\n     * Get PM delegations for unique instance views\n     * @returns {Map} - Map of delegation IDs to PM delegation contexts\n     */\n    getPMDelegations() {\n        return this.state.pmDelegations;\n    }\n\n    /**\n     * Get agent to delegation mapping\n     * @returns {Map} - Map of agent names to delegation IDs\n     */\n    getAgentToDelegationMap() {\n        return this.state.agentToDelegation;\n    }\n\n    /**\n     * Build hierarchical delegation tree structure\n     * @returns {Object} Tree structure with PM nodes and subagent children\n     */\n    buildDelegationHierarchy() {\n        // Get all PM delegations\n        const pmDelegations = this.getPMDelegations();\n        const events = this.eventViewer.events;\n        \n        // Build hierarchy tree\n        const hierarchy = {\n            mainPM: {\n                type: 'pm',\n                name: 'PM',\n                delegations: [],\n                ownEvents: [],\n                totalEvents: 0\n            },\n            impliedPM: {\n                type: 'pm_implied',\n                name: 'Implied PM',\n                delegations: [],\n                ownEvents: [],\n                totalEvents: 0\n            }\n        };\n        \n        // Process explicit PM delegations\n        for (const [delegationId, delegation] of pmDelegations) {\n            hierarchy.mainPM.delegations.push({\n                id: delegationId,\n                agentName: delegation.agentName,\n                taskContext: this.extractTaskContext(delegation.pmCall),\n                events: delegation.agentEvents,\n                startTime: delegation.timestamp,\n                endTime: delegation.endIndex ? events[delegation.endIndex]?.timestamp : null,\n                status: delegation.endIndex ? 'completed' : 'active'\n            });\n            hierarchy.mainPM.totalEvents += delegation.agentEvents.length;\n        }\n        \n        // Find PM's own events\n        events.forEach((event, index) => {\n            const inference = this.getInferredAgent(index);\n            if (inference && inference.type === 'main_agent') {\n                hierarchy.mainPM.ownEvents.push({\n                    eventIndex: index,\n                    event: event\n                });\n                hierarchy.mainPM.totalEvents++;\n            }\n        });\n        \n        // Find orphan subagent events\n        const orphanEvents = new Map();\n        events.forEach((event, index) => {\n            const inference = this.getInferredAgent(index);\n            if (inference && inference.type === 'subagent') {\n                // Check if this is part of any PM delegation\n                let isOrphan = true;\n                for (const [_, delegation] of pmDelegations) {\n                    if (delegation.agentEvents.some(e => e.eventIndex === index)) {\n                        isOrphan = false;\n                        break;\n                    }\n                }\n                \n                if (isOrphan) {\n                    const agentName = inference.agentName;\n                    if (!orphanEvents.has(agentName)) {\n                        orphanEvents.set(agentName, []);\n                    }\n                    orphanEvents.get(agentName).push({\n                        eventIndex: index,\n                        event: event,\n                        inference: inference\n                    });\n                }\n            }\n        });\n        \n        // Add orphan agents as implied PM delegations\n        for (const [agentName, agentEvents] of orphanEvents) {\n            hierarchy.impliedPM.delegations.push({\n                id: `implied_${agentName}`,\n                agentName: agentName,\n                taskContext: 'No explicit PM delegation',\n                events: agentEvents,\n                startTime: agentEvents[0].event.timestamp,\n                endTime: agentEvents[agentEvents.length - 1].event.timestamp,\n                status: 'completed'\n            });\n            hierarchy.impliedPM.totalEvents += agentEvents.length;\n        }\n        \n        return hierarchy;\n    }\n    \n    /**\n     * Extract task context from PM call\n     * @param {Object} pmCall - PM's Task tool call\n     * @returns {string} Task description\n     */\n    extractTaskContext(pmCall) {\n        if (!pmCall) return 'Unknown task';\n        \n        const params = pmCall.tool_parameters || pmCall.data?.tool_parameters || {};\n        return params.task || params.request || params.description || 'Task delegation';\n    }\n    \n    /**\n     * Identify orphan subagents (SubagentStart without PM Task delegation)\n     * @param {Array} events - All events to analyze\n     */\n    identifyOrphanSubagents(events) {\n        const ORPHAN_TIME_WINDOW = 5000; // 5 seconds to group orphans together\n        \n        // Check each SubagentStart event\n        for (const [agentName, startEvents] of this.state.subagentStartEvents) {\n            for (const startEvent of startEvents) {\n                const eventIndex = startEvent.eventIndex;\n                const timestamp = new Date(startEvent.timestamp).getTime();\n                \n                // Check if this SubagentStart has a corresponding PM Task delegation\n                let hasTaskDelegation = false;\n                \n                // Look for a Task tool call within a reasonable time window before this SubagentStart\n                for (let i = Math.max(0, eventIndex - 20); i < eventIndex; i++) {\n                    const prevEvent = events[i];\n                    if (!prevEvent) continue;\n                    \n                    const prevTimestamp = new Date(prevEvent.timestamp).getTime();\n                    const timeDiff = timestamp - prevTimestamp;\n                    \n                    // Check if this is a Task tool call within 10 seconds\n                    if (prevEvent.tool_name === 'Task' && timeDiff >= 0 && timeDiff < 10000) {\n                        const inference = this.state.eventAgentMap.get(i);\n                        if (inference && inference.agentName === agentName) {\n                            hasTaskDelegation = true;\n                            break;\n                        }\n                    }\n                }\n                \n                // If no Task delegation found, mark as orphan\n                if (!hasTaskDelegation) {\n                    this.state.orphanSubagents.set(eventIndex, {\n                        agentName: agentName,\n                        timestamp: startEvent.timestamp,\n                        sessionId: startEvent.sessionId,\n                        event: startEvent.event,\n                        groupingKey: null // Will be set by grouping logic\n                    });\n                }\n            }\n        }\n        \n        // Group orphan subagents by time proximity or session\n        this.groupOrphanSubagents(ORPHAN_TIME_WINDOW);\n    }\n    \n    /**\n     * Group orphan subagents that occur close together in time or same session\n     * @param {number} timeWindow - Time window in milliseconds for grouping\n     */\n    groupOrphanSubagents(timeWindow) {\n        const orphansList = Array.from(this.state.orphanSubagents.values())\n            .sort((a, b) => new Date(a.timestamp) - new Date(b.timestamp));\n        \n        let currentGroup = null;\n        let lastTimestamp = null;\n        \n        for (const orphan of orphansList) {\n            const timestamp = new Date(orphan.timestamp).getTime();\n            \n            // Check if this orphan should be in the same group\n            if (!currentGroup || \n                (lastTimestamp && timestamp - lastTimestamp > timeWindow)) {\n                // Start a new group\n                currentGroup = `implied_pm_${orphan.sessionId}_${timestamp}`;\n            }\n            \n            orphan.groupingKey = currentGroup;\n            lastTimestamp = timestamp;\n        }\n    }\n    \n    /**\n     * Check if a subagent event is an orphan (no PM Task delegation)\n     * @param {number} eventIndex - Index of the event\n     * @returns {boolean} True if the event is from an orphan subagent\n     */\n    isOrphanSubagent(eventIndex) {\n        return this.state.orphanSubagents.has(eventIndex);\n    }\n    \n    /**\n     * Get orphan subagent context for an event\n     * @param {number} eventIndex - Index of the event  \n     * @returns {Object|null} Orphan context or null\n     */\n    getOrphanContext(eventIndex) {\n        return this.state.orphanSubagents.get(eventIndex) || null;\n    }\n    \n    /**\n     * Get all orphan subagent groups\n     * @returns {Map} Map of groupingKey -> array of orphan contexts\n     */\n    getOrphanGroups() {\n        const groups = new Map();\n        \n        for (const orphan of this.state.orphanSubagents.values()) {\n            const key = orphan.groupingKey;\n            if (!groups.has(key)) {\n                groups.set(key, []);\n            }\n            groups.get(key).push(orphan);\n        }\n        \n        return groups;\n    }\n\n    /**\n     * Get unique agent instances (one per agent type, consolidating multiple delegations)\n     * This is used for the unique instance view in the agents tab\n     * @returns {Array} - Array of unique agent instances\n     */\n    getUniqueAgentInstances() {\n        const agentMap = new Map(); // agentName -> consolidated data\n\n        // Consolidate all PM delegations by agent name\n        for (const [delegationId, delegation] of this.state.pmDelegations) {\n            const agentName = delegation.agentName;\n\n            if (!agentMap.has(agentName)) {\n                // First delegation for this agent type\n                agentMap.set(agentName, {\n                    id: `consolidated_${agentName}`,\n                    type: 'consolidated_agent',\n                    agentName: agentName,\n                    delegations: [], // Array of all delegations\n                    pmCalls: [], // Array of all PM calls\n                    allEvents: [], // Combined events from all delegations\n                    firstTimestamp: delegation.timestamp,\n                    lastTimestamp: delegation.timestamp,\n                    totalEventCount: delegation.agentEvents.length,\n                    delegationCount: 1\n                });\n            }\n\n            // Add this delegation to the consolidated agent\n            const agent = agentMap.get(agentName);\n            agent.delegations.push({\n                id: delegationId,\n                pmCall: delegation.pmCall,\n                timestamp: delegation.timestamp,\n                eventCount: delegation.agentEvents.length,\n                startIndex: delegation.startIndex,\n                endIndex: delegation.endIndex,\n                events: delegation.agentEvents\n            });\n\n            if (delegation.pmCall) {\n                agent.pmCalls.push(delegation.pmCall);\n            }\n\n            // Merge events from all delegations\n            agent.allEvents = agent.allEvents.concat(delegation.agentEvents);\n\n            // Update consolidated metadata\n            if (new Date(delegation.timestamp) < new Date(agent.firstTimestamp)) {\n                agent.firstTimestamp = delegation.timestamp;\n            }\n            if (new Date(delegation.timestamp) > new Date(agent.lastTimestamp)) {\n                agent.lastTimestamp = delegation.timestamp;\n            }\n\n            agent.totalEventCount += delegation.agentEvents.length;\n            agent.delegationCount++;\n        }\n\n        // Handle agents that appear without explicit PM delegation (implied PM)\n        const events = this.eventViewer.events;\n        for (let index = 0; index < events.length; index++) {\n            const inference = this.getInferredAgent(index);\n            if (inference && inference.type === 'subagent' && !agentMap.has(inference.agentName)) {\n                // Create consolidated agent for implied delegation\n                agentMap.set(inference.agentName, {\n                    id: `consolidated_${inference.agentName}`,\n                    type: 'consolidated_agent',\n                    agentName: inference.agentName,\n                    delegations: [{\n                        id: `implied_pm_${inference.agentName}_${index}`,\n                        pmCall: null,\n                        timestamp: events[index].timestamp,\n                        eventCount: 1,\n                        startIndex: index,\n                        endIndex: null,\n                        events: [{\n                            eventIndex: index,\n                            event: events[index],\n                            inference: inference\n                        }]\n                    }],\n                    pmCalls: [],\n                    allEvents: [{\n                        eventIndex: index,\n                        event: events[index],\n                        inference: inference\n                    }],\n                    firstTimestamp: events[index].timestamp,\n                    lastTimestamp: events[index].timestamp,\n                    totalEventCount: 1,\n                    delegationCount: 1,\n                    isImplied: true\n                });\n            }\n        }\n\n        // Convert map to array and sort by first appearance (timestamp)\n        const uniqueInstances = Array.from(agentMap.values())\n            .sort((a, b) => new Date(a.firstTimestamp) - new Date(b.firstTimestamp));\n\n        console.log('Consolidated unique agents:', {\n            total_unique_agents: uniqueInstances.length,\n            agents: uniqueInstances.map(agent => ({\n                name: agent.agentName,\n                delegations: agent.delegationCount,\n                totalEvents: agent.totalEventCount\n            }))\n        });\n\n        return uniqueInstances;\n    }\n}\n\n// ES6 Module export\nexport { AgentInference };\nexport default AgentInference;\n\n// Make AgentInference globally available for dist/dashboard.js\nwindow.AgentInference = AgentInference;\n"],"names":["window","AgentInference","constructor","eventViewer","this","state","currentDelegation","sessionAgents","Map","eventAgentMap","pmDelegations","agentToDelegation","orphanSubagents","subagentStartEvents","console","log","initialize","inferAgentFromEvent","event","data","sessionId","session_id","eventType","hook_event_name","type","subtype","toolName","tool_name","Math","random","hasData","dataKeys","Object","keys","eventKeys","agentType","agent_type","subagentType","subagent_type","agentName","extractAgentNameFromEvent","rawAgentType","confidence","reason","extractSubagentTypeFromTask","sessionLower","toLowerCase","some","pattern","includes","agent_id","normalizeAgentName","delegation_details","startsWith","hookType","replace","rawAgentName","normalized","engineer","research","qa","documentation","security","ops","version_control","data_engineer","test_integration","pm","formatted","split","map","word","charAt","toUpperCase","slice","join","tool_parameters","tool_input","taskAgent","agent","name","processAgentInference","events","clear","length","forEach","index","finalAgent","inference","hookEventName","has","set","get","push","eventIndex","timestamp","delegationId","pmDelegation","id","startIndex","endIndex","pmCall","agentEvents","event_type","error","identifyOrphanSubagents","total_events","inferred_agents","size","unique_sessions","pm_delegations","agent_to_delegation_mappings","orphan_subagents","getInferredAgent","getInferredAgentForEvent","indexOf","findIndex","e","getCurrentDelegation","getSessionAgents","getEventAgentMap","getPMDelegations","getAgentToDelegationMap","buildDelegationHierarchy","hierarchy","mainPM","delegations","ownEvents","totalEvents","impliedPM","delegation","taskContext","extractTaskContext","startTime","endTime","status","orphanEvents","isOrphan","_","params","task","request","description","startEvents","startEvent","Date","getTime","hasTaskDelegation","i","max","prevEvent","timeDiff","groupingKey","groupOrphanSubagents","timeWindow","orphansList","Array","from","values","sort","a","b","currentGroup","lastTimestamp","orphan","isOrphanSubagent","getOrphanContext","getOrphanGroups","groups","key","getUniqueAgentInstances","agentMap","pmCalls","allEvents","firstTimestamp","totalEventCount","delegationCount","eventCount","concat","isImplied","uniqueInstances","total_unique_agents","agents"],"mappings":"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"}