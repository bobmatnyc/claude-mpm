{"version":3,"file":"event-viewer.js","sources":["../../js/components/event-viewer.js","../../js/components/event-processor.js"],"sourcesContent":["/**\n * Event Viewer Component\n * Handles event display, filtering, and selection\n */\n\nclass EventViewer {\n    constructor(containerId, socketClient) {\n        this.container = document.getElementById(containerId);\n        this.socketClient = socketClient;\n\n        // State\n        this.events = [];\n        this.filteredEvents = [];\n        this.selectedEventIndex = -1;\n        this.filteredEventElements = [];\n        this.autoScroll = true;\n\n        // Filters\n        this.searchFilter = '';\n        this.typeFilter = '';\n        this.sessionFilter = '';\n\n        // Event type tracking\n        this.eventTypeCount = {};\n        this.availableEventTypes = new Set();\n        this.errorCount = 0;\n        this.eventsThisMinute = 0;\n        this.lastMinute = new Date().getMinutes();\n\n        this.init();\n    }\n\n    /**\n     * Initialize the event viewer\n     */\n    init() {\n        this.setupEventHandlers();\n        this.setupKeyboardNavigation();\n\n        // Subscribe to socket events\n        this.socketClient.onEventUpdate((events, sessions) => {\n            console.log('EventViewer received event update:', events?.length || 0, 'events');\n            // Ensure we always have a valid events array\n            this.events = Array.isArray(events) ? events : [];\n            this.updateDisplay();\n        });\n    }\n\n    /**\n     * Setup event handlers for UI controls\n     */\n    setupEventHandlers() {\n        // Search input\n        const searchInput = document.getElementById('events-search-input');\n        if (searchInput) {\n            searchInput.addEventListener('input', (e) => {\n                this.searchFilter = e.target.value.toLowerCase();\n                this.applyFilters();\n            });\n        }\n\n        // Type filter\n        const typeFilter = document.getElementById('events-type-filter');\n        if (typeFilter) {\n            typeFilter.addEventListener('change', (e) => {\n                this.typeFilter = e.target.value;\n                this.applyFilters();\n            });\n        }\n    }\n\n    /**\n     * Setup keyboard navigation for events\n     * Note: This is now handled by the unified Dashboard navigation system\n     */\n    setupKeyboardNavigation() {\n        // Keyboard navigation is now handled by Dashboard.setupUnifiedKeyboardNavigation()\n        // This method is kept for backward compatibility but does nothing\n        console.log('EventViewer: Keyboard navigation handled by unified Dashboard system');\n    }\n\n    /**\n     * Handle arrow key navigation\n     * @param {number} direction - Direction: 1 for down, -1 for up\n     */\n    handleArrowNavigation(direction) {\n        if (this.filteredEventElements.length === 0) return;\n\n        // Calculate new index\n        let newIndex = this.selectedEventIndex + direction;\n\n        // Wrap around\n        if (newIndex >= this.filteredEventElements.length) {\n            newIndex = 0;\n        } else if (newIndex < 0) {\n            newIndex = this.filteredEventElements.length - 1;\n        }\n\n        this.showEventDetails(newIndex);\n    }\n\n    /**\n     * Apply filters to events\n     */\n    applyFilters() {\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized, using empty array');\n            this.events = [];\n        }\n\n        this.filteredEvents = this.events.filter(event => {\n            // Search filter\n            if (this.searchFilter) {\n                const searchableText = [\n                    event.type || '',\n                    event.subtype || '',\n                    JSON.stringify(event.data || {})\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(this.searchFilter)) {\n                    return false;\n                }\n            }\n\n            // Type filter - now handles full hook types (like \"hook.user_prompt\") and main types\n            if (this.typeFilter) {\n                // Use the same logic as formatEventType to get the full event type\n                const eventType = event.type && event.type.trim() !== '' ? event.type : '';\n                const fullEventType = event.subtype && eventType ? `${eventType}.${event.subtype}` : eventType;\n                if (fullEventType !== this.typeFilter) {\n                    return false;\n                }\n            }\n\n            // Session filter\n            if (this.sessionFilter && this.sessionFilter !== '') {\n                if (!event.data || event.data.session_id !== this.sessionFilter) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n\n        this.renderEvents();\n        this.updateMetrics();\n    }\n\n    /**\n     * Update available event types and populate dropdown\n     */\n    updateEventTypeDropdown() {\n        const dropdown = document.getElementById('events-type-filter');\n        if (!dropdown) return;\n\n        // Extract unique event types from current events\n        // Use the same logic as formatEventType to get full event type names\n        const eventTypes = new Set();\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateEventTypeDropdown');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            if (event.type && event.type.trim() !== '') {\n                // Combine type and subtype if subtype exists, otherwise just use type\n                const fullType = event.subtype ? `${event.type}.${event.subtype}` : event.type;\n                eventTypes.add(fullType);\n            }\n        });\n\n        // Check if event types have changed\n        const currentTypes = Array.from(eventTypes).sort();\n        const previousTypes = Array.from(this.availableEventTypes).sort();\n\n        if (JSON.stringify(currentTypes) === JSON.stringify(previousTypes)) {\n            return; // No change needed\n        }\n\n        // Update our tracking\n        this.availableEventTypes = eventTypes;\n\n        // Store the current selection\n        const currentSelection = dropdown.value;\n\n        // Clear existing options except \"All Events\"\n        dropdown.innerHTML = '<option value=\"\">All Events</option>';\n\n        // Add new options sorted alphabetically\n        const sortedTypes = Array.from(eventTypes).sort();\n        sortedTypes.forEach(type => {\n            const option = document.createElement('option');\n            option.value = type;\n            option.textContent = type;\n            dropdown.appendChild(option);\n        });\n\n        // Restore selection if it still exists\n        if (currentSelection && eventTypes.has(currentSelection)) {\n            dropdown.value = currentSelection;\n        } else if (currentSelection && !eventTypes.has(currentSelection)) {\n            // If the previously selected type no longer exists, clear the filter\n            dropdown.value = '';\n            this.typeFilter = '';\n        }\n    }\n\n    /**\n     * Update the display with current events\n     */\n    updateDisplay() {\n        console.log('EventViewer updating display with', this.events?.length || 0, 'events');\n        this.updateEventTypeDropdown();\n        this.applyFilters();\n    }\n\n    /**\n     * Render events in the UI\n     */\n    renderEvents() {\n        const eventsList = document.getElementById('events-list');\n        if (!eventsList) return;\n\n        if (this.filteredEvents.length === 0) {\n            eventsList.innerHTML = `\n                <div class=\"no-events\">\n                    ${this.events.length === 0 ?\n                        'Connect to Socket.IO server to see events...' :\n                        'No events match current filters...'}\n                </div>\n            `;\n            this.filteredEventElements = [];\n            return;\n        }\n\n        const html = this.filteredEvents.map((event, index) => {\n            const timestamp = new Date(event.timestamp).toLocaleTimeString();\n            const eventClass = event.type ? `event-${event.type}` : 'event-default';\n            const isSelected = index === this.selectedEventIndex;\n\n            // Get main content and timestamp separately\n            const mainContent = this.formatSingleRowEventContent(event);\n\n            // Check if this is an Edit/MultiEdit tool event and add diff viewer\n            const diffViewer = this.createInlineEditDiffViewer(event, index);\n\n            return `\n                <div class=\"event-item single-row ${eventClass} ${isSelected ? 'selected' : ''}\"\n                     onclick=\"eventViewer.showEventDetails(${index})\"\n                     data-index=\"${index}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${mainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                    ${diffViewer}\n                </div>\n            `;\n        }).join('');\n\n        eventsList.innerHTML = html;\n\n        // Update filtered elements reference\n        this.filteredEventElements = Array.from(eventsList.querySelectorAll('.event-item'));\n\n        // Update Dashboard navigation items if we're in the events tab\n        if (window.dashboard && window.dashboard.currentTab === 'events' &&\n            window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n            window.dashboard.tabNavigation.events.items = this.filteredEventElements;\n        }\n\n        // Auto-scroll to bottom if enabled\n        if (this.autoScroll && this.filteredEvents.length > 0) {\n            eventsList.scrollTop = eventsList.scrollHeight;\n        }\n    }\n\n    /**\n     * Format event type for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event type\n     */\n    formatEventType(event) {\n        // If we have type and subtype, use them\n        if (event.type && event.subtype) {\n            // Check if type and subtype are identical or subtype is 'generic' to prevent redundant display\n            if (event.type === event.subtype || event.subtype === 'generic') {\n                return event.type;\n            }\n            return `${event.type}.${event.subtype}`;\n        }\n        // If we have just type, use it\n        if (event.type) {\n            return event.type;\n        }\n        // If we have originalEventName (from transformation), use it as fallback\n        if (event.originalEventName) {\n            return event.originalEventName;\n        }\n        // Last resort fallback\n        return 'unknown';\n    }\n\n    /**\n     * Format event data for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event data\n     */\n    formatEventData(event) {\n        if (!event.data) return 'No data';\n\n        // Special formatting for different event types\n        switch (event.type) {\n            case 'session':\n                return this.formatSessionEvent(event);\n            case 'claude':\n                return this.formatClaudeEvent(event);\n            case 'agent':\n                return this.formatAgentEvent(event);\n            case 'hook':\n                return this.formatHookEvent(event);\n            case 'todo':\n                return this.formatTodoEvent(event);\n            case 'memory':\n                return this.formatMemoryEvent(event);\n            case 'log':\n                return this.formatLogEvent(event);\n            default:\n                return this.formatGenericEvent(event);\n        }\n    }\n\n    /**\n     * Format session event data\n     */\n    formatSessionEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'started') {\n            return `<strong>Session started:</strong> ${data.session_id || 'Unknown'}`;\n        } else if (event.subtype === 'ended') {\n            return `<strong>Session ended:</strong> ${data.session_id || 'Unknown'}`;\n        }\n        return `<strong>Session:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format Claude event data\n     */\n    formatClaudeEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'request') {\n            const prompt = data.prompt || data.message || '';\n            const truncated = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;\n            return `<strong>Request:</strong> ${truncated}`;\n        } else if (event.subtype === 'response') {\n            const response = data.response || data.content || '';\n            const truncated = response.length > 100 ? response.substring(0, 100) + '...' : response;\n            return `<strong>Response:</strong> ${truncated}`;\n        }\n        return `<strong>Claude:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format agent event data\n     */\n    formatAgentEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'loaded') {\n            return `<strong>Agent loaded:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        } else if (event.subtype === 'executed') {\n            return `<strong>Agent executed:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        }\n        return `<strong>Agent:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format hook event data\n     */\n    formatHookEvent(event) {\n        const data = event.data;\n        const eventType = data.event_type || event.subtype || 'unknown';\n\n        // Format based on specific hook event type\n        switch (eventType) {\n            case 'user_prompt':\n                const prompt = data.prompt_text || data.prompt_preview || '';\n                const truncated = prompt.length > 80 ? prompt.substring(0, 80) + '...' : prompt;\n                return `<strong>User Prompt:</strong> ${truncated || 'No prompt text'}`;\n\n            case 'pre_tool':\n                const toolName = data.tool_name || 'Unknown tool';\n                const operation = data.operation_type || 'operation';\n                return `<strong>Pre-Tool (${operation}):</strong> ${toolName}`;\n\n            case 'post_tool':\n                const postToolName = data.tool_name || 'Unknown tool';\n                const status = data.success ? 'success' : data.status || 'failed';\n                const duration = data.duration_ms ? ` (${data.duration_ms}ms)` : '';\n                return `<strong>Post-Tool (${status}):</strong> ${postToolName}${duration}`;\n\n            case 'notification':\n                const notifType = data.notification_type || 'notification';\n                const message = data.message_preview || data.message || 'No message';\n                return `<strong>Notification (${notifType}):</strong> ${message}`;\n\n            case 'stop':\n                const reason = data.reason || 'unknown';\n                const stopType = data.stop_type || 'normal';\n                return `<strong>Stop (${stopType}):</strong> ${reason}`;\n\n            case 'subagent_start':\n                // Try multiple locations for agent type\n                const startAgentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                const startPrompt = data.prompt || data.description || data.task || 'No description';\n                const startTruncated = startPrompt.length > 60 ? startPrompt.substring(0, 60) + '...' : startPrompt;\n                // Format with proper agent type display\n                const startAgentDisplay = this.formatAgentType(startAgentType);\n                return `<strong>Subagent Start (${startAgentDisplay}):</strong> ${startTruncated}`;\n\n            case 'subagent_stop':\n                // Try multiple locations for agent type\n                const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                const stopReason = data.reason || data.stop_reason || 'completed';\n                // Format with proper agent type display\n                const stopAgentDisplay = this.formatAgentType(agentType);\n                // Include task completion status if available\n                const isCompleted = data.structured_response?.task_completed;\n                const completionStatus = isCompleted !== undefined ? (isCompleted ? ' âœ“' : ' âœ—') : '';\n                return `<strong>Subagent Stop (${stopAgentDisplay})${completionStatus}:</strong> ${stopReason}`;\n\n            default:\n                // Fallback to original logic for unknown hook types\n                const hookName = data.hook_name || data.name || data.event_type || 'Unknown';\n                const phase = event.subtype || eventType;\n                return `<strong>Hook ${phase}:</strong> ${hookName}`;\n        }\n    }\n\n    /**\n     * Format todo event data\n     */\n    formatTodoEvent(event) {\n        const data = event.data;\n        if (data.todos && Array.isArray(data.todos)) {\n            const count = data.todos.length;\n            return `<strong>Todo updated:</strong> ${count} item${count !== 1 ? 's' : ''}`;\n        }\n        return `<strong>Todo:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format memory event data\n     */\n    formatMemoryEvent(event) {\n        const data = event.data;\n        const operation = data.operation || 'unknown';\n        return `<strong>Memory ${operation}:</strong> ${data.key || 'Unknown key'}`;\n    }\n\n    /**\n     * Format log event data\n     */\n    formatLogEvent(event) {\n        const data = event.data;\n        const level = data.level || 'info';\n        const message = data.message || '';\n        const truncated = message.length > 80 ? message.substring(0, 80) + '...' : message;\n        return `<strong>[${level.toUpperCase()}]</strong> ${truncated}`;\n    }\n\n    /**\n     * Format generic event data\n     */\n    formatGenericEvent(event) {\n        const data = event.data;\n        if (typeof data === 'string') {\n            return data.length > 100 ? data.substring(0, 100) + '...' : data;\n        }\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Format agent type for display with proper capitalization\n     * @param {string} agentType - The raw agent type string\n     * @returns {string} Formatted agent type for display\n     */\n    formatAgentType(agentType) {\n        // Handle common agent type patterns\n        const agentTypeMap = {\n            'research': 'Research',\n            'architect': 'Architect',\n            'engineer': 'Engineer',\n            'qa': 'QA',\n            'pm': 'PM',\n            'project_manager': 'PM',\n            'research_agent': 'Research',\n            'architect_agent': 'Architect',\n            'engineer_agent': 'Engineer',\n            'qa_agent': 'QA',\n            'unknown': 'Unknown'\n        };\n        \n        // Try to find a match in the map (case-insensitive)\n        const lowerType = (agentType || 'unknown').toLowerCase();\n        if (agentTypeMap[lowerType]) {\n            return agentTypeMap[lowerType];\n        }\n        \n        // If not in map, try to extract the agent name from patterns like \"Research Agent\" or \"research_agent\"\n        const match = agentType.match(/^(\\w+)(?:_agent|Agent)?$/i);\n        if (match && match[1]) {\n            // Capitalize first letter\n            return match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();\n        }\n        \n        // Fallback: just capitalize first letter of whatever we have\n        return agentType.charAt(0).toUpperCase() + agentType.slice(1);\n    }\n\n    /**\n     * Format event content for single-row display (without timestamp)\n     * Format: \"{type}.{subtype}\" followed by data details\n     * @param {Object} event - Event object\n     * @returns {string} Formatted single-row event content string\n     */\n    formatSingleRowEventContent(event) {\n        const eventType = this.formatEventType(event);\n        const data = event.data || {};\n        \n        // Include source if it's not the default 'system' source\n        const sourcePrefix = event.source && event.source !== 'system' ? `[${event.source}] ` : '';\n\n        // Extract meaningful details from the data package for different event types\n        let dataDetails = '';\n\n        switch (event.type) {\n            case 'hook':\n                // Hook events: show tool name and operation details\n                const toolName = event.tool_name || data.tool_name || 'Unknown';\n                const hookType = event.subtype || 'Unknown';\n                \n                // Format specific hook types\n                if (hookType === 'pre_tool' || hookType === 'post_tool') {\n                    const operation = data.operation_type || '';\n                    const status = hookType === 'post_tool' && data.success !== undefined \n                        ? (data.success ? 'âœ“' : 'âœ—') \n                        : '';\n                    dataDetails = `${toolName}${operation ? ` (${operation})` : ''}${status ? ` ${status}` : ''}`;\n                } else if (hookType === 'user_prompt') {\n                    const prompt = data.prompt_text || data.prompt_preview || '';\n                    const truncated = prompt.length > 60 ? prompt.substring(0, 60) + '...' : prompt;\n                    dataDetails = truncated || 'No prompt text';\n                } else if (hookType === 'subagent_start') {\n                    // Enhanced agent type detection\n                    const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                    const agentDisplay = this.formatAgentType(agentType);\n                    const prompt = data.prompt || data.description || data.task || '';\n                    const truncated = prompt.length > 40 ? prompt.substring(0, 40) + '...' : prompt;\n                    dataDetails = truncated ? `${agentDisplay} - ${truncated}` : agentDisplay;\n                } else if (hookType === 'subagent_stop') {\n                    // Enhanced agent type detection for subagent_stop\n                    const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                    const agentDisplay = this.formatAgentType(agentType);\n                    const reason = data.reason || data.stop_reason || 'completed';\n                    const isCompleted = data.structured_response?.task_completed;\n                    const status = isCompleted !== undefined ? (isCompleted ? 'âœ“' : 'âœ—') : '';\n                    dataDetails = `${agentDisplay}${status ? ' ' + status : ''} - ${reason}`;\n                } else if (hookType === 'stop') {\n                    const reason = data.reason || 'completed';\n                    const stopType = data.stop_type || 'normal';\n                    dataDetails = `${stopType} - ${reason}`;\n                } else {\n                    dataDetails = toolName;\n                }\n                break;\n\n            case 'agent':\n                // Agent events: show agent name and status\n                const agentName = event.subagent_type || data.subagent_type || 'PM';\n                const status = data.status || '';\n                dataDetails = `${agentName}${status ? ` - ${status}` : ''}`;\n                break;\n\n            case 'todo':\n                // Todo events: show item count and status changes\n                if (data.todos && Array.isArray(data.todos)) {\n                    const count = data.todos.length;\n                    const completed = data.todos.filter(t => t.status === 'completed').length;\n                    const inProgress = data.todos.filter(t => t.status === 'in_progress').length;\n                    dataDetails = `${count} items (${completed} completed, ${inProgress} in progress)`;\n                } else {\n                    dataDetails = 'Todo update';\n                }\n                break;\n\n            case 'memory':\n                // Memory events: show operation and key\n                const operation = data.operation || 'unknown';\n                const key = data.key || 'unknown';\n                const value = data.value ? ` = ${JSON.stringify(data.value).substring(0, 30)}...` : '';\n                dataDetails = `${operation}: ${key}${value}`;\n                break;\n\n            case 'session':\n                // Session events: show session ID\n                const sessionId = data.session_id || 'unknown';\n                dataDetails = `ID: ${sessionId}`;\n                break;\n\n            case 'claude':\n                // Claude events: show request/response preview\n                if (event.subtype === 'request') {\n                    const prompt = data.prompt || data.message || '';\n                    const truncated = prompt.length > 60 ? prompt.substring(0, 60) + '...' : prompt;\n                    dataDetails = truncated || 'Empty request';\n                } else if (event.subtype === 'response') {\n                    const response = data.response || data.content || '';\n                    const truncated = response.length > 60 ? response.substring(0, 60) + '...' : response;\n                    dataDetails = truncated || 'Empty response';\n                } else {\n                    dataDetails = data.message || 'Claude interaction';\n                }\n                break;\n\n            case 'log':\n                // Log events: show log level and message\n                const level = data.level || 'info';\n                const message = data.message || '';\n                const truncated = message.length > 60 ? message.substring(0, 60) + '...' : message;\n                dataDetails = `[${level.toUpperCase()}] ${truncated}`;\n                break;\n\n            case 'test':\n                // Test events: show test name or details\n                const testName = data.test_name || data.name || 'Test';\n                dataDetails = testName;\n                break;\n\n            default:\n                // Generic events: show any available data\n                if (typeof data === 'string') {\n                    dataDetails = data.length > 60 ? data.substring(0, 60) + '...' : data;\n                } else if (data.message) {\n                    dataDetails = data.message.length > 60 ? data.message.substring(0, 60) + '...' : data.message;\n                } else if (data.name) {\n                    dataDetails = data.name;\n                } else if (Object.keys(data).length > 0) {\n                    // Show first meaningful field from data\n                    const firstKey = Object.keys(data).find(k => !['timestamp', 'id'].includes(k));\n                    if (firstKey) {\n                        const value = data[firstKey];\n                        dataDetails = `${firstKey}: ${typeof value === 'object' ? JSON.stringify(value).substring(0, 40) + '...' : value}`;\n                    }\n                }\n                break;\n        }\n\n        // Return formatted string: \"[source] {type}.{subtype} - {data details}\"\n        // The eventType already contains the type.subtype format from formatEventType()\n        const fullType = `${sourcePrefix}${eventType}`;\n        return dataDetails ? `${fullType} - ${dataDetails}` : fullType;\n    }\n\n    /**\n     * Get display name for hook types\n     * @param {string} hookType - Hook subtype\n     * @param {Object} data - Event data\n     * @returns {string} Display name\n     */\n    getHookDisplayName(hookType, data) {\n        const hookNames = {\n            'pre_tool': 'Pre-Tool',\n            'post_tool': 'Post-Tool',\n            'user_prompt': 'User-Prompt',\n            'stop': 'Stop',\n            'subagent_start': 'Subagent-Start',\n            'subagent_stop': 'Subagent-Stop',\n            'notification': 'Notification'\n        };\n\n        // Handle non-string hookType safely\n        if (hookNames[hookType]) {\n            return hookNames[hookType];\n        }\n        \n        // Convert to string and handle null/undefined\n        const typeStr = String(hookType || 'unknown');\n        return typeStr.replace(/_/g, ' ');\n    }\n\n    /**\n     * Get event category for display\n     * @param {Object} event - Event object\n     * @returns {string} Category\n     */\n    getEventCategory(event) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Categorize based on tool type\n        if (['Read', 'Write', 'Edit', 'MultiEdit'].includes(toolName)) {\n            return 'file_operations';\n        } else if (['Bash', 'grep', 'Glob'].includes(toolName)) {\n            return 'system_operations';\n        } else if (toolName === 'TodoWrite') {\n            return 'task_management';\n        } else if (toolName === 'Task') {\n            return 'agent_delegation';\n        } else if (event.subtype === 'subagent_start' || event.subtype === 'subagent_stop') {\n            return 'agent_delegation';\n        } else if (event.subtype === 'stop') {\n            return 'session_control';\n        }\n\n        return 'general';\n    }\n\n    /**\n     * Show event details and update selection\n     * @param {number} index - Index of event to show\n     */\n    showEventDetails(index) {\n        // Defensive checks\n        if (!this.filteredEvents || !Array.isArray(this.filteredEvents)) {\n            console.warn('EventViewer: filteredEvents array is not initialized');\n            return;\n        }\n        if (index < 0 || index >= this.filteredEvents.length) return;\n\n        // Update selection\n        this.selectedEventIndex = index;\n\n        // Get the selected event\n        const event = this.filteredEvents[index];\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            // Update the dashboard's navigation state for events tab\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = index;\n            }\n            if (window.dashboard.selectCard) {\n                window.dashboard.selectCard('events', index, 'event', event);\n            }\n        }\n\n        // Update visual selection (this will be handled by Dashboard.updateCardSelectionUI())\n        this.filteredEventElements.forEach((el, i) => {\n            el.classList.toggle('selected', i === index);\n        });\n\n        // Notify other components about selection\n        document.dispatchEvent(new CustomEvent('eventSelected', {\n            detail: { event, index }\n        }));\n\n        // Scroll to selected event if not visible\n        const selectedElement = this.filteredEventElements[index];\n        if (selectedElement) {\n            selectedElement.scrollIntoView({\n                behavior: 'smooth',\n                block: 'nearest'\n            });\n        }\n    }\n\n    /**\n     * Clear event selection\n     */\n    clearSelection() {\n        this.selectedEventIndex = -1;\n        this.filteredEventElements.forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = -1;\n            }\n            if (window.dashboard.clearCardSelection) {\n                window.dashboard.clearCardSelection();\n            }\n        }\n\n        // Notify other components\n        document.dispatchEvent(new CustomEvent('eventSelectionCleared'));\n    }\n\n    /**\n     * Update metrics display\n     */\n    updateMetrics() {\n        // Update event type counts\n        this.eventTypeCount = {};\n        this.errorCount = 0;\n\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateMetrics');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            const type = event.type || 'unknown';\n            this.eventTypeCount[type] = (this.eventTypeCount[type] || 0) + 1;\n\n            if (event.type === 'log' &&\n                event.data &&\n                ['error', 'critical'].includes(event.data.level)) {\n                this.errorCount++;\n            }\n        });\n\n        // Update events per minute\n        const currentMinute = new Date().getMinutes();\n        if (currentMinute !== this.lastMinute) {\n            this.lastMinute = currentMinute;\n            this.eventsThisMinute = 0;\n        }\n\n        // Count events in the last minute\n        const oneMinuteAgo = new Date(Date.now() - 60000);\n        this.eventsThisMinute = this.events.filter(event =>\n            new Date(event.timestamp) > oneMinuteAgo\n        ).length;\n\n        // Update UI\n        this.updateMetricsUI();\n    }\n\n    /**\n     * Update metrics in the UI\n     */\n    updateMetricsUI() {\n        const totalEventsEl = document.getElementById('total-events');\n        const eventsPerMinuteEl = document.getElementById('events-per-minute');\n        const uniqueTypesEl = document.getElementById('unique-types');\n        const errorCountEl = document.getElementById('error-count');\n\n        if (totalEventsEl) totalEventsEl.textContent = this.events.length;\n        if (eventsPerMinuteEl) eventsPerMinuteEl.textContent = this.eventsThisMinute;\n        if (uniqueTypesEl) uniqueTypesEl.textContent = Object.keys(this.eventTypeCount).length;\n        if (errorCountEl) errorCountEl.textContent = this.errorCount;\n    }\n\n    /**\n     * Export events to JSON\n     */\n    exportEvents() {\n        const dataStr = JSON.stringify(this.filteredEvents, null, 2);\n        const dataBlob = new Blob([dataStr], { type: 'application/json' });\n        const url = URL.createObjectURL(dataBlob);\n\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = `claude-mpm-events-${new Date().toISOString().split('T')[0]}.json`;\n        link.click();\n\n        URL.revokeObjectURL(url);\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.socketClient.clearEvents();\n        this.selectedEventIndex = -1;\n        this.updateDisplay();\n    }\n\n    /**\n     * Set session filter\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSessionFilter(sessionId) {\n        this.sessionFilter = sessionId;\n        this.applyFilters();\n    }\n\n    /**\n     * Get current filter state\n     * @returns {Object} Current filters\n     */\n    getFilters() {\n        return {\n            search: this.searchFilter,\n            type: this.typeFilter,\n            session: this.sessionFilter\n        };\n    }\n\n    /**\n     * Get filtered events (used by HUD and other components)\n     * @returns {Array} Array of filtered events\n     */\n    getFilteredEvents() {\n        return this.filteredEvents;\n    }\n\n    /**\n     * Get all events (unfiltered, used by HUD for complete visualization)\n     * @returns {Array} Array of all events\n     */\n    getAllEvents() {\n        return this.events;\n    }\n\n    /**\n     * Create inline diff viewer for Edit/MultiEdit tool events\n     * WHY: Provides immediate visibility of file changes without needing to open modals\n     * DESIGN DECISION: Shows inline diffs only for Edit/MultiEdit events to avoid clutter\n     * @param {Object} event - Event object\n     * @param {number} index - Event index for unique IDs\n     * @returns {string} HTML for inline diff viewer\n     */\n    createInlineEditDiffViewer(event, index) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Only show for Edit and MultiEdit tools\n        if (!['Edit', 'MultiEdit'].includes(toolName)) {\n            return '';\n        }\n\n        // Extract edit parameters based on tool type\n        let edits = [];\n        if (toolName === 'Edit') {\n            // Single edit\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.old_string && parameters.new_string) {\n                edits.push({\n                    old_string: parameters.old_string,\n                    new_string: parameters.new_string,\n                    file_path: parameters.file_path || 'unknown'\n                });\n            }\n        } else if (toolName === 'MultiEdit') {\n            // Multiple edits\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.edits && Array.isArray(parameters.edits)) {\n                edits = parameters.edits.map(edit => ({\n                    ...edit,\n                    file_path: parameters.file_path || 'unknown'\n                }));\n            }\n        }\n\n        if (edits.length === 0) {\n            return '';\n        }\n\n        // Create collapsible diff section\n        const diffId = `edit-diff-${index}`;\n        const isMultiEdit = edits.length > 1;\n\n        let diffContent = '';\n        edits.forEach((edit, editIndex) => {\n            const editId = `${diffId}-${editIndex}`;\n            const diffHtml = this.createDiffHtml(edit.old_string, edit.new_string);\n\n            diffContent += `\n                <div class=\"edit-diff-section\">\n                    ${isMultiEdit ? `<div class=\"edit-diff-header\">Edit ${editIndex + 1}</div>` : ''}\n                    <div class=\"diff-content\">${diffHtml}</div>\n                </div>\n            `;\n        });\n\n        return `\n            <div class=\"inline-edit-diff-viewer\">\n                <div class=\"diff-toggle-header\" onclick=\"eventViewer.toggleEditDiff('${diffId}', event)\">\n                    <span class=\"diff-toggle-icon\">ðŸ“‹</span>\n                    <span class=\"diff-toggle-text\">Show ${isMultiEdit ? edits.length + ' edits' : 'edit'}</span>\n                    <span class=\"diff-toggle-arrow\">â–¼</span>\n                </div>\n                <div id=\"${diffId}\" class=\"diff-content-container\" style=\"display: none;\">\n                    ${diffContent}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create HTML diff visualization\n     * WHY: Provides clear visual representation of text changes similar to git diff\n     * @param {string} oldText - Original text\n     * @param {string} newText - Modified text\n     * @returns {string} HTML diff content\n     */\n    createDiffHtml(oldText, newText) {\n        // Simple line-by-line diff implementation\n        const oldLines = oldText.split('\\n');\n        const newLines = newText.split('\\n');\n\n        let diffHtml = '';\n        let i = 0, j = 0;\n\n        // Simple diff algorithm - can be enhanced with proper diff library if needed\n        while (i < oldLines.length || j < newLines.length) {\n            const oldLine = i < oldLines.length ? oldLines[i] : null;\n            const newLine = j < newLines.length ? newLines[j] : null;\n\n            if (oldLine === null) {\n                // New line added\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                j++;\n            } else if (newLine === null) {\n                // Old line removed\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n            } else if (oldLine === newLine) {\n                // Lines are the same\n                diffHtml += `<div class=\"diff-line diff-unchanged\">  ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n                j++;\n            } else {\n                // Lines are different - show both\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                i++;\n                j++;\n            }\n        }\n\n        return `<div class=\"diff-container\">${diffHtml}</div>`;\n    }\n\n    /**\n     * Toggle edit diff visibility\n     * @param {string} diffId - Diff container ID\n     * @param {Event} event - Click event\n     */\n    toggleEditDiff(diffId, event) {\n        // Prevent event bubbling to parent event item\n        event.stopPropagation();\n\n        const diffContainer = document.getElementById(diffId);\n        const arrow = event.currentTarget.querySelector('.diff-toggle-arrow');\n\n        if (diffContainer) {\n            const isVisible = diffContainer.style.display !== 'none';\n            diffContainer.style.display = isVisible ? 'none' : 'block';\n            if (arrow) {\n                arrow.textContent = isVisible ? 'â–¼' : 'â–²';\n            }\n        }\n    }\n\n    /**\n     * Escape HTML characters for safe display\n     * @param {string} text - Text to escape\n     * @returns {string} Escaped text\n     */\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n}\n\n// ES6 Module export\nexport { EventViewer };\nexport default EventViewer;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.EventViewer = EventViewer;\n","/**\n * Event Processor Module\n *\n * Handles event processing, filtering, and rendering for different tabs in the dashboard.\n * Provides centralized event filtering and rendering logic for agents, tools, and files tabs.\n *\n * WHY: Extracted from main dashboard to isolate complex event processing logic\n * that involves filtering, transforming, and rendering events across different views.\n * This improves maintainability and makes the event processing logic testable.\n *\n * DESIGN DECISION: Maintains its own filtered event collections while relying on\n * eventViewer for source data. Provides separate filtering logic for each tab type\n * while sharing common filtering patterns and utilities.\n */\nclass EventProcessor {\n    constructor(eventViewer, agentInference) {\n        this.eventViewer = eventViewer;\n        this.agentInference = agentInference;\n\n        // Processed event collections for different tabs\n        this.agentEvents = [];\n        this.filteredAgentEvents = [];\n        this.filteredToolEvents = [];\n        this.filteredFileEvents = [];\n\n        // Session filtering\n        this.selectedSessionId = null;\n\n        // Git tracking status cache\n        this.fileTrackingCache = new Map(); // file_path -> {is_tracked: boolean, timestamp: number}\n        this.trackingCheckTimeout = 30000; // Cache for 30 seconds\n\n        console.log('Event processor initialized');\n    }\n\n    /**\n     * Get filtered events for a specific tab\n     * @param {string} tabName - Tab name ('agents', 'tools', 'files', 'events')\n     * @returns {Array} - Filtered events\n     */\n    getFilteredEventsForTab(tabName) {\n        const events = this.eventViewer.events;\n        console.log(`getFilteredEventsForTab(${tabName}) - using RAW events: ${events.length} total`);\n\n        // Use session manager to filter events by session if needed\n        const sessionManager = window.sessionManager;\n        if (sessionManager && sessionManager.selectedSessionId) {\n            const sessionEvents = sessionManager.getEventsForSession(sessionManager.selectedSessionId);\n            console.log(`Filtering by session ${sessionManager.selectedSessionId}: ${sessionEvents.length} events`);\n            return sessionEvents;\n        }\n\n        return events;\n    }\n\n    /**\n     * Apply agents tab filtering for unique instances\n     * @param {Array} uniqueInstances - Unique agent instances to filter\n     * @returns {Array} - Filtered unique instances\n     */\n    applyAgentsFilters(uniqueInstances) {\n        const searchInput = document.getElementById('agents-search-input');\n        const typeFilter = document.getElementById('agents-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return uniqueInstances.filter(instance => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    instance.agentName || '',\n                    instance.type || '',\n                    instance.isImplied ? 'implied' : 'explicit'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const agentName = instance.agentName || 'unknown';\n                if (!agentName.toLowerCase().includes(typeValue.toLowerCase())) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering\n     * @param {Array} events - Events to filter\n     * @returns {Array} - Filtered events\n     */\n    applyToolsFilters(events) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return events.filter(event => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    event.tool_name || '',\n                    event.agent_type || '',\n                    event.type || '',\n                    event.subtype || ''\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = event.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering for tool calls\n     * @param {Array} toolCallsArray - Tool calls array to filter\n     * @returns {Array} - Filtered tool calls\n     */\n    applyToolCallFilters(toolCallsArray) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return toolCallsArray.filter(([key, toolCall]) => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    toolCall.tool_name || '',\n                    toolCall.agent_type || '',\n                    'tool_call'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = toolCall.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply files tab filtering\n     * @param {Array} fileOperations - File operations to filter\n     * @returns {Array} - Filtered file operations\n     */\n    applyFilesFilters(fileOperations) {\n        const searchInput = document.getElementById('files-search-input');\n        const typeFilter = document.getElementById('files-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return fileOperations.filter(([filePath, fileData]) => {\n            // Session filter - filter operations within each file\n            if (this.selectedSessionId) {\n                // Filter operations for this file by session\n                const sessionOperations = fileData.operations.filter(op =>\n                    op.sessionId === this.selectedSessionId\n                );\n\n                // If no operations from this session, exclude the file\n                if (sessionOperations.length === 0) {\n                    return false;\n                }\n\n                // Update the fileData to only include session-specific operations\n                // (Note: This creates a filtered view without modifying the original)\n                fileData = {\n                    ...fileData,\n                    operations: sessionOperations,\n                    lastOperation: sessionOperations[sessionOperations.length - 1]?.timestamp || fileData.lastOperation\n                };\n            }\n\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    filePath,\n                    ...fileData.operations.map(op => op.operation),\n                    ...fileData.operations.map(op => op.agent)\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const operations = fileData.operations.map(op => op.operation);\n                if (!operations.includes(typeValue)) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Extract operation type from event type\n     * @param {string} eventType - Event type string\n     * @returns {string} - Operation type\n     */\n    extractOperation(eventType) {\n        if (!eventType) return 'unknown';\n\n        const type = eventType.toLowerCase();\n        if (type.includes('read')) return 'read';\n        if (type.includes('write')) return 'write';\n        if (type.includes('edit')) return 'edit';\n        if (type.includes('create')) return 'create';\n        if (type.includes('delete')) return 'delete';\n        if (type.includes('move') || type.includes('rename')) return 'move';\n\n        return 'other';\n    }\n\n    /**\n     * Extract tool name from hook event type\n     * @param {string} eventType - Hook event type\n     * @returns {string} - Tool name\n     */\n    extractToolFromHook(eventType) {\n        if (!eventType) return '';\n\n        // Pattern: Pre{ToolName}Use or Post{ToolName}Use\n        const match = eventType.match(/^(?:Pre|Post)(.+)Use$/);\n        return match ? match[1] : '';\n    }\n\n    /**\n     * Extract tool name from subtype\n     * @param {string} subtype - Event subtype\n     * @returns {string} - Tool name\n     */\n    extractToolFromSubtype(subtype) {\n        if (!subtype) return '';\n\n        // Handle various subtype patterns\n        if (subtype.includes('_')) {\n            const parts = subtype.split('_');\n            return parts[0] || '';\n        }\n\n        return subtype;\n    }\n\n    /**\n     * Extract target information from tool parameters\n     * @param {string} toolName - Tool name\n     * @param {Object} params - Tool parameters\n     * @param {Object} toolParameters - Alternative tool parameters\n     * @returns {string} - Target information\n     */\n    extractToolTarget(toolName, params, toolParameters) {\n        const parameters = params || toolParameters || {};\n\n        switch (toolName?.toLowerCase()) {\n            case 'read':\n            case 'write':\n            case 'edit':\n                return parameters.file_path || parameters.path || '';\n            case 'bash':\n                return parameters.command || '';\n            case 'grep':\n                return parameters.pattern || '';\n            case 'task':\n                return parameters.subagent_type || parameters.agent_type || '';\n            default:\n                // Try to find a meaningful parameter\n                const keys = Object.keys(parameters);\n                const meaningfulKeys = ['path', 'file_path', 'command', 'pattern', 'query', 'target'];\n                for (const key of meaningfulKeys) {\n                    if (parameters[key]) {\n                        return parameters[key];\n                    }\n                }\n                return keys.length > 0 ? `${keys[0]}: ${parameters[keys[0]]}` : '';\n        }\n    }\n\n    /**\n     * Generate HTML for unique agent instances (one row per PM delegation)\n     * @param {Array} events - Agent events to render (not used, kept for compatibility)\n     * @returns {string} - HTML string\n     */\n    generateAgentHTML(events) {\n        // Get unique agent instances from agent inference\n        const uniqueInstances = this.agentInference.getUniqueAgentInstances();\n\n        // Apply filtering\n        const filteredInstances = this.applyAgentsFilters(uniqueInstances);\n\n        return filteredInstances.map((instance, index) => {\n            const agentName = instance.agentName;\n            const timestamp = this.formatTimestamp(instance.firstTimestamp || instance.timestamp);\n            const delegationType = instance.isImplied ? 'implied' : 'explicit';\n            // Fix: Use totalEventCount which is the actual property name from getUniqueAgentInstances()\n            const eventCount = instance.totalEventCount || instance.eventCount || 0;\n\n            const onclickString = `dashboard.selectCard('agents', ${index}, 'agent_instance', '${instance.id}'); dashboard.showAgentInstanceDetails('${instance.id}');`;\n\n            // Format: \"[Agent Name] (delegationType, eventCount events)\" with separate timestamp\n            const agentMainContent = `${agentName} (${delegationType}, ${eventCount} events)`;\n\n            return `\n                <div class=\"event-item single-row event-agent\" onclick=\"${onclickString}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${agentMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for tool events\n     * @param {Array} toolCalls - Tool calls to render\n     * @returns {string} - HTML string\n     */\n    generateToolHTML(toolCalls) {\n        const filteredToolCalls = this.applyToolCallFilters(toolCalls);\n\n        return filteredToolCalls.map(([key, toolCall], index) => {\n            const toolName = toolCall.tool_name || 'Unknown';\n            const rawAgent = toolCall.agent_type || 'Unknown';\n            const timestamp = this.formatTimestamp(toolCall.timestamp);\n            const status = toolCall.post_event ? 'completed' : 'pending';\n            const statusClass = status === 'completed' ? 'status-success' : 'status-pending';\n\n            // Convert agent name: show \"pm\" for PM agent, otherwise show actual agent name\n            const agentName = rawAgent.toLowerCase() === 'pm' ? 'pm' : rawAgent;\n\n            // Format: \"Tool Name (Agent Name)\" - removed duration from main display\n            const toolMainContent = `${toolName} (${agentName})`;\n\n            return `\n                <div class=\"event-item single-row event-tool ${statusClass}\" onclick=\"dashboard.selectCard('tools', ${index}, 'toolCall', '${key}'); dashboard.showToolCallDetails('${key}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${toolMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for file operations\n     * @param {Array} fileOperations - File operations to render\n     * @returns {string} - HTML string\n     */\n    generateFileHTML(fileOperations) {\n        const filteredFiles = this.applyFilesFilters(fileOperations);\n\n        return filteredFiles.map(([filePath, fileData], index) => {\n            const operations = fileData.operations.map(op => op.operation);\n            const timestamp = this.formatTimestamp(fileData.lastOperation);\n\n            // Count operations by type for display: \"read(2), write(1)\"\n            const operationCounts = {};\n            operations.forEach(op => {\n                operationCounts[op] = (operationCounts[op] || 0) + 1;\n            });\n\n            const operationSummary = Object.entries(operationCounts)\n                .map(([op, count]) => `${op}(${count})`)\n                .join(', ');\n\n            // Get unique agents that worked on this file\n            const uniqueAgents = [...new Set(fileData.operations.map(op => op.agent))];\n            const agentSummary = uniqueAgents.length > 1 ? `by ${uniqueAgents.length} agents` : `by ${uniqueAgents[0] || 'unknown'}`;\n\n            // Format: \"[file path] read(2), write(1) by agent\" with separate timestamp\n            const fileName = this.getRelativeFilePath(filePath);\n            const fileMainContent = `${fileName} ${operationSummary} ${agentSummary}`;\n\n            return `\n                <div class=\"event-item single-row file-item\" onclick=\"dashboard.selectCard('files', ${index}, 'file', '${filePath}'); dashboard.showFileDetails('${filePath}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${fileMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Get icon for file operations\n     * @param {Array} operations - Array of operations\n     * @returns {string} - Icon representation\n     */\n    getFileOperationIcon(operations) {\n        if (operations.includes('write') || operations.includes('create')) return 'ðŸ“';\n        if (operations.includes('edit')) return 'âœï¸';\n        if (operations.includes('read')) return 'ðŸ‘ï¸';\n        if (operations.includes('delete')) return 'ðŸ—‘ï¸';\n        if (operations.includes('move')) return 'ðŸ“¦';\n        return 'ðŸ“„';\n    }\n\n    /**\n     * Get relative file path\n     * @param {string} filePath - Full file path\n     * @returns {string} - Relative path\n     */\n    getRelativeFilePath(filePath) {\n        if (!filePath) return '';\n\n        // Simple relative path logic - can be enhanced\n        const parts = filePath.split('/');\n        if (parts.length > 3) {\n            return '.../' + parts.slice(-2).join('/');\n        }\n        return filePath;\n    }\n\n    /**\n     * Format timestamp for display\n     * @param {string|number} timestamp - Timestamp to format\n     * @returns {string} - Formatted timestamp\n     */\n    formatTimestamp(timestamp) {\n        if (!timestamp) return '';\n\n        const date = new Date(timestamp);\n        return date.toLocaleTimeString();\n    }\n\n    /**\n     * Set selected session ID for filtering\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSelectedSessionId(sessionId) {\n        this.selectedSessionId = sessionId;\n    }\n\n    /**\n     * Get selected session ID\n     * @returns {string|null} - Current session ID\n     */\n    getSelectedSessionId() {\n        return this.selectedSessionId;\n    }\n\n    /**\n     * Get unique tool instances (one row per unique tool call)\n     * This deduplicates tool calls to show unique instances only\n     * @param {Array} toolCallsArray - Tool calls array\n     * @returns {Array} - Unique tool instances\n     */\n    getUniqueToolInstances(toolCallsArray) {\n        // The toolCallsArray already represents unique tool calls\n        // since it's generated from paired pre/post events in FileToolTracker\n        // Just apply filtering and return\n        return this.applyToolCallFilters(toolCallsArray);\n    }\n\n    /**\n     * Get unique file instances (one row per unique file)\n     * This aggregates all operations on each file\n     * @param {Array} fileOperations - File operations array\n     * @returns {Array} - Unique file instances (same as input since already unique per file)\n     */\n    getUniqueFileInstances(fileOperations) {\n        // The fileOperations array already represents unique files\n        // since it's keyed by file path in FileToolTracker\n        // Just apply filtering and return\n        return this.applyFilesFilters(fileOperations);\n    }\n\n    /**\n     * Check if a file is tracked by git (with caching)\n     * @param {string} filePath - Path to the file\n     * @param {string} workingDir - Working directory\n     * @returns {Promise<boolean>} - Promise resolving to tracking status\n     */\n    async isFileTracked(filePath, workingDir) {\n        const cacheKey = `${workingDir}:${filePath}`;\n        const now = Date.now();\n\n        // Check cache first\n        const cached = this.fileTrackingCache.get(cacheKey);\n        if (cached && (now - cached.timestamp) < this.trackingCheckTimeout) {\n            return cached.is_tracked;\n        }\n\n        try {\n            // Use the socketio connection to check tracking status\n            const socket = window.socket;\n            if (!socket) {\n                console.warn('No socket connection available for git tracking check');\n                return false;\n            }\n\n            return new Promise((resolve) => {\n                // Set up one-time listener for response\n                const responseHandler = (data) => {\n                    if (data.file_path === filePath) {\n                        const isTracked = data.success && data.is_tracked;\n\n                        // Cache the result\n                        this.fileTrackingCache.set(cacheKey, {\n                            is_tracked: isTracked,\n                            timestamp: now\n                        });\n\n                        socket.off('file_tracked_response', responseHandler);\n                        resolve(isTracked);\n                    }\n                };\n\n                socket.on('file_tracked_response', responseHandler);\n\n                // Send request\n                socket.emit('check_file_tracked', {\n                    file_path: filePath,\n                    working_dir: workingDir\n                });\n\n                // Timeout after 5 seconds\n                setTimeout(() => {\n                    socket.off('file_tracked_response', responseHandler);\n                    resolve(false); // Default to not tracked on timeout\n                }, 5000);\n            });\n\n        } catch (error) {\n            console.error('Error checking file tracking status:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Generate git diff icon with tracking status\n     * @param {string} filePath - Path to the file\n     * @param {string} timestamp - Operation timestamp\n     * @param {string} workingDir - Working directory\n     * @returns {string} - HTML for git diff icon\n     */\n    generateGitDiffIcon(filePath, timestamp, workingDir) {\n        const iconId = `git-icon-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}-${timestamp}`;\n\n        // Initially show default icon\n        const iconHtml = `\n            <span id=\"${iconId}\" class=\"git-diff-icon\"\n                  onclick=\"event.stopPropagation(); showGitDiffModal('${filePath}', '${timestamp}')\"\n                  title=\"View git diff for this file operation\"\n                  style=\"margin-left: 8px; cursor: pointer; font-size: 16px;\">\n                ðŸ“‹\n            </span>\n        `;\n\n        // Asynchronously check tracking status and update icon\n        this.isFileTracked(filePath, workingDir).then(isTracked => {\n            const iconElement = document.getElementById(iconId);\n            if (iconElement) {\n                if (!isTracked) {\n                    // File is not tracked - show crossed out icon\n                    iconElement.innerHTML = 'ðŸ“‹âŒ';\n                    iconElement.title = 'File not tracked by git - click to see details';\n                    iconElement.classList.add('untracked-file');\n                } else {\n                    // File is tracked - keep normal icon\n                    iconElement.innerHTML = 'ðŸ“‹';\n                    iconElement.title = 'View git diff for this file operation';\n                    iconElement.classList.add('tracked-file');\n                }\n            }\n        }).catch(error => {\n            console.error('Error updating git diff icon:', error);\n        });\n\n        return iconHtml;\n    }\n\n    /**\n     * Show agent instance details for unique instance view\n     * @param {string} instanceId - Agent instance ID\n     */\n    showAgentInstanceDetails(instanceId) {\n        const pmDelegations = this.agentInference.getPMDelegations();\n        const instance = pmDelegations.get(instanceId);\n\n        if (!instance) {\n            console.error('Agent instance not found:', instanceId);\n            return;\n        }\n\n        // Show details about this PM delegation and its events\n        console.log('Showing agent instance details for:', instanceId, instance);\n\n        // This would integrate with the existing detail view system\n        // For now, just log the details - can be expanded to show in a modal/sidebar\n        const detailsHtml = `\n            <div class=\"agent-instance-details\">\n                <h3>Agent Instance: ${instance.agentName}</h3>\n                <p><strong>Type:</strong> ${instance.isImplied ? 'Implied PM Delegation' : 'Explicit PM Delegation'}</p>\n                <p><strong>Start Time:</strong> ${this.formatTimestamp(instance.timestamp)}</p>\n                <p><strong>Event Count:</strong> ${instance.agentEvents.length}</p>\n                <p><strong>Session:</strong> ${instance.sessionId}</p>\n                ${instance.pmCall ? `<p><strong>PM Call:</strong> Task delegation to ${instance.agentName}</p>` : '<p><strong>Note:</strong> Implied delegation (no explicit PM call found)</p>'}\n            </div>\n        `;\n\n        // You would integrate this with your existing detail display system\n        console.log('Agent instance details HTML:', detailsHtml);\n    }\n}\n\n// ES6 Module export\nexport { EventProcessor };\nexport default EventProcessor;\n"],"names":["EventViewer","constructor","containerId","socketClient","this","container","document","getElementById","events","filteredEvents","selectedEventIndex","filteredEventElements","autoScroll","searchFilter","typeFilter","sessionFilter","eventTypeCount","availableEventTypes","Set","errorCount","eventsThisMinute","lastMinute","Date","getMinutes","init","setupEventHandlers","setupKeyboardNavigation","onEventUpdate","sessions","console","log","length","Array","isArray","updateDisplay","searchInput","addEventListener","e","target","value","toLowerCase","applyFilters","handleArrowNavigation","direction","newIndex","showEventDetails","warn","filter","event","type","subtype","JSON","stringify","data","join","includes","eventType","trim","session_id","renderEvents","updateMetrics","updateEventTypeDropdown","dropdown","eventTypes","forEach","fullType","add","currentTypes","from","sort","previousTypes","currentSelection","innerHTML","option","createElement","textContent","appendChild","has","eventsList","html","map","index","timestamp","toLocaleTimeString","formatSingleRowEventContent","createInlineEditDiffViewer","querySelectorAll","window","dashboard","currentTab","tabNavigation","items","scrollTop","scrollHeight","formatEventType","originalEventName","formatEventData","formatSessionEvent","formatClaudeEvent","formatAgentEvent","formatHookEvent","formatTodoEvent","formatMemoryEvent","formatLogEvent","formatGenericEvent","prompt","message","substring","response","content","agent_type","name","event_type","prompt_text","prompt_preview","toolName","tool_name","operation_type","postToolName","success","status","duration_ms","notification_type","message_preview","reason","stop_type","startAgentType","agent","subagent_type","startPrompt","description","task","startTruncated","formatAgentType","agentType","stopReason","stop_reason","stopAgentDisplay","isCompleted","structured_response","task_completed","hookName","hook_name","todos","count","operation","key","level","truncated","toUpperCase","agentTypeMap","research","architect","engineer","qa","pm","project_manager","research_agent","architect_agent","engineer_agent","qa_agent","unknown","lowerType","match","charAt","slice","sourcePrefix","source","dataDetails","hookType","agentDisplay","agentName","t","test_name","Object","keys","firstKey","find","k","getHookDisplayName","hookNames","pre_tool","post_tool","user_prompt","stop","subagent_start","subagent_stop","notification","String","replace","getEventCategory","selectedIndex","selectCard","el","i","classList","toggle","dispatchEvent","CustomEvent","detail","selectedElement","scrollIntoView","behavior","block","clearSelection","remove","clearCardSelection","currentMinute","oneMinuteAgo","now","updateMetricsUI","totalEventsEl","eventsPerMinuteEl","uniqueTypesEl","errorCountEl","exportEvents","dataStr","dataBlob","Blob","url","URL","createObjectURL","link","href","download","toISOString","split","click","revokeObjectURL","clearEvents","setSessionFilter","sessionId","getFilters","search","session","getFilteredEvents","getAllEvents","edits","parameters","tool_parameters","old_string","new_string","push","file_path","edit","diffId","isMultiEdit","diffContent","editIndex","diffHtml","createDiffHtml","oldText","newText","oldLines","newLines","j","oldLine","newLine","escapeHtml","toggleEditDiff","stopPropagation","diffContainer","arrow","currentTarget","querySelector","isVisible","style","display","text","div","EventProcessor","eventViewer","agentInference","agentEvents","filteredAgentEvents","filteredToolEvents","filteredFileEvents","selectedSessionId","fileTrackingCache","Map","trackingCheckTimeout","getFilteredEventsForTab","tabName","sessionManager","sessionEvents","getEventsForSession","applyAgentsFilters","uniqueInstances","searchText","typeValue","instance","isImplied","applyToolsFilters","applyToolCallFilters","toolCallsArray","toolCall","applyFilesFilters","fileOperations","filePath","fileData","sessionOperations","operations","op","lastOperation","extractOperation","extractToolFromHook","extractToolFromSubtype","extractToolTarget","params","toolParameters","path","command","pattern","meaningfulKeys","generateAgentHTML","getUniqueAgentInstances","formatTimestamp","firstTimestamp","delegationType","eventCount","totalEventCount","id","generateToolHTML","toolCalls","rawAgent","post_event","generateFileHTML","operationCounts","operationSummary","entries","uniqueAgents","agentSummary","getRelativeFilePath","getFileOperationIcon","parts","setSelectedSessionId","getSelectedSessionId","getUniqueToolInstances","getUniqueFileInstances","isFileTracked","workingDir","cacheKey","cached","get","is_tracked","socket","Promise","resolve","responseHandler","isTracked","set","off","on","emit","working_dir","setTimeout","error","generateGitDiffIcon","iconId","iconHtml","then","iconElement","title","catch","showAgentInstanceDetails","instanceId","getPMDelegations","detailsHtml","pmCall"],"mappings":"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"}