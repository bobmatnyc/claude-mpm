{"version":3,"file":"event-viewer.js","sources":["../../js/components/event-viewer.js","../../js/components/event-processor.js"],"sourcesContent":["/**\n * Event Viewer Component\n * Handles event display, filtering, and selection\n */\n\nclass EventViewer {\n    constructor(containerId, socketClient) {\n        this.container = document.getElementById(containerId);\n        this.socketClient = socketClient;\n\n        // State\n        this.events = [];\n        this.filteredEvents = [];\n        this.selectedEventIndex = -1;\n        this.filteredEventElements = [];\n        this.autoScroll = true;\n\n        // Filters\n        this.searchFilter = '';\n        this.typeFilter = '';\n        this.sessionFilter = '';\n\n        // Event type tracking\n        this.eventTypeCount = {};\n        this.availableEventTypes = new Set();\n        this.errorCount = 0;\n        this.eventsThisMinute = 0;\n        this.lastMinute = new Date().getMinutes();\n\n        this.init();\n    }\n\n    /**\n     * Initialize the event viewer\n     */\n    init() {\n        this.setupEventHandlers();\n        this.setupKeyboardNavigation();\n\n        // Subscribe to socket events\n        this.socketClient.onEventUpdate((events, sessions) => {\n            // Ensure we always have a valid events array\n            this.events = Array.isArray(events) ? events : [];\n            this.updateDisplay();\n        });\n    }\n\n    /**\n     * Setup event handlers for UI controls\n     */\n    setupEventHandlers() {\n        // Search input\n        const searchInput = document.getElementById('events-search-input');\n        if (searchInput) {\n            searchInput.addEventListener('input', (e) => {\n                this.searchFilter = e.target.value.toLowerCase();\n                this.applyFilters();\n            });\n        }\n\n        // Type filter\n        const typeFilter = document.getElementById('events-type-filter');\n        if (typeFilter) {\n            typeFilter.addEventListener('change', (e) => {\n                this.typeFilter = e.target.value;\n                this.applyFilters();\n            });\n        }\n    }\n\n    /**\n     * Setup keyboard navigation for events\n     * Note: This is now handled by the unified Dashboard navigation system\n     */\n    setupKeyboardNavigation() {\n        // Keyboard navigation is now handled by Dashboard.setupUnifiedKeyboardNavigation()\n        // This method is kept for backward compatibility but does nothing\n        console.log('EventViewer: Keyboard navigation handled by unified Dashboard system');\n    }\n\n    /**\n     * Handle arrow key navigation\n     * @param {number} direction - Direction: 1 for down, -1 for up\n     */\n    handleArrowNavigation(direction) {\n        if (this.filteredEventElements.length === 0) return;\n\n        // Calculate new index\n        let newIndex = this.selectedEventIndex + direction;\n\n        // Wrap around\n        if (newIndex >= this.filteredEventElements.length) {\n            newIndex = 0;\n        } else if (newIndex < 0) {\n            newIndex = this.filteredEventElements.length - 1;\n        }\n\n        this.showEventDetails(newIndex);\n    }\n\n    /**\n     * Apply filters to events\n     */\n    applyFilters() {\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized, using empty array');\n            this.events = [];\n        }\n\n        this.filteredEvents = this.events.filter(event => {\n            // Search filter\n            if (this.searchFilter) {\n                const searchableText = [\n                    event.type || '',\n                    event.subtype || '',\n                    JSON.stringify(event.data || {})\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(this.searchFilter)) {\n                    return false;\n                }\n            }\n\n            // Type filter - now handles full hook types (like \"hook.user_prompt\") and main types\n            if (this.typeFilter) {\n                // Use the same logic as formatEventType to get the full event type\n                const eventType = event.type && event.type.trim() !== '' ? event.type : '';\n                const fullEventType = event.subtype && eventType ? `${eventType}.${event.subtype}` : eventType;\n                if (fullEventType !== this.typeFilter) {\n                    return false;\n                }\n            }\n\n            // Session filter\n            if (this.sessionFilter && this.sessionFilter !== '') {\n                if (!event.data || event.data.session_id !== this.sessionFilter) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n\n        this.renderEvents();\n        this.updateMetrics();\n    }\n\n    /**\n     * Update available event types and populate dropdown\n     */\n    updateEventTypeDropdown() {\n        const dropdown = document.getElementById('events-type-filter');\n        if (!dropdown) return;\n\n        // Extract unique event types from current events\n        // Use the same logic as formatEventType to get full event type names\n        const eventTypes = new Set();\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateEventTypeDropdown');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            if (event.type && event.type.trim() !== '') {\n                // Combine type and subtype if subtype exists, otherwise just use type\n                const fullType = event.subtype ? `${event.type}.${event.subtype}` : event.type;\n                eventTypes.add(fullType);\n            }\n        });\n\n        // Check if event types have changed\n        const currentTypes = Array.from(eventTypes).sort();\n        const previousTypes = Array.from(this.availableEventTypes).sort();\n\n        if (JSON.stringify(currentTypes) === JSON.stringify(previousTypes)) {\n            return; // No change needed\n        }\n\n        // Update our tracking\n        this.availableEventTypes = eventTypes;\n\n        // Store the current selection\n        const currentSelection = dropdown.value;\n\n        // Clear existing options except \"All Events\"\n        dropdown.innerHTML = '<option value=\"\">All Events</option>';\n\n        // Add new options sorted alphabetically\n        const sortedTypes = Array.from(eventTypes).sort();\n        sortedTypes.forEach(type => {\n            const option = document.createElement('option');\n            option.value = type;\n            option.textContent = type;\n            dropdown.appendChild(option);\n        });\n\n        // Restore selection if it still exists\n        if (currentSelection && eventTypes.has(currentSelection)) {\n            dropdown.value = currentSelection;\n        } else if (currentSelection && !eventTypes.has(currentSelection)) {\n            // If the previously selected type no longer exists, clear the filter\n            dropdown.value = '';\n            this.typeFilter = '';\n        }\n    }\n\n    /**\n     * Update the display with current events\n     */\n    updateDisplay() {\n        this.updateEventTypeDropdown();\n        this.applyFilters();\n    }\n\n    /**\n     * Render events in the UI\n     */\n    renderEvents() {\n        const eventsList = document.getElementById('events-list');\n        if (!eventsList) return;\n\n        if (this.filteredEvents.length === 0) {\n            eventsList.innerHTML = `\n                <div class=\"no-events\">\n                    ${this.events.length === 0 ?\n                        'Connect to Socket.IO server to see events...' :\n                        'No events match current filters...'}\n                </div>\n            `;\n            this.filteredEventElements = [];\n            return;\n        }\n\n        const html = this.filteredEvents.map((event, index) => {\n            const timestamp = new Date(event.timestamp).toLocaleTimeString();\n            const eventClass = event.type ? `event-${event.type}` : 'event-default';\n            const isSelected = index === this.selectedEventIndex;\n\n            // Get main content and timestamp separately\n            const mainContent = this.formatSingleRowEventContent(event);\n\n            // Check if this is an Edit/MultiEdit tool event and add diff viewer\n            const diffViewer = this.createInlineEditDiffViewer(event, index);\n\n            return `\n                <div class=\"event-item single-row ${eventClass} ${isSelected ? 'selected' : ''}\"\n                     onclick=\"eventViewer.showEventDetails(${index})\"\n                     data-index=\"${index}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${mainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                    ${diffViewer}\n                </div>\n            `;\n        }).join('');\n\n        eventsList.innerHTML = html;\n\n        // Update filtered elements reference\n        this.filteredEventElements = Array.from(eventsList.querySelectorAll('.event-item'));\n\n        // Update Dashboard navigation items if we're in the events tab\n        if (window.dashboard && window.dashboard.currentTab === 'events' &&\n            window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n            window.dashboard.tabNavigation.events.items = this.filteredEventElements;\n        }\n\n        // Auto-scroll to bottom if enabled\n        if (this.autoScroll && this.filteredEvents.length > 0) {\n            eventsList.scrollTop = eventsList.scrollHeight;\n        }\n    }\n\n    /**\n     * Format event type for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event type\n     */\n    formatEventType(event) {\n        // If we have type and subtype, use them\n        if (event.type && event.subtype) {\n            // Check if type and subtype are identical to prevent \"type.type\" display\n            if (event.type === event.subtype) {\n                return event.type;\n            }\n            return `${event.type}.${event.subtype}`;\n        }\n        // If we have just type, use it\n        if (event.type) {\n            return event.type;\n        }\n        // If we have originalEventName (from transformation), use it as fallback\n        if (event.originalEventName) {\n            return event.originalEventName;\n        }\n        // Last resort fallback\n        return 'unknown';\n    }\n\n    /**\n     * Format event data for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event data\n     */\n    formatEventData(event) {\n        if (!event.data) return 'No data';\n\n        // Special formatting for different event types\n        switch (event.type) {\n            case 'session':\n                return this.formatSessionEvent(event);\n            case 'claude':\n                return this.formatClaudeEvent(event);\n            case 'agent':\n                return this.formatAgentEvent(event);\n            case 'hook':\n                return this.formatHookEvent(event);\n            case 'todo':\n                return this.formatTodoEvent(event);\n            case 'memory':\n                return this.formatMemoryEvent(event);\n            case 'log':\n                return this.formatLogEvent(event);\n            default:\n                return this.formatGenericEvent(event);\n        }\n    }\n\n    /**\n     * Format session event data\n     */\n    formatSessionEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'started') {\n            return `<strong>Session started:</strong> ${data.session_id || 'Unknown'}`;\n        } else if (event.subtype === 'ended') {\n            return `<strong>Session ended:</strong> ${data.session_id || 'Unknown'}`;\n        }\n        return `<strong>Session:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format Claude event data\n     */\n    formatClaudeEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'request') {\n            const prompt = data.prompt || data.message || '';\n            const truncated = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;\n            return `<strong>Request:</strong> ${truncated}`;\n        } else if (event.subtype === 'response') {\n            const response = data.response || data.content || '';\n            const truncated = response.length > 100 ? response.substring(0, 100) + '...' : response;\n            return `<strong>Response:</strong> ${truncated}`;\n        }\n        return `<strong>Claude:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format agent event data\n     */\n    formatAgentEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'loaded') {\n            return `<strong>Agent loaded:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        } else if (event.subtype === 'executed') {\n            return `<strong>Agent executed:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        }\n        return `<strong>Agent:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format hook event data\n     */\n    formatHookEvent(event) {\n        const data = event.data;\n        const eventType = data.event_type || event.subtype || 'unknown';\n\n        // Format based on specific hook event type\n        switch (eventType) {\n            case 'user_prompt':\n                const prompt = data.prompt_text || data.prompt_preview || '';\n                const truncated = prompt.length > 80 ? prompt.substring(0, 80) + '...' : prompt;\n                return `<strong>User Prompt:</strong> ${truncated || 'No prompt text'}`;\n\n            case 'pre_tool':\n                const toolName = data.tool_name || 'Unknown tool';\n                const operation = data.operation_type || 'operation';\n                return `<strong>Pre-Tool (${operation}):</strong> ${toolName}`;\n\n            case 'post_tool':\n                const postToolName = data.tool_name || 'Unknown tool';\n                const status = data.success ? 'success' : data.status || 'failed';\n                const duration = data.duration_ms ? ` (${data.duration_ms}ms)` : '';\n                return `<strong>Post-Tool (${status}):</strong> ${postToolName}${duration}`;\n\n            case 'notification':\n                const notifType = data.notification_type || 'notification';\n                const message = data.message_preview || data.message || 'No message';\n                return `<strong>Notification (${notifType}):</strong> ${message}`;\n\n            case 'stop':\n                const reason = data.reason || 'unknown';\n                const stopType = data.stop_type || 'normal';\n                return `<strong>Stop (${stopType}):</strong> ${reason}`;\n\n            case 'subagent_stop':\n                const agentType = data.agent_type || 'unknown agent';\n                const stopReason = data.reason || 'unknown';\n                return `<strong>Subagent Stop (${agentType}):</strong> ${stopReason}`;\n\n            default:\n                // Fallback to original logic for unknown hook types\n                const hookName = data.hook_name || data.name || data.event_type || 'Unknown';\n                const phase = event.subtype || eventType;\n                return `<strong>Hook ${phase}:</strong> ${hookName}`;\n        }\n    }\n\n    /**\n     * Format todo event data\n     */\n    formatTodoEvent(event) {\n        const data = event.data;\n        if (data.todos && Array.isArray(data.todos)) {\n            const count = data.todos.length;\n            return `<strong>Todo updated:</strong> ${count} item${count !== 1 ? 's' : ''}`;\n        }\n        return `<strong>Todo:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format memory event data\n     */\n    formatMemoryEvent(event) {\n        const data = event.data;\n        const operation = data.operation || 'unknown';\n        return `<strong>Memory ${operation}:</strong> ${data.key || 'Unknown key'}`;\n    }\n\n    /**\n     * Format log event data\n     */\n    formatLogEvent(event) {\n        const data = event.data;\n        const level = data.level || 'info';\n        const message = data.message || '';\n        const truncated = message.length > 80 ? message.substring(0, 80) + '...' : message;\n        return `<strong>[${level.toUpperCase()}]</strong> ${truncated}`;\n    }\n\n    /**\n     * Format generic event data\n     */\n    formatGenericEvent(event) {\n        const data = event.data;\n        if (typeof data === 'string') {\n            return data.length > 100 ? data.substring(0, 100) + '...' : data;\n        }\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Format event content for single-row display (without timestamp)\n     * Format: \"hook.pre_tool Pre-Tool (task_management): TodoWrite\"\n     * @param {Object} event - Event object\n     * @returns {string} Formatted single-row event content string\n     */\n    formatSingleRowEventContent(event) {\n        const eventType = this.formatEventType(event);\n        const data = event.data || {};\n\n        // Extract event details for different event types\n        let eventDetails = '';\n        let category = '';\n        let action = '';\n\n        switch (event.type) {\n            case 'hook':\n                // Hook events: extract tool name and hook type\n                const toolName = event.tool_name || data.tool_name || 'Unknown';\n                const hookType = event.subtype || 'Unknown';\n                const hookDisplayName = this.getHookDisplayName(hookType, data);\n                category = this.getEventCategory(event);\n                eventDetails = `${hookDisplayName} (${category}): ${toolName}`;\n                break;\n\n            case 'agent':\n                // Agent events\n                const agentName = event.subagent_type || data.subagent_type || 'PM';\n                const agentAction = event.subtype || 'action';\n                category = 'agent_operations';\n                eventDetails = `${agentName} ${agentAction}`;\n                break;\n\n            case 'todo':\n                // Todo events\n                const todoCount = data.todos ? data.todos.length : 0;\n                category = 'task_management';\n                eventDetails = `TodoWrite (${todoCount} items)`;\n                break;\n\n            case 'memory':\n                // Memory events\n                const operation = data.operation || 'unknown';\n                const key = data.key || 'unknown';\n                category = 'memory_operations';\n                eventDetails = `${operation} ${key}`;\n                break;\n\n            case 'session':\n                // Session events\n                const sessionAction = event.subtype || 'unknown';\n                category = 'session_management';\n                eventDetails = `Session ${sessionAction}`;\n                break;\n\n            case 'claude':\n                // Claude events\n                const claudeAction = event.subtype || 'interaction';\n                category = 'claude_interactions';\n                eventDetails = `Claude ${claudeAction}`;\n                break;\n\n            default:\n                // Generic events\n                category = 'general';\n                eventDetails = event.type || 'Unknown Event';\n                break;\n        }\n\n        // Return formatted string: \"type.subtype DisplayName (category): Details\"\n        return `${eventType} ${eventDetails}`;\n    }\n\n    /**\n     * Get display name for hook types\n     * @param {string} hookType - Hook subtype\n     * @param {Object} data - Event data\n     * @returns {string} Display name\n     */\n    getHookDisplayName(hookType, data) {\n        const hookNames = {\n            'pre_tool': 'Pre-Tool',\n            'post_tool': 'Post-Tool',\n            'user_prompt': 'User-Prompt',\n            'stop': 'Stop',\n            'subagent_stop': 'Subagent-Stop',\n            'notification': 'Notification'\n        };\n\n        // Handle non-string hookType safely\n        if (hookNames[hookType]) {\n            return hookNames[hookType];\n        }\n        \n        // Convert to string and handle null/undefined\n        const typeStr = String(hookType || 'unknown');\n        return typeStr.replace(/_/g, ' ');\n    }\n\n    /**\n     * Get event category for display\n     * @param {Object} event - Event object\n     * @returns {string} Category\n     */\n    getEventCategory(event) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Categorize based on tool type\n        if (['Read', 'Write', 'Edit', 'MultiEdit'].includes(toolName)) {\n            return 'file_operations';\n        } else if (['Bash', 'grep', 'Glob'].includes(toolName)) {\n            return 'system_operations';\n        } else if (toolName === 'TodoWrite') {\n            return 'task_management';\n        } else if (toolName === 'Task') {\n            return 'agent_delegation';\n        } else if (event.subtype === 'stop' || event.subtype === 'subagent_stop') {\n            return 'session_control';\n        }\n\n        return 'general';\n    }\n\n    /**\n     * Show event details and update selection\n     * @param {number} index - Index of event to show\n     */\n    showEventDetails(index) {\n        // Defensive checks\n        if (!this.filteredEvents || !Array.isArray(this.filteredEvents)) {\n            console.warn('EventViewer: filteredEvents array is not initialized');\n            return;\n        }\n        if (index < 0 || index >= this.filteredEvents.length) return;\n\n        // Update selection\n        this.selectedEventIndex = index;\n\n        // Get the selected event\n        const event = this.filteredEvents[index];\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            // Update the dashboard's navigation state for events tab\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = index;\n            }\n            if (window.dashboard.selectCard) {\n                window.dashboard.selectCard('events', index, 'event', event);\n            }\n        }\n\n        // Update visual selection (this will be handled by Dashboard.updateCardSelectionUI())\n        this.filteredEventElements.forEach((el, i) => {\n            el.classList.toggle('selected', i === index);\n        });\n\n        // Notify other components about selection\n        document.dispatchEvent(new CustomEvent('eventSelected', {\n            detail: { event, index }\n        }));\n\n        // Scroll to selected event if not visible\n        const selectedElement = this.filteredEventElements[index];\n        if (selectedElement) {\n            selectedElement.scrollIntoView({\n                behavior: 'smooth',\n                block: 'nearest'\n            });\n        }\n    }\n\n    /**\n     * Clear event selection\n     */\n    clearSelection() {\n        this.selectedEventIndex = -1;\n        this.filteredEventElements.forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = -1;\n            }\n            if (window.dashboard.clearCardSelection) {\n                window.dashboard.clearCardSelection();\n            }\n        }\n\n        // Notify other components\n        document.dispatchEvent(new CustomEvent('eventSelectionCleared'));\n    }\n\n    /**\n     * Update metrics display\n     */\n    updateMetrics() {\n        // Update event type counts\n        this.eventTypeCount = {};\n        this.errorCount = 0;\n\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateMetrics');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            const type = event.type || 'unknown';\n            this.eventTypeCount[type] = (this.eventTypeCount[type] || 0) + 1;\n\n            if (event.type === 'log' &&\n                event.data &&\n                ['error', 'critical'].includes(event.data.level)) {\n                this.errorCount++;\n            }\n        });\n\n        // Update events per minute\n        const currentMinute = new Date().getMinutes();\n        if (currentMinute !== this.lastMinute) {\n            this.lastMinute = currentMinute;\n            this.eventsThisMinute = 0;\n        }\n\n        // Count events in the last minute\n        const oneMinuteAgo = new Date(Date.now() - 60000);\n        this.eventsThisMinute = this.events.filter(event =>\n            new Date(event.timestamp) > oneMinuteAgo\n        ).length;\n\n        // Update UI\n        this.updateMetricsUI();\n    }\n\n    /**\n     * Update metrics in the UI\n     */\n    updateMetricsUI() {\n        const totalEventsEl = document.getElementById('total-events');\n        const eventsPerMinuteEl = document.getElementById('events-per-minute');\n        const uniqueTypesEl = document.getElementById('unique-types');\n        const errorCountEl = document.getElementById('error-count');\n\n        if (totalEventsEl) totalEventsEl.textContent = this.events.length;\n        if (eventsPerMinuteEl) eventsPerMinuteEl.textContent = this.eventsThisMinute;\n        if (uniqueTypesEl) uniqueTypesEl.textContent = Object.keys(this.eventTypeCount).length;\n        if (errorCountEl) errorCountEl.textContent = this.errorCount;\n    }\n\n    /**\n     * Export events to JSON\n     */\n    exportEvents() {\n        const dataStr = JSON.stringify(this.filteredEvents, null, 2);\n        const dataBlob = new Blob([dataStr], { type: 'application/json' });\n        const url = URL.createObjectURL(dataBlob);\n\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = `claude-mpm-events-${new Date().toISOString().split('T')[0]}.json`;\n        link.click();\n\n        URL.revokeObjectURL(url);\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.socketClient.clearEvents();\n        this.selectedEventIndex = -1;\n        this.updateDisplay();\n    }\n\n    /**\n     * Set session filter\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSessionFilter(sessionId) {\n        this.sessionFilter = sessionId;\n        this.applyFilters();\n    }\n\n    /**\n     * Get current filter state\n     * @returns {Object} Current filters\n     */\n    getFilters() {\n        return {\n            search: this.searchFilter,\n            type: this.typeFilter,\n            session: this.sessionFilter\n        };\n    }\n\n    /**\n     * Get filtered events (used by HUD and other components)\n     * @returns {Array} Array of filtered events\n     */\n    getFilteredEvents() {\n        return this.filteredEvents;\n    }\n\n    /**\n     * Get all events (unfiltered, used by HUD for complete visualization)\n     * @returns {Array} Array of all events\n     */\n    getAllEvents() {\n        return this.events;\n    }\n\n    /**\n     * Create inline diff viewer for Edit/MultiEdit tool events\n     * WHY: Provides immediate visibility of file changes without needing to open modals\n     * DESIGN DECISION: Shows inline diffs only for Edit/MultiEdit events to avoid clutter\n     * @param {Object} event - Event object\n     * @param {number} index - Event index for unique IDs\n     * @returns {string} HTML for inline diff viewer\n     */\n    createInlineEditDiffViewer(event, index) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Only show for Edit and MultiEdit tools\n        if (!['Edit', 'MultiEdit'].includes(toolName)) {\n            return '';\n        }\n\n        // Extract edit parameters based on tool type\n        let edits = [];\n        if (toolName === 'Edit') {\n            // Single edit\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.old_string && parameters.new_string) {\n                edits.push({\n                    old_string: parameters.old_string,\n                    new_string: parameters.new_string,\n                    file_path: parameters.file_path || 'unknown'\n                });\n            }\n        } else if (toolName === 'MultiEdit') {\n            // Multiple edits\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.edits && Array.isArray(parameters.edits)) {\n                edits = parameters.edits.map(edit => ({\n                    ...edit,\n                    file_path: parameters.file_path || 'unknown'\n                }));\n            }\n        }\n\n        if (edits.length === 0) {\n            return '';\n        }\n\n        // Create collapsible diff section\n        const diffId = `edit-diff-${index}`;\n        const isMultiEdit = edits.length > 1;\n\n        let diffContent = '';\n        edits.forEach((edit, editIndex) => {\n            const editId = `${diffId}-${editIndex}`;\n            const diffHtml = this.createDiffHtml(edit.old_string, edit.new_string);\n\n            diffContent += `\n                <div class=\"edit-diff-section\">\n                    ${isMultiEdit ? `<div class=\"edit-diff-header\">Edit ${editIndex + 1}</div>` : ''}\n                    <div class=\"diff-content\">${diffHtml}</div>\n                </div>\n            `;\n        });\n\n        return `\n            <div class=\"inline-edit-diff-viewer\">\n                <div class=\"diff-toggle-header\" onclick=\"eventViewer.toggleEditDiff('${diffId}', event)\">\n                    <span class=\"diff-toggle-icon\">📋</span>\n                    <span class=\"diff-toggle-text\">Show ${isMultiEdit ? edits.length + ' edits' : 'edit'}</span>\n                    <span class=\"diff-toggle-arrow\">▼</span>\n                </div>\n                <div id=\"${diffId}\" class=\"diff-content-container\" style=\"display: none;\">\n                    ${diffContent}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create HTML diff visualization\n     * WHY: Provides clear visual representation of text changes similar to git diff\n     * @param {string} oldText - Original text\n     * @param {string} newText - Modified text\n     * @returns {string} HTML diff content\n     */\n    createDiffHtml(oldText, newText) {\n        // Simple line-by-line diff implementation\n        const oldLines = oldText.split('\\n');\n        const newLines = newText.split('\\n');\n\n        let diffHtml = '';\n        let i = 0, j = 0;\n\n        // Simple diff algorithm - can be enhanced with proper diff library if needed\n        while (i < oldLines.length || j < newLines.length) {\n            const oldLine = i < oldLines.length ? oldLines[i] : null;\n            const newLine = j < newLines.length ? newLines[j] : null;\n\n            if (oldLine === null) {\n                // New line added\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                j++;\n            } else if (newLine === null) {\n                // Old line removed\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n            } else if (oldLine === newLine) {\n                // Lines are the same\n                diffHtml += `<div class=\"diff-line diff-unchanged\">  ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n                j++;\n            } else {\n                // Lines are different - show both\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                i++;\n                j++;\n            }\n        }\n\n        return `<div class=\"diff-container\">${diffHtml}</div>`;\n    }\n\n    /**\n     * Toggle edit diff visibility\n     * @param {string} diffId - Diff container ID\n     * @param {Event} event - Click event\n     */\n    toggleEditDiff(diffId, event) {\n        // Prevent event bubbling to parent event item\n        event.stopPropagation();\n\n        const diffContainer = document.getElementById(diffId);\n        const arrow = event.currentTarget.querySelector('.diff-toggle-arrow');\n\n        if (diffContainer) {\n            const isVisible = diffContainer.style.display !== 'none';\n            diffContainer.style.display = isVisible ? 'none' : 'block';\n            if (arrow) {\n                arrow.textContent = isVisible ? '▼' : '▲';\n            }\n        }\n    }\n\n    /**\n     * Escape HTML characters for safe display\n     * @param {string} text - Text to escape\n     * @returns {string} Escaped text\n     */\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n}\n\n// ES6 Module export\nexport { EventViewer };\nexport default EventViewer;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.EventViewer = EventViewer;\n","/**\n * Event Processor Module\n *\n * Handles event processing, filtering, and rendering for different tabs in the dashboard.\n * Provides centralized event filtering and rendering logic for agents, tools, and files tabs.\n *\n * WHY: Extracted from main dashboard to isolate complex event processing logic\n * that involves filtering, transforming, and rendering events across different views.\n * This improves maintainability and makes the event processing logic testable.\n *\n * DESIGN DECISION: Maintains its own filtered event collections while relying on\n * eventViewer for source data. Provides separate filtering logic for each tab type\n * while sharing common filtering patterns and utilities.\n */\nclass EventProcessor {\n    constructor(eventViewer, agentInference) {\n        this.eventViewer = eventViewer;\n        this.agentInference = agentInference;\n\n        // Processed event collections for different tabs\n        this.agentEvents = [];\n        this.filteredAgentEvents = [];\n        this.filteredToolEvents = [];\n        this.filteredFileEvents = [];\n\n        // Session filtering\n        this.selectedSessionId = null;\n\n        // Git tracking status cache\n        this.fileTrackingCache = new Map(); // file_path -> {is_tracked: boolean, timestamp: number}\n        this.trackingCheckTimeout = 30000; // Cache for 30 seconds\n\n        console.log('Event processor initialized');\n    }\n\n    /**\n     * Get filtered events for a specific tab\n     * @param {string} tabName - Tab name ('agents', 'tools', 'files', 'events')\n     * @returns {Array} - Filtered events\n     */\n    getFilteredEventsForTab(tabName) {\n        const events = this.eventViewer.events;\n        console.log(`getFilteredEventsForTab(${tabName}) - using RAW events: ${events.length} total`);\n\n        // Use session manager to filter events by session if needed\n        const sessionManager = window.sessionManager;\n        if (sessionManager && sessionManager.selectedSessionId) {\n            const sessionEvents = sessionManager.getEventsForSession(sessionManager.selectedSessionId);\n            console.log(`Filtering by session ${sessionManager.selectedSessionId}: ${sessionEvents.length} events`);\n            return sessionEvents;\n        }\n\n        return events;\n    }\n\n    /**\n     * Apply agents tab filtering for unique instances\n     * @param {Array} uniqueInstances - Unique agent instances to filter\n     * @returns {Array} - Filtered unique instances\n     */\n    applyAgentsFilters(uniqueInstances) {\n        const searchInput = document.getElementById('agents-search-input');\n        const typeFilter = document.getElementById('agents-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return uniqueInstances.filter(instance => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    instance.agentName || '',\n                    instance.type || '',\n                    instance.isImplied ? 'implied' : 'explicit'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const agentName = instance.agentName || 'unknown';\n                if (!agentName.toLowerCase().includes(typeValue.toLowerCase())) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering\n     * @param {Array} events - Events to filter\n     * @returns {Array} - Filtered events\n     */\n    applyToolsFilters(events) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return events.filter(event => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    event.tool_name || '',\n                    event.agent_type || '',\n                    event.type || '',\n                    event.subtype || ''\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = event.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering for tool calls\n     * @param {Array} toolCallsArray - Tool calls array to filter\n     * @returns {Array} - Filtered tool calls\n     */\n    applyToolCallFilters(toolCallsArray) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return toolCallsArray.filter(([key, toolCall]) => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    toolCall.tool_name || '',\n                    toolCall.agent_type || '',\n                    'tool_call'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = toolCall.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply files tab filtering\n     * @param {Array} fileOperations - File operations to filter\n     * @returns {Array} - Filtered file operations\n     */\n    applyFilesFilters(fileOperations) {\n        const searchInput = document.getElementById('files-search-input');\n        const typeFilter = document.getElementById('files-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return fileOperations.filter(([filePath, fileData]) => {\n            // Session filter - filter operations within each file\n            if (this.selectedSessionId) {\n                // Filter operations for this file by session\n                const sessionOperations = fileData.operations.filter(op =>\n                    op.sessionId === this.selectedSessionId\n                );\n\n                // If no operations from this session, exclude the file\n                if (sessionOperations.length === 0) {\n                    return false;\n                }\n\n                // Update the fileData to only include session-specific operations\n                // (Note: This creates a filtered view without modifying the original)\n                fileData = {\n                    ...fileData,\n                    operations: sessionOperations,\n                    lastOperation: sessionOperations[sessionOperations.length - 1]?.timestamp || fileData.lastOperation\n                };\n            }\n\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    filePath,\n                    ...fileData.operations.map(op => op.operation),\n                    ...fileData.operations.map(op => op.agent)\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const operations = fileData.operations.map(op => op.operation);\n                if (!operations.includes(typeValue)) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Extract operation type from event type\n     * @param {string} eventType - Event type string\n     * @returns {string} - Operation type\n     */\n    extractOperation(eventType) {\n        if (!eventType) return 'unknown';\n\n        const type = eventType.toLowerCase();\n        if (type.includes('read')) return 'read';\n        if (type.includes('write')) return 'write';\n        if (type.includes('edit')) return 'edit';\n        if (type.includes('create')) return 'create';\n        if (type.includes('delete')) return 'delete';\n        if (type.includes('move') || type.includes('rename')) return 'move';\n\n        return 'other';\n    }\n\n    /**\n     * Extract tool name from hook event type\n     * @param {string} eventType - Hook event type\n     * @returns {string} - Tool name\n     */\n    extractToolFromHook(eventType) {\n        if (!eventType) return '';\n\n        // Pattern: Pre{ToolName}Use or Post{ToolName}Use\n        const match = eventType.match(/^(?:Pre|Post)(.+)Use$/);\n        return match ? match[1] : '';\n    }\n\n    /**\n     * Extract tool name from subtype\n     * @param {string} subtype - Event subtype\n     * @returns {string} - Tool name\n     */\n    extractToolFromSubtype(subtype) {\n        if (!subtype) return '';\n\n        // Handle various subtype patterns\n        if (subtype.includes('_')) {\n            const parts = subtype.split('_');\n            return parts[0] || '';\n        }\n\n        return subtype;\n    }\n\n    /**\n     * Extract target information from tool parameters\n     * @param {string} toolName - Tool name\n     * @param {Object} params - Tool parameters\n     * @param {Object} toolParameters - Alternative tool parameters\n     * @returns {string} - Target information\n     */\n    extractToolTarget(toolName, params, toolParameters) {\n        const parameters = params || toolParameters || {};\n\n        switch (toolName?.toLowerCase()) {\n            case 'read':\n            case 'write':\n            case 'edit':\n                return parameters.file_path || parameters.path || '';\n            case 'bash':\n                return parameters.command || '';\n            case 'grep':\n                return parameters.pattern || '';\n            case 'task':\n                return parameters.subagent_type || parameters.agent_type || '';\n            default:\n                // Try to find a meaningful parameter\n                const keys = Object.keys(parameters);\n                const meaningfulKeys = ['path', 'file_path', 'command', 'pattern', 'query', 'target'];\n                for (const key of meaningfulKeys) {\n                    if (parameters[key]) {\n                        return parameters[key];\n                    }\n                }\n                return keys.length > 0 ? `${keys[0]}: ${parameters[keys[0]]}` : '';\n        }\n    }\n\n    /**\n     * Generate HTML for unique agent instances (one row per PM delegation)\n     * @param {Array} events - Agent events to render (not used, kept for compatibility)\n     * @returns {string} - HTML string\n     */\n    generateAgentHTML(events) {\n        // Get unique agent instances from agent inference\n        const uniqueInstances = this.agentInference.getUniqueAgentInstances();\n\n        // Apply filtering\n        const filteredInstances = this.applyAgentsFilters(uniqueInstances);\n\n        return filteredInstances.map((instance, index) => {\n            const agentName = instance.agentName;\n            const timestamp = this.formatTimestamp(instance.firstTimestamp || instance.timestamp);\n            const delegationType = instance.isImplied ? 'implied' : 'explicit';\n            // Fix: Use totalEventCount which is the actual property name from getUniqueAgentInstances()\n            const eventCount = instance.totalEventCount || instance.eventCount || 0;\n\n            const onclickString = `dashboard.selectCard('agents', ${index}, 'agent_instance', '${instance.id}'); dashboard.showAgentInstanceDetails('${instance.id}');`;\n\n            // Format: \"[Agent Name] (delegationType, eventCount events)\" with separate timestamp\n            const agentMainContent = `${agentName} (${delegationType}, ${eventCount} events)`;\n\n            return `\n                <div class=\"event-item single-row event-agent\" onclick=\"${onclickString}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${agentMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for tool events\n     * @param {Array} toolCalls - Tool calls to render\n     * @returns {string} - HTML string\n     */\n    generateToolHTML(toolCalls) {\n        const filteredToolCalls = this.applyToolCallFilters(toolCalls);\n\n        return filteredToolCalls.map(([key, toolCall], index) => {\n            const toolName = toolCall.tool_name || 'Unknown';\n            const rawAgent = toolCall.agent_type || 'Unknown';\n            const timestamp = this.formatTimestamp(toolCall.timestamp);\n            const status = toolCall.post_event ? 'completed' : 'pending';\n            const statusClass = status === 'completed' ? 'status-success' : 'status-pending';\n\n            // Convert agent name: show \"pm\" for PM agent, otherwise show actual agent name\n            const agentName = rawAgent.toLowerCase() === 'pm' ? 'pm' : rawAgent;\n\n            // Format: \"Tool Name (Agent Name)\" - removed duration from main display\n            const toolMainContent = `${toolName} (${agentName})`;\n\n            return `\n                <div class=\"event-item single-row event-tool ${statusClass}\" onclick=\"dashboard.selectCard('tools', ${index}, 'toolCall', '${key}'); dashboard.showToolCallDetails('${key}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${toolMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for file operations\n     * @param {Array} fileOperations - File operations to render\n     * @returns {string} - HTML string\n     */\n    generateFileHTML(fileOperations) {\n        const filteredFiles = this.applyFilesFilters(fileOperations);\n\n        return filteredFiles.map(([filePath, fileData], index) => {\n            const operations = fileData.operations.map(op => op.operation);\n            const timestamp = this.formatTimestamp(fileData.lastOperation);\n\n            // Count operations by type for display: \"read(2), write(1)\"\n            const operationCounts = {};\n            operations.forEach(op => {\n                operationCounts[op] = (operationCounts[op] || 0) + 1;\n            });\n\n            const operationSummary = Object.entries(operationCounts)\n                .map(([op, count]) => `${op}(${count})`)\n                .join(', ');\n\n            // Get unique agents that worked on this file\n            const uniqueAgents = [...new Set(fileData.operations.map(op => op.agent))];\n            const agentSummary = uniqueAgents.length > 1 ? `by ${uniqueAgents.length} agents` : `by ${uniqueAgents[0] || 'unknown'}`;\n\n            // Format: \"[file path] read(2), write(1) by agent\" with separate timestamp\n            const fileName = this.getRelativeFilePath(filePath);\n            const fileMainContent = `${fileName} ${operationSummary} ${agentSummary}`;\n\n            return `\n                <div class=\"event-item single-row file-item\" onclick=\"dashboard.selectCard('files', ${index}, 'file', '${filePath}'); dashboard.showFileDetails('${filePath}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${fileMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Get icon for file operations\n     * @param {Array} operations - Array of operations\n     * @returns {string} - Icon representation\n     */\n    getFileOperationIcon(operations) {\n        if (operations.includes('write') || operations.includes('create')) return '📝';\n        if (operations.includes('edit')) return '✏️';\n        if (operations.includes('read')) return '👁️';\n        if (operations.includes('delete')) return '🗑️';\n        if (operations.includes('move')) return '📦';\n        return '📄';\n    }\n\n    /**\n     * Get relative file path\n     * @param {string} filePath - Full file path\n     * @returns {string} - Relative path\n     */\n    getRelativeFilePath(filePath) {\n        if (!filePath) return '';\n\n        // Simple relative path logic - can be enhanced\n        const parts = filePath.split('/');\n        if (parts.length > 3) {\n            return '.../' + parts.slice(-2).join('/');\n        }\n        return filePath;\n    }\n\n    /**\n     * Format timestamp for display\n     * @param {string|number} timestamp - Timestamp to format\n     * @returns {string} - Formatted timestamp\n     */\n    formatTimestamp(timestamp) {\n        if (!timestamp) return '';\n\n        const date = new Date(timestamp);\n        return date.toLocaleTimeString();\n    }\n\n    /**\n     * Set selected session ID for filtering\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSelectedSessionId(sessionId) {\n        this.selectedSessionId = sessionId;\n    }\n\n    /**\n     * Get selected session ID\n     * @returns {string|null} - Current session ID\n     */\n    getSelectedSessionId() {\n        return this.selectedSessionId;\n    }\n\n    /**\n     * Get unique tool instances (one row per unique tool call)\n     * This deduplicates tool calls to show unique instances only\n     * @param {Array} toolCallsArray - Tool calls array\n     * @returns {Array} - Unique tool instances\n     */\n    getUniqueToolInstances(toolCallsArray) {\n        // The toolCallsArray already represents unique tool calls\n        // since it's generated from paired pre/post events in FileToolTracker\n        // Just apply filtering and return\n        return this.applyToolCallFilters(toolCallsArray);\n    }\n\n    /**\n     * Get unique file instances (one row per unique file)\n     * This aggregates all operations on each file\n     * @param {Array} fileOperations - File operations array\n     * @returns {Array} - Unique file instances (same as input since already unique per file)\n     */\n    getUniqueFileInstances(fileOperations) {\n        // The fileOperations array already represents unique files\n        // since it's keyed by file path in FileToolTracker\n        // Just apply filtering and return\n        return this.applyFilesFilters(fileOperations);\n    }\n\n    /**\n     * Check if a file is tracked by git (with caching)\n     * @param {string} filePath - Path to the file\n     * @param {string} workingDir - Working directory\n     * @returns {Promise<boolean>} - Promise resolving to tracking status\n     */\n    async isFileTracked(filePath, workingDir) {\n        const cacheKey = `${workingDir}:${filePath}`;\n        const now = Date.now();\n\n        // Check cache first\n        const cached = this.fileTrackingCache.get(cacheKey);\n        if (cached && (now - cached.timestamp) < this.trackingCheckTimeout) {\n            return cached.is_tracked;\n        }\n\n        try {\n            // Use the socketio connection to check tracking status\n            const socket = window.socket;\n            if (!socket) {\n                console.warn('No socket connection available for git tracking check');\n                return false;\n            }\n\n            return new Promise((resolve) => {\n                // Set up one-time listener for response\n                const responseHandler = (data) => {\n                    if (data.file_path === filePath) {\n                        const isTracked = data.success && data.is_tracked;\n\n                        // Cache the result\n                        this.fileTrackingCache.set(cacheKey, {\n                            is_tracked: isTracked,\n                            timestamp: now\n                        });\n\n                        socket.off('file_tracked_response', responseHandler);\n                        resolve(isTracked);\n                    }\n                };\n\n                socket.on('file_tracked_response', responseHandler);\n\n                // Send request\n                socket.emit('check_file_tracked', {\n                    file_path: filePath,\n                    working_dir: workingDir\n                });\n\n                // Timeout after 5 seconds\n                setTimeout(() => {\n                    socket.off('file_tracked_response', responseHandler);\n                    resolve(false); // Default to not tracked on timeout\n                }, 5000);\n            });\n\n        } catch (error) {\n            console.error('Error checking file tracking status:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Generate git diff icon with tracking status\n     * @param {string} filePath - Path to the file\n     * @param {string} timestamp - Operation timestamp\n     * @param {string} workingDir - Working directory\n     * @returns {string} - HTML for git diff icon\n     */\n    generateGitDiffIcon(filePath, timestamp, workingDir) {\n        const iconId = `git-icon-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}-${timestamp}`;\n\n        // Initially show default icon\n        const iconHtml = `\n            <span id=\"${iconId}\" class=\"git-diff-icon\"\n                  onclick=\"event.stopPropagation(); showGitDiffModal('${filePath}', '${timestamp}')\"\n                  title=\"View git diff for this file operation\"\n                  style=\"margin-left: 8px; cursor: pointer; font-size: 16px;\">\n                📋\n            </span>\n        `;\n\n        // Asynchronously check tracking status and update icon\n        this.isFileTracked(filePath, workingDir).then(isTracked => {\n            const iconElement = document.getElementById(iconId);\n            if (iconElement) {\n                if (!isTracked) {\n                    // File is not tracked - show crossed out icon\n                    iconElement.innerHTML = '📋❌';\n                    iconElement.title = 'File not tracked by git - click to see details';\n                    iconElement.classList.add('untracked-file');\n                } else {\n                    // File is tracked - keep normal icon\n                    iconElement.innerHTML = '📋';\n                    iconElement.title = 'View git diff for this file operation';\n                    iconElement.classList.add('tracked-file');\n                }\n            }\n        }).catch(error => {\n            console.error('Error updating git diff icon:', error);\n        });\n\n        return iconHtml;\n    }\n\n    /**\n     * Show agent instance details for unique instance view\n     * @param {string} instanceId - Agent instance ID\n     */\n    showAgentInstanceDetails(instanceId) {\n        const pmDelegations = this.agentInference.getPMDelegations();\n        const instance = pmDelegations.get(instanceId);\n\n        if (!instance) {\n            console.error('Agent instance not found:', instanceId);\n            return;\n        }\n\n        // Show details about this PM delegation and its events\n        console.log('Showing agent instance details for:', instanceId, instance);\n\n        // This would integrate with the existing detail view system\n        // For now, just log the details - can be expanded to show in a modal/sidebar\n        const detailsHtml = `\n            <div class=\"agent-instance-details\">\n                <h3>Agent Instance: ${instance.agentName}</h3>\n                <p><strong>Type:</strong> ${instance.isImplied ? 'Implied PM Delegation' : 'Explicit PM Delegation'}</p>\n                <p><strong>Start Time:</strong> ${this.formatTimestamp(instance.timestamp)}</p>\n                <p><strong>Event Count:</strong> ${instance.agentEvents.length}</p>\n                <p><strong>Session:</strong> ${instance.sessionId}</p>\n                ${instance.pmCall ? `<p><strong>PM Call:</strong> Task delegation to ${instance.agentName}</p>` : '<p><strong>Note:</strong> Implied delegation (no explicit PM call found)</p>'}\n            </div>\n        `;\n\n        // You would integrate this with your existing detail display system\n        console.log('Agent instance details HTML:', detailsHtml);\n    }\n}\n\n// ES6 Module export\nexport { EventProcessor };\nexport default EventProcessor;\n"],"names":["EventViewer","constructor","containerId","socketClient","this","container","document","getElementById","events","filteredEvents","selectedEventIndex","filteredEventElements","autoScroll","searchFilter","typeFilter","sessionFilter","eventTypeCount","availableEventTypes","Set","errorCount","eventsThisMinute","lastMinute","Date","getMinutes","init","setupEventHandlers","setupKeyboardNavigation","onEventUpdate","sessions","Array","isArray","updateDisplay","searchInput","addEventListener","e","target","value","toLowerCase","applyFilters","console","log","handleArrowNavigation","direction","length","newIndex","showEventDetails","warn","filter","event","type","subtype","JSON","stringify","data","join","includes","eventType","trim","session_id","renderEvents","updateMetrics","updateEventTypeDropdown","dropdown","eventTypes","forEach","fullType","add","currentTypes","from","sort","previousTypes","currentSelection","innerHTML","option","createElement","textContent","appendChild","has","eventsList","html","map","index","timestamp","toLocaleTimeString","formatSingleRowEventContent","createInlineEditDiffViewer","querySelectorAll","window","dashboard","currentTab","tabNavigation","items","scrollTop","scrollHeight","formatEventType","originalEventName","formatEventData","formatSessionEvent","formatClaudeEvent","formatAgentEvent","formatHookEvent","formatTodoEvent","formatMemoryEvent","formatLogEvent","formatGenericEvent","prompt","message","substring","response","content","agent_type","name","event_type","prompt_text","prompt_preview","toolName","tool_name","operation_type","postToolName","success","status","duration_ms","notification_type","message_preview","reason","stop_type","hookName","hook_name","todos","count","operation","key","level","truncated","toUpperCase","eventDetails","category","hookType","hookDisplayName","getHookDisplayName","getEventCategory","subagent_type","hookNames","pre_tool","post_tool","user_prompt","stop","subagent_stop","notification","String","replace","selectedIndex","selectCard","el","i","classList","toggle","dispatchEvent","CustomEvent","detail","selectedElement","scrollIntoView","behavior","block","clearSelection","remove","clearCardSelection","currentMinute","oneMinuteAgo","now","updateMetricsUI","totalEventsEl","eventsPerMinuteEl","uniqueTypesEl","errorCountEl","Object","keys","exportEvents","dataStr","dataBlob","Blob","url","URL","createObjectURL","link","href","download","toISOString","split","click","revokeObjectURL","clearEvents","setSessionFilter","sessionId","getFilters","search","session","getFilteredEvents","getAllEvents","edits","parameters","tool_parameters","old_string","new_string","push","file_path","edit","diffId","isMultiEdit","diffContent","editIndex","diffHtml","createDiffHtml","oldText","newText","oldLines","newLines","j","oldLine","newLine","escapeHtml","toggleEditDiff","stopPropagation","diffContainer","arrow","currentTarget","querySelector","isVisible","style","display","text","div","EventProcessor","eventViewer","agentInference","agentEvents","filteredAgentEvents","filteredToolEvents","filteredFileEvents","selectedSessionId","fileTrackingCache","Map","trackingCheckTimeout","getFilteredEventsForTab","tabName","sessionManager","sessionEvents","getEventsForSession","applyAgentsFilters","uniqueInstances","searchText","typeValue","instance","agentName","isImplied","applyToolsFilters","applyToolCallFilters","toolCallsArray","toolCall","applyFilesFilters","fileOperations","filePath","fileData","sessionOperations","operations","op","lastOperation","agent","extractOperation","extractToolFromHook","match","extractToolFromSubtype","extractToolTarget","params","toolParameters","path","command","pattern","meaningfulKeys","generateAgentHTML","getUniqueAgentInstances","formatTimestamp","firstTimestamp","delegationType","eventCount","totalEventCount","id","generateToolHTML","toolCalls","rawAgent","post_event","generateFileHTML","operationCounts","operationSummary","entries","uniqueAgents","agentSummary","getRelativeFilePath","getFileOperationIcon","parts","slice","setSelectedSessionId","getSelectedSessionId","getUniqueToolInstances","getUniqueFileInstances","isFileTracked","workingDir","cacheKey","cached","get","is_tracked","socket","Promise","resolve","responseHandler","isTracked","set","off","on","emit","working_dir","setTimeout","error","generateGitDiffIcon","iconId","iconHtml","then","iconElement","title","catch","showAgentInstanceDetails","instanceId","getPMDelegations","detailsHtml","pmCall"],"mappings":"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"}