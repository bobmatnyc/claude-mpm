{"version":3,"file":"event-viewer.js","sources":["../../js/components/event-viewer.js","../../js/components/event-processor.js"],"sourcesContent":["/**\n * Event Viewer Component\n * Handles event display, filtering, and selection\n */\n\nclass EventViewer {\n    constructor(containerId, socketClient) {\n        this.container = document.getElementById(containerId);\n        this.socketClient = socketClient;\n\n        // State\n        this.events = [];\n        this.filteredEvents = [];\n        this.selectedEventIndex = -1;\n        this.filteredEventElements = [];\n        this.autoScroll = true;\n\n        // Filters\n        this.searchFilter = '';\n        this.typeFilter = '';\n        this.sessionFilter = '';\n\n        // Event type tracking\n        this.eventTypeCount = {};\n        this.availableEventTypes = new Set();\n        this.errorCount = 0;\n        this.eventsThisMinute = 0;\n        this.lastMinute = new Date().getMinutes();\n\n        this.init();\n    }\n\n    /**\n     * Initialize the event viewer\n     */\n    init() {\n        this.setupEventHandlers();\n        this.setupKeyboardNavigation();\n\n        // Subscribe to socket events\n        this.socketClient.onEventUpdate((events, sessions) => {\n            // Ensure we always have a valid events array\n            this.events = Array.isArray(events) ? events : [];\n            this.updateDisplay();\n        });\n    }\n\n    /**\n     * Setup event handlers for UI controls\n     */\n    setupEventHandlers() {\n        // Search input\n        const searchInput = document.getElementById('events-search-input');\n        if (searchInput) {\n            searchInput.addEventListener('input', (e) => {\n                this.searchFilter = e.target.value.toLowerCase();\n                this.applyFilters();\n            });\n        }\n\n        // Type filter\n        const typeFilter = document.getElementById('events-type-filter');\n        if (typeFilter) {\n            typeFilter.addEventListener('change', (e) => {\n                this.typeFilter = e.target.value;\n                this.applyFilters();\n            });\n        }\n    }\n\n    /**\n     * Setup keyboard navigation for events\n     * Note: This is now handled by the unified Dashboard navigation system\n     */\n    setupKeyboardNavigation() {\n        // Keyboard navigation is now handled by Dashboard.setupUnifiedKeyboardNavigation()\n        // This method is kept for backward compatibility but does nothing\n    }\n\n    /**\n     * Handle arrow key navigation\n     * @param {number} direction - Direction: 1 for down, -1 for up\n     */\n    handleArrowNavigation(direction) {\n        if (this.filteredEventElements.length === 0) return;\n\n        // Calculate new index\n        let newIndex = this.selectedEventIndex + direction;\n\n        // Wrap around\n        if (newIndex >= this.filteredEventElements.length) {\n            newIndex = 0;\n        } else if (newIndex < 0) {\n            newIndex = this.filteredEventElements.length - 1;\n        }\n\n        this.showEventDetails(newIndex);\n    }\n\n    /**\n     * Apply filters to events\n     */\n    applyFilters() {\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized, using empty array');\n            this.events = [];\n        }\n\n        this.filteredEvents = this.events.filter(event => {\n            // NO AUTOMATIC FILTERING - All events are shown by default for complete visibility\n            // Users can apply their own filters using the search and type filter controls\n            \n            // User-controlled search filter\n            if (this.searchFilter) {\n                const searchableText = [\n                    event.type || '',\n                    event.subtype || '',\n                    JSON.stringify(event.data || {})\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(this.searchFilter)) {\n                    return false;\n                }\n            }\n\n            // User-controlled type filter - handles full hook types (like \"hook.user_prompt\") and main types\n            if (this.typeFilter) {\n                // Use the same logic as formatEventType to get the full event type\n                const eventType = event.type && event.type.trim() !== '' ? event.type : '';\n                const fullEventType = event.subtype && eventType ? `${eventType}.${event.subtype}` : eventType;\n                if (fullEventType !== this.typeFilter) {\n                    return false;\n                }\n            }\n\n            // User-controlled session filter\n            if (this.sessionFilter && this.sessionFilter !== '') {\n                if (!event.data || event.data.session_id !== this.sessionFilter) {\n                    return false;\n                }\n            }\n\n            // Allow all events through unless filtered by user controls\n            return true;\n        });\n\n        this.renderEvents();\n        this.updateMetrics();\n    }\n\n    /**\n     * Update available event types and populate dropdown\n     */\n    updateEventTypeDropdown() {\n        const dropdown = document.getElementById('events-type-filter');\n        if (!dropdown) return;\n\n        // Extract unique event types from current events\n        // Use the same logic as formatEventType to get full event type names\n        const eventTypes = new Set();\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateEventTypeDropdown');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            if (event.type && event.type.trim() !== '') {\n                // Combine type and subtype if subtype exists, otherwise just use type\n                const fullType = event.subtype ? `${event.type}.${event.subtype}` : event.type;\n                eventTypes.add(fullType);\n            }\n        });\n\n        // Check if event types have changed\n        const currentTypes = Array.from(eventTypes).sort();\n        const previousTypes = Array.from(this.availableEventTypes).sort();\n\n        if (JSON.stringify(currentTypes) === JSON.stringify(previousTypes)) {\n            return; // No change needed\n        }\n\n        // Update our tracking\n        this.availableEventTypes = eventTypes;\n\n        // Store the current selection\n        const currentSelection = dropdown.value;\n\n        // Clear existing options except \"All Events\"\n        dropdown.innerHTML = '<option value=\"\">All Events</option>';\n\n        // Add new options sorted alphabetically\n        const sortedTypes = Array.from(eventTypes).sort();\n        sortedTypes.forEach(type => {\n            const option = document.createElement('option');\n            option.value = type;\n            option.textContent = type;\n            dropdown.appendChild(option);\n        });\n\n        // Restore selection if it still exists\n        if (currentSelection && eventTypes.has(currentSelection)) {\n            dropdown.value = currentSelection;\n        } else if (currentSelection && !eventTypes.has(currentSelection)) {\n            // If the previously selected type no longer exists, clear the filter\n            dropdown.value = '';\n            this.typeFilter = '';\n        }\n    }\n\n    /**\n     * Update the display with current events\n     */\n    updateDisplay() {\n        this.updateEventTypeDropdown();\n        this.applyFilters();\n    }\n\n    /**\n     * Render events in the UI\n     */\n    renderEvents() {\n        const eventsList = document.getElementById('events-list');\n        if (!eventsList) return;\n\n        // Check if user is at bottom BEFORE rendering (for autoscroll decision)\n        const wasAtBottom = (eventsList.scrollTop + eventsList.clientHeight >= eventsList.scrollHeight - 10);\n\n        if (this.filteredEvents.length === 0) {\n            eventsList.innerHTML = `\n                <div class=\"no-events\">\n                    ${this.events.length === 0 ?\n                        'Connect to Socket.IO server to see events...' :\n                        'No events match current filters...'}\n                </div>\n            `;\n            this.filteredEventElements = [];\n            return;\n        }\n\n        const html = this.filteredEvents.map((event, index) => {\n            const timestamp = new Date(event.timestamp).toLocaleTimeString();\n            const eventClass = event.type ? `event-${event.type}` : 'event-default';\n            const isSelected = index === this.selectedEventIndex;\n\n            // Get main content and timestamp separately\n            const mainContent = this.formatSingleRowEventContent(event);\n\n            // Check if this is an Edit/MultiEdit tool event and add diff viewer\n            const diffViewer = this.createInlineEditDiffViewer(event, index);\n\n            return `\n                <div class=\"event-item single-row ${eventClass} ${isSelected ? 'selected' : ''}\"\n                     onclick=\"eventViewer.showEventDetails(${index})\"\n                     data-index=\"${index}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${mainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                    ${diffViewer}\n                </div>\n            `;\n        }).join('');\n\n        eventsList.innerHTML = html;\n\n        // Update filtered elements reference\n        this.filteredEventElements = Array.from(eventsList.querySelectorAll('.event-item'));\n\n        // Update Dashboard navigation items if we're in the events tab\n        if (window.dashboard && window.dashboard.currentTab === 'events' &&\n            window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n            window.dashboard.tabNavigation.events.items = this.filteredEventElements;\n        }\n\n        // Auto-scroll only if user was already at bottom before rendering\n        if (this.filteredEvents.length > 0 && wasAtBottom && this.autoScroll) {\n            // Use requestAnimationFrame to ensure DOM has updated\n            requestAnimationFrame(() => {\n                eventsList.scrollTop = eventsList.scrollHeight;\n            });\n        }\n    }\n\n    /**\n     * Format event type for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event type\n     */\n    formatEventType(event) {\n        // If we have type and subtype, use them\n        if (event.type && event.subtype) {\n            // Check if type and subtype are identical or subtype is 'generic' to prevent redundant display\n            if (event.type === event.subtype || event.subtype === 'generic') {\n                return event.type;\n            }\n            return `${event.type}.${event.subtype}`;\n        }\n        // If we have just type, use it\n        if (event.type) {\n            return event.type;\n        }\n        // If we have originalEventName (from transformation), use it as fallback\n        if (event.originalEventName) {\n            return event.originalEventName;\n        }\n        // Last resort fallback\n        return 'unknown';\n    }\n\n    /**\n     * Format event data for display\n     * @param {Object} event - Event object\n     * @returns {string} Formatted event data\n     */\n    formatEventData(event) {\n        if (!event.data) return 'No data';\n\n        // Special formatting for different event types\n        switch (event.type) {\n            case 'session':\n                return this.formatSessionEvent(event);\n            case 'claude':\n                return this.formatClaudeEvent(event);\n            case 'agent':\n                return this.formatAgentEvent(event);\n            case 'hook':\n                return this.formatHookEvent(event);\n            case 'todo':\n                return this.formatTodoEvent(event);\n            case 'memory':\n                return this.formatMemoryEvent(event);\n            case 'log':\n                return this.formatLogEvent(event);\n            case 'code':\n                return this.formatCodeEvent(event);\n            default:\n                return this.formatGenericEvent(event);\n        }\n    }\n\n    /**\n     * Format session event data\n     */\n    formatSessionEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'started') {\n            return `<strong>Session started:</strong> ${data.session_id || 'Unknown'}`;\n        } else if (event.subtype === 'ended') {\n            return `<strong>Session ended:</strong> ${data.session_id || 'Unknown'}`;\n        }\n        return `<strong>Session:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format Claude event data\n     */\n    formatClaudeEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'request') {\n            const prompt = data.prompt || data.message || '';\n            const truncated = prompt.length > 100 ? prompt.substring(0, 100) + '...' : prompt;\n            return `<strong>Request:</strong> ${truncated}`;\n        } else if (event.subtype === 'response') {\n            const response = data.response || data.content || '';\n            const truncated = response.length > 100 ? response.substring(0, 100) + '...' : response;\n            return `<strong>Response:</strong> ${truncated}`;\n        }\n        return `<strong>Claude:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format agent event data\n     */\n    formatAgentEvent(event) {\n        const data = event.data;\n        if (event.subtype === 'loaded') {\n            return `<strong>Agent loaded:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        } else if (event.subtype === 'executed') {\n            return `<strong>Agent executed:</strong> ${data.agent_type || data.name || 'Unknown'}`;\n        }\n        return `<strong>Agent:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format hook event data\n     */\n    formatHookEvent(event) {\n        const data = event.data;\n        const eventType = data.event_type || event.subtype || 'unknown';\n\n        // Format based on specific hook event type\n        switch (eventType) {\n            case 'user_prompt':\n                const prompt = data.prompt_text || data.prompt_preview || '';\n                const truncated = prompt.length > 80 ? prompt.substring(0, 80) + '...' : prompt;\n                return `<strong>User Prompt:</strong> ${truncated || 'No prompt text'}`;\n\n            case 'pre_tool':\n                const toolName = data.tool_name || 'Unknown tool';\n                const operation = data.operation_type || 'operation';\n                return `<strong>Pre-Tool (${operation}):</strong> ${toolName}`;\n\n            case 'post_tool':\n                const postToolName = data.tool_name || 'Unknown tool';\n                const status = data.success ? 'success' : data.status || 'failed';\n                const duration = data.duration_ms ? ` (${data.duration_ms}ms)` : '';\n                return `<strong>Post-Tool (${status}):</strong> ${postToolName}${duration}`;\n\n            case 'notification':\n                const notifType = data.notification_type || 'notification';\n                const message = data.message_preview || data.message || 'No message';\n                return `<strong>Notification (${notifType}):</strong> ${message}`;\n\n            case 'stop':\n                const reason = data.reason || 'unknown';\n                const stopType = data.stop_type || 'normal';\n                return `<strong>Stop (${stopType}):</strong> ${reason}`;\n\n            case 'subagent_start':\n                // Try multiple locations for agent type\n                const startAgentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                const startPrompt = data.prompt || data.description || data.task || 'No description';\n                const startTruncated = startPrompt.length > 60 ? startPrompt.substring(0, 60) + '...' : startPrompt;\n                // Format with proper agent type display\n                const startAgentDisplay = this.formatAgentType(startAgentType);\n                return `<strong>Subagent Start (${startAgentDisplay}):</strong> ${startTruncated}`;\n\n            case 'subagent_stop':\n                // Try multiple locations for agent type\n                const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                const stopReason = data.reason || data.stop_reason || 'completed';\n                // Format with proper agent type display\n                const stopAgentDisplay = this.formatAgentType(agentType);\n                // Include task completion status if available\n                const isCompleted = data.structured_response?.task_completed;\n                const completionStatus = isCompleted !== undefined ? (isCompleted ? ' ✓' : ' ✗') : '';\n                return `<strong>Subagent Stop (${stopAgentDisplay})${completionStatus}:</strong> ${stopReason}`;\n\n            default:\n                // Fallback to original logic for unknown hook types\n                const hookName = data.hook_name || data.name || data.event_type || 'Unknown';\n                const phase = event.subtype || eventType;\n                return `<strong>Hook ${phase}:</strong> ${hookName}`;\n        }\n    }\n\n    /**\n     * Format todo event data\n     */\n    formatTodoEvent(event) {\n        const data = event.data;\n        if (data.todos && Array.isArray(data.todos)) {\n            const count = data.todos.length;\n            return `<strong>Todo updated:</strong> ${count} item${count !== 1 ? 's' : ''}`;\n        }\n        return `<strong>Todo:</strong> ${JSON.stringify(data)}`;\n    }\n\n    /**\n     * Format memory event data\n     */\n    formatMemoryEvent(event) {\n        const data = event.data;\n        const operation = data.operation || 'unknown';\n        return `<strong>Memory ${operation}:</strong> ${data.key || 'Unknown key'}`;\n    }\n\n    /**\n     * Format log event data\n     */\n    formatLogEvent(event) {\n        const data = event.data;\n        const level = data.level || 'info';\n        const message = data.message || '';\n        const truncated = message.length > 80 ? message.substring(0, 80) + '...' : message;\n        return `<strong>[${level.toUpperCase()}]</strong> ${truncated}`;\n    }\n\n    /**\n     * Format code analysis event data\n     */\n    formatCodeEvent(event) {\n        const data = event.data || {};\n        \n        // Handle different code event subtypes\n        if (event.subtype === 'progress') {\n            const message = data.message || 'Processing...';\n            const percentage = data.percentage;\n            if (percentage !== undefined) {\n                return `<strong>Progress:</strong> ${message} (${Math.round(percentage)}%)`;\n            }\n            return `<strong>Progress:</strong> ${message}`;\n        } else if (event.subtype === 'analysis:queued') {\n            return `<strong>Queued:</strong> Analysis for ${data.path || 'Unknown path'}`;\n        } else if (event.subtype === 'analysis:start') {\n            return `<strong>Started:</strong> Analyzing ${data.path || 'Unknown path'}`;\n        } else if (event.subtype === 'analysis:complete') {\n            const duration = data.duration ? ` (${data.duration.toFixed(2)}s)` : '';\n            return `<strong>Complete:</strong> Analysis finished${duration}`;\n        } else if (event.subtype === 'analysis:error') {\n            return `<strong>Error:</strong> ${data.message || 'Analysis failed'}`;\n        } else if (event.subtype === 'analysis:cancelled') {\n            return `<strong>Cancelled:</strong> Analysis stopped for ${data.path || 'Unknown path'}`;\n        } else if (event.subtype === 'file:start') {\n            return `<strong>File:</strong> Processing ${data.file || 'Unknown file'}`;\n        } else if (event.subtype === 'file:complete') {\n            const nodes = data.nodes_count !== undefined ? ` (${data.nodes_count} nodes)` : '';\n            return `<strong>File done:</strong> ${data.file || 'Unknown file'}${nodes}`;\n        } else if (event.subtype === 'node:found') {\n            return `<strong>Node:</strong> Found ${data.node_type || 'element'} \"${data.name || 'unnamed'}\"`;\n        } else if (event.subtype === 'error') {\n            return `<strong>Error:</strong> ${data.error || 'Unknown error'} in ${data.file || 'file'}`;\n        }\n        \n        // Generic fallback for code events\n        const json = JSON.stringify(data);\n        return `<strong>Code:</strong> ${json.length > 100 ? json.substring(0, 100) + '...' : json}`;\n    }\n\n    /**\n     * Format generic event data\n     */\n    formatGenericEvent(event) {\n        const data = event.data;\n        if (typeof data === 'string') {\n            return data.length > 100 ? data.substring(0, 100) + '...' : data;\n        }\n        return JSON.stringify(data);\n    }\n\n    /**\n     * Format agent type for display with proper capitalization\n     * @param {string} agentType - The raw agent type string\n     * @returns {string} Formatted agent type for display\n     */\n    formatAgentType(agentType) {\n        // Handle common agent type patterns\n        const agentTypeMap = {\n            'research': 'Research',\n            'architect': 'Architect',\n            'engineer': 'Engineer',\n            'qa': 'QA',\n            'pm': 'PM',\n            'project_manager': 'PM',\n            'research_agent': 'Research',\n            'architect_agent': 'Architect',\n            'engineer_agent': 'Engineer',\n            'qa_agent': 'QA',\n            'unknown': 'Unknown'\n        };\n        \n        // Try to find a match in the map (case-insensitive)\n        const lowerType = (agentType || 'unknown').toLowerCase();\n        if (agentTypeMap[lowerType]) {\n            return agentTypeMap[lowerType];\n        }\n        \n        // If not in map, try to extract the agent name from patterns like \"Research Agent\" or \"research_agent\"\n        const match = agentType.match(/^(\\w+)(?:_agent|Agent)?$/i);\n        if (match && match[1]) {\n            // Capitalize first letter\n            return match[1].charAt(0).toUpperCase() + match[1].slice(1).toLowerCase();\n        }\n        \n        // Fallback: just capitalize first letter of whatever we have\n        return agentType.charAt(0).toUpperCase() + agentType.slice(1);\n    }\n\n    /**\n     * Format event content for single-row display (without timestamp)\n     * Format: \"{type}.{subtype}\" followed by data details\n     * @param {Object} event - Event object\n     * @returns {string} Formatted single-row event content string\n     */\n    formatSingleRowEventContent(event) {\n        const eventType = this.formatEventType(event);\n        const data = event.data || {};\n        \n        // Include source if it's not the default 'system' source\n        const sourcePrefix = event.source && event.source !== 'system' ? `[${event.source}] ` : '';\n\n        // Extract meaningful details from the data package for different event types\n        let dataDetails = '';\n\n        switch (event.type) {\n            case 'hook':\n                // Hook events: show tool name and operation details\n                const toolName = event.tool_name || data.tool_name || 'Unknown';\n                const hookType = event.subtype || 'Unknown';\n                \n                // Format specific hook types\n                if (hookType === 'pre_tool' || hookType === 'post_tool') {\n                    const operation = data.operation_type || '';\n                    const status = hookType === 'post_tool' && data.success !== undefined \n                        ? (data.success ? '✓' : '✗') \n                        : '';\n                    dataDetails = `${toolName}${operation ? ` (${operation})` : ''}${status ? ` ${status}` : ''}`;\n                } else if (hookType === 'user_prompt') {\n                    const prompt = data.prompt_text || data.prompt_preview || '';\n                    const truncated = prompt.length > 60 ? prompt.substring(0, 60) + '...' : prompt;\n                    dataDetails = truncated || 'No prompt text';\n                } else if (hookType === 'subagent_start') {\n                    // Enhanced agent type detection\n                    const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                    const agentDisplay = this.formatAgentType(agentType);\n                    const prompt = data.prompt || data.description || data.task || '';\n                    const truncated = prompt.length > 40 ? prompt.substring(0, 40) + '...' : prompt;\n                    dataDetails = truncated ? `${agentDisplay} - ${truncated}` : agentDisplay;\n                } else if (hookType === 'subagent_stop') {\n                    // Enhanced agent type detection for subagent_stop\n                    const agentType = data.agent_type || data.agent || data.subagent_type || 'Unknown';\n                    const agentDisplay = this.formatAgentType(agentType);\n                    const reason = data.reason || data.stop_reason || 'completed';\n                    const isCompleted = data.structured_response?.task_completed;\n                    const status = isCompleted !== undefined ? (isCompleted ? '✓' : '✗') : '';\n                    dataDetails = `${agentDisplay}${status ? ' ' + status : ''} - ${reason}`;\n                } else if (hookType === 'stop') {\n                    const reason = data.reason || 'completed';\n                    const stopType = data.stop_type || 'normal';\n                    dataDetails = `${stopType} - ${reason}`;\n                } else {\n                    dataDetails = toolName;\n                }\n                break;\n\n            case 'agent':\n                // Agent events: show agent name and status\n                const agentName = event.subagent_type || data.subagent_type || 'PM';\n                const status = data.status || '';\n                dataDetails = `${agentName}${status ? ` - ${status}` : ''}`;\n                break;\n\n            case 'todo':\n                // Todo events: show item count and status changes\n                if (data.todos && Array.isArray(data.todos)) {\n                    const count = data.todos.length;\n                    const completed = data.todos.filter(t => t.status === 'completed').length;\n                    const inProgress = data.todos.filter(t => t.status === 'in_progress').length;\n                    dataDetails = `${count} items (${completed} completed, ${inProgress} in progress)`;\n                } else {\n                    dataDetails = 'Todo update';\n                }\n                break;\n\n            case 'memory':\n                // Memory events: show operation and key\n                const operation = data.operation || 'unknown';\n                const key = data.key || 'unknown';\n                const value = data.value ? ` = ${JSON.stringify(data.value).substring(0, 30)}...` : '';\n                dataDetails = `${operation}: ${key}${value}`;\n                break;\n\n            case 'session':\n                // Session events: show session ID\n                const sessionId = data.session_id || 'unknown';\n                dataDetails = `ID: ${sessionId}`;\n                break;\n\n            case 'claude':\n                // Claude events: show request/response preview\n                if (event.subtype === 'request') {\n                    const prompt = data.prompt || data.message || '';\n                    const truncated = prompt.length > 60 ? prompt.substring(0, 60) + '...' : prompt;\n                    dataDetails = truncated || 'Empty request';\n                } else if (event.subtype === 'response') {\n                    const response = data.response || data.content || '';\n                    const truncated = response.length > 60 ? response.substring(0, 60) + '...' : response;\n                    dataDetails = truncated || 'Empty response';\n                } else {\n                    dataDetails = data.message || 'Claude interaction';\n                }\n                break;\n\n            case 'log':\n                // Log events: show log level and message\n                const level = data.level || 'info';\n                const message = data.message || '';\n                const truncated = message.length > 60 ? message.substring(0, 60) + '...' : message;\n                dataDetails = `[${level.toUpperCase()}] ${truncated}`;\n                break;\n\n            case 'test':\n                // Test events: show test name or details\n                const testName = data.test_name || data.name || 'Test';\n                dataDetails = testName;\n                break;\n\n            default:\n                // Generic events: show any available data\n                if (typeof data === 'string') {\n                    dataDetails = data.length > 60 ? data.substring(0, 60) + '...' : data;\n                } else if (data.message) {\n                    dataDetails = data.message.length > 60 ? data.message.substring(0, 60) + '...' : data.message;\n                } else if (data.name) {\n                    dataDetails = data.name;\n                } else if (Object.keys(data).length > 0) {\n                    // Show first meaningful field from data\n                    const firstKey = Object.keys(data).find(k => !['timestamp', 'id'].includes(k));\n                    if (firstKey) {\n                        const value = data[firstKey];\n                        dataDetails = `${firstKey}: ${typeof value === 'object' ? JSON.stringify(value).substring(0, 40) + '...' : value}`;\n                    }\n                }\n                break;\n        }\n\n        // Return formatted string: \"[source] {type}.{subtype} - {data details}\"\n        // The eventType already contains the type.subtype format from formatEventType()\n        const fullType = `${sourcePrefix}${eventType}`;\n        return dataDetails ? `${fullType} - ${dataDetails}` : fullType;\n    }\n\n    /**\n     * Get display name for hook types\n     * @param {string} hookType - Hook subtype\n     * @param {Object} data - Event data\n     * @returns {string} Display name\n     */\n    getHookDisplayName(hookType, data) {\n        const hookNames = {\n            'pre_tool': 'Pre-Tool',\n            'post_tool': 'Post-Tool',\n            'user_prompt': 'User-Prompt',\n            'stop': 'Stop',\n            'subagent_start': 'Subagent-Start',\n            'subagent_stop': 'Subagent-Stop',\n            'notification': 'Notification'\n        };\n\n        // Handle non-string hookType safely\n        if (hookNames[hookType]) {\n            return hookNames[hookType];\n        }\n        \n        // Convert to string and handle null/undefined\n        const typeStr = String(hookType || 'unknown');\n        return typeStr.replace(/_/g, ' ');\n    }\n\n    /**\n     * Get event category for display\n     * @param {Object} event - Event object\n     * @returns {string} Category\n     */\n    getEventCategory(event) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Categorize based on tool type\n        if (['Read', 'Write', 'Edit', 'MultiEdit'].includes(toolName)) {\n            return 'file_operations';\n        } else if (['Bash', 'grep', 'Glob'].includes(toolName)) {\n            return 'system_operations';\n        } else if (toolName === 'TodoWrite') {\n            return 'task_management';\n        } else if (toolName === 'Task') {\n            return 'agent_delegation';\n        } else if (event.subtype === 'subagent_start' || event.subtype === 'subagent_stop') {\n            return 'agent_delegation';\n        } else if (event.subtype === 'stop') {\n            return 'session_control';\n        }\n\n        return 'general';\n    }\n\n    /**\n     * Show event details and update selection\n     * @param {number} index - Index of event to show\n     */\n    showEventDetails(index) {\n        // Defensive checks\n        if (!this.filteredEvents || !Array.isArray(this.filteredEvents)) {\n            console.warn('EventViewer: filteredEvents array is not initialized');\n            return;\n        }\n        if (index < 0 || index >= this.filteredEvents.length) return;\n\n        // Update selection\n        this.selectedEventIndex = index;\n\n        // Get the selected event\n        const event = this.filteredEvents[index];\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            // Update the dashboard's navigation state for events tab\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = index;\n            }\n            if (window.dashboard.selectCard) {\n                window.dashboard.selectCard('events', index, 'event', event);\n            }\n        }\n\n        // Update visual selection (this will be handled by Dashboard.updateCardSelectionUI())\n        this.filteredEventElements.forEach((el, i) => {\n            el.classList.toggle('selected', i === index);\n        });\n\n        // Notify other components about selection\n        document.dispatchEvent(new CustomEvent('eventSelected', {\n            detail: { event, index }\n        }));\n\n        // Scroll to selected event if not visible\n        const selectedElement = this.filteredEventElements[index];\n        if (selectedElement) {\n            selectedElement.scrollIntoView({\n                behavior: 'smooth',\n                block: 'nearest'\n            });\n        }\n    }\n\n    /**\n     * Clear event selection\n     */\n    clearSelection() {\n        this.selectedEventIndex = -1;\n        this.filteredEventElements.forEach(el => {\n            el.classList.remove('selected');\n        });\n\n        // Coordinate with Dashboard unified navigation system\n        if (window.dashboard) {\n            if (window.dashboard.tabNavigation && window.dashboard.tabNavigation.events) {\n                window.dashboard.tabNavigation.events.selectedIndex = -1;\n            }\n            if (window.dashboard.clearCardSelection) {\n                window.dashboard.clearCardSelection();\n            }\n        }\n\n        // Notify other components\n        document.dispatchEvent(new CustomEvent('eventSelectionCleared'));\n    }\n\n    /**\n     * Update metrics display\n     */\n    updateMetrics() {\n        // Update event type counts\n        this.eventTypeCount = {};\n        this.errorCount = 0;\n\n        // Defensive check to ensure events array exists\n        if (!this.events || !Array.isArray(this.events)) {\n            console.warn('EventViewer: events array is not initialized in updateMetrics');\n            this.events = [];\n        }\n\n        this.events.forEach(event => {\n            const type = event.type || 'unknown';\n            this.eventTypeCount[type] = (this.eventTypeCount[type] || 0) + 1;\n\n            if (event.type === 'log' &&\n                event.data &&\n                ['error', 'critical'].includes(event.data.level)) {\n                this.errorCount++;\n            }\n        });\n\n        // Update events per minute\n        const currentMinute = new Date().getMinutes();\n        if (currentMinute !== this.lastMinute) {\n            this.lastMinute = currentMinute;\n            this.eventsThisMinute = 0;\n        }\n\n        // Count events in the last minute\n        const oneMinuteAgo = new Date(Date.now() - 60000);\n        this.eventsThisMinute = this.events.filter(event =>\n            new Date(event.timestamp) > oneMinuteAgo\n        ).length;\n\n        // Update UI\n        this.updateMetricsUI();\n    }\n\n    /**\n     * Update metrics in the UI\n     */\n    updateMetricsUI() {\n        const totalEventsEl = document.getElementById('total-events');\n        const eventsPerMinuteEl = document.getElementById('events-per-minute');\n        const uniqueTypesEl = document.getElementById('unique-types');\n        const errorCountEl = document.getElementById('error-count');\n\n        if (totalEventsEl) totalEventsEl.textContent = this.events.length;\n        if (eventsPerMinuteEl) eventsPerMinuteEl.textContent = this.eventsThisMinute;\n        if (uniqueTypesEl) uniqueTypesEl.textContent = Object.keys(this.eventTypeCount).length;\n        if (errorCountEl) errorCountEl.textContent = this.errorCount;\n    }\n\n    /**\n     * Export events to JSON\n     */\n    exportEvents() {\n        const dataStr = JSON.stringify(this.filteredEvents, null, 2);\n        const dataBlob = new Blob([dataStr], { type: 'application/json' });\n        const url = URL.createObjectURL(dataBlob);\n\n        const link = document.createElement('a');\n        link.href = url;\n        link.download = `claude-mpm-events-${new Date().toISOString().split('T')[0]}.json`;\n        link.click();\n\n        URL.revokeObjectURL(url);\n    }\n\n    /**\n     * Clear all events\n     */\n    clearEvents() {\n        this.socketClient.clearEvents();\n        this.selectedEventIndex = -1;\n        this.updateDisplay();\n    }\n\n    /**\n     * Set session filter\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSessionFilter(sessionId) {\n        this.sessionFilter = sessionId;\n        this.applyFilters();\n    }\n\n    /**\n     * Get current filter state\n     * @returns {Object} Current filters\n     */\n    getFilters() {\n        return {\n            search: this.searchFilter,\n            type: this.typeFilter,\n            session: this.sessionFilter\n        };\n    }\n\n    /**\n     * Get filtered events (used by HUD and other components)\n     * @returns {Array} Array of filtered events\n     */\n    getFilteredEvents() {\n        return this.filteredEvents;\n    }\n\n    /**\n     * Get all events (unfiltered, used by HUD for complete visualization)\n     * @returns {Array} Array of all events\n     */\n    getAllEvents() {\n        return this.events;\n    }\n\n    /**\n     * Create inline diff viewer for Edit/MultiEdit tool events\n     * WHY: Provides immediate visibility of file changes without needing to open modals\n     * DESIGN DECISION: Shows inline diffs only for Edit/MultiEdit events to avoid clutter\n     * @param {Object} event - Event object\n     * @param {number} index - Event index for unique IDs\n     * @returns {string} HTML for inline diff viewer\n     */\n    createInlineEditDiffViewer(event, index) {\n        const data = event.data || {};\n        const toolName = event.tool_name || data.tool_name || '';\n\n        // Only show for Edit and MultiEdit tools\n        if (!['Edit', 'MultiEdit'].includes(toolName)) {\n            return '';\n        }\n\n        // Extract edit parameters based on tool type\n        let edits = [];\n        if (toolName === 'Edit') {\n            // Single edit\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.old_string && parameters.new_string) {\n                edits.push({\n                    old_string: parameters.old_string,\n                    new_string: parameters.new_string,\n                    file_path: parameters.file_path || 'unknown'\n                });\n            }\n        } else if (toolName === 'MultiEdit') {\n            // Multiple edits\n            const parameters = event.tool_parameters || data.tool_parameters || {};\n            if (parameters.edits && Array.isArray(parameters.edits)) {\n                edits = parameters.edits.map(edit => ({\n                    ...edit,\n                    file_path: parameters.file_path || 'unknown'\n                }));\n            }\n        }\n\n        if (edits.length === 0) {\n            return '';\n        }\n\n        // Create collapsible diff section\n        const diffId = `edit-diff-${index}`;\n        const isMultiEdit = edits.length > 1;\n\n        let diffContent = '';\n        edits.forEach((edit, editIndex) => {\n            const editId = `${diffId}-${editIndex}`;\n            const diffHtml = this.createDiffHtml(edit.old_string, edit.new_string);\n\n            diffContent += `\n                <div class=\"edit-diff-section\">\n                    ${isMultiEdit ? `<div class=\"edit-diff-header\">Edit ${editIndex + 1}</div>` : ''}\n                    <div class=\"diff-content\">${diffHtml}</div>\n                </div>\n            `;\n        });\n\n        return `\n            <div class=\"inline-edit-diff-viewer\">\n                <div class=\"diff-toggle-header\" onclick=\"eventViewer.toggleEditDiff('${diffId}', event)\">\n                    <span class=\"diff-toggle-icon\">📋</span>\n                    <span class=\"diff-toggle-text\">Show ${isMultiEdit ? edits.length + ' edits' : 'edit'}</span>\n                    <span class=\"diff-toggle-arrow\">▼</span>\n                </div>\n                <div id=\"${diffId}\" class=\"diff-content-container\" style=\"display: none;\">\n                    ${diffContent}\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Create HTML diff visualization\n     * WHY: Provides clear visual representation of text changes similar to git diff\n     * @param {string} oldText - Original text\n     * @param {string} newText - Modified text\n     * @returns {string} HTML diff content\n     */\n    createDiffHtml(oldText, newText) {\n        // Simple line-by-line diff implementation\n        const oldLines = oldText.split('\\n');\n        const newLines = newText.split('\\n');\n\n        let diffHtml = '';\n        let i = 0, j = 0;\n\n        // Simple diff algorithm - can be enhanced with proper diff library if needed\n        while (i < oldLines.length || j < newLines.length) {\n            const oldLine = i < oldLines.length ? oldLines[i] : null;\n            const newLine = j < newLines.length ? newLines[j] : null;\n\n            if (oldLine === null) {\n                // New line added\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                j++;\n            } else if (newLine === null) {\n                // Old line removed\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n            } else if (oldLine === newLine) {\n                // Lines are the same\n                diffHtml += `<div class=\"diff-line diff-unchanged\">  ${this.escapeHtml(oldLine)}</div>`;\n                i++;\n                j++;\n            } else {\n                // Lines are different - show both\n                diffHtml += `<div class=\"diff-line diff-removed\">- ${this.escapeHtml(oldLine)}</div>`;\n                diffHtml += `<div class=\"diff-line diff-added\">+ ${this.escapeHtml(newLine)}</div>`;\n                i++;\n                j++;\n            }\n        }\n\n        return `<div class=\"diff-container\">${diffHtml}</div>`;\n    }\n\n    /**\n     * Toggle edit diff visibility\n     * @param {string} diffId - Diff container ID\n     * @param {Event} event - Click event\n     */\n    toggleEditDiff(diffId, event) {\n        // Prevent event bubbling to parent event item\n        event.stopPropagation();\n\n        const diffContainer = document.getElementById(diffId);\n        const arrow = event.currentTarget.querySelector('.diff-toggle-arrow');\n\n        if (diffContainer) {\n            const isVisible = diffContainer.style.display !== 'none';\n            diffContainer.style.display = isVisible ? 'none' : 'block';\n            if (arrow) {\n                arrow.textContent = isVisible ? '▼' : '▲';\n            }\n        }\n    }\n\n    /**\n     * Escape HTML characters for safe display\n     * @param {string} text - Text to escape\n     * @returns {string} Escaped text\n     */\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n}\n\n// ES6 Module export\nexport { EventViewer };\nexport default EventViewer;\n\n// Backward compatibility - keep window export for non-module usage\nwindow.EventViewer = EventViewer;\n","/**\n * Event Processor Module\n *\n * Handles event processing, filtering, and rendering for different tabs in the dashboard.\n * Provides centralized event filtering and rendering logic for agents, tools, and files tabs.\n *\n * WHY: Extracted from main dashboard to isolate complex event processing logic\n * that involves filtering, transforming, and rendering events across different views.\n * This improves maintainability and makes the event processing logic testable.\n *\n * DESIGN DECISION: Maintains its own filtered event collections while relying on\n * eventViewer for source data. Provides separate filtering logic for each tab type\n * while sharing common filtering patterns and utilities.\n */\nclass EventProcessor {\n    constructor(eventViewer, agentInference) {\n        this.eventViewer = eventViewer;\n        this.agentInference = agentInference;\n\n        // Processed event collections for different tabs\n        this.agentEvents = [];\n        this.filteredAgentEvents = [];\n        this.filteredToolEvents = [];\n        this.filteredFileEvents = [];\n\n        // Session filtering\n        this.selectedSessionId = null;\n\n        // Git tracking status cache\n        this.fileTrackingCache = new Map(); // file_path -> {is_tracked: boolean, timestamp: number}\n        this.trackingCheckTimeout = 30000; // Cache for 30 seconds\n\n        console.log('Event processor initialized');\n    }\n\n    /**\n     * Get filtered events for a specific tab\n     * @param {string} tabName - Tab name ('agents', 'tools', 'files', 'events')\n     * @returns {Array} - Filtered events\n     */\n    getFilteredEventsForTab(tabName) {\n        const events = this.eventViewer.events;\n        console.log(`getFilteredEventsForTab(${tabName}) - using RAW events: ${events.length} total`);\n\n        // Use session manager to filter events by session if needed\n        const sessionManager = window.sessionManager;\n        if (sessionManager && sessionManager.selectedSessionId) {\n            const sessionEvents = sessionManager.getEventsForSession(sessionManager.selectedSessionId);\n            console.log(`Filtering by session ${sessionManager.selectedSessionId}: ${sessionEvents.length} events`);\n            return sessionEvents;\n        }\n\n        return events;\n    }\n\n    /**\n     * Apply agents tab filtering for unique instances\n     * @param {Array} uniqueInstances - Unique agent instances to filter\n     * @returns {Array} - Filtered unique instances\n     */\n    applyAgentsFilters(uniqueInstances) {\n        const searchInput = document.getElementById('agents-search-input');\n        const typeFilter = document.getElementById('agents-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return uniqueInstances.filter(instance => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    instance.agentName || '',\n                    instance.type || '',\n                    instance.isImplied ? 'implied' : 'explicit'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const agentName = instance.agentName || 'unknown';\n                if (!agentName.toLowerCase().includes(typeValue.toLowerCase())) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering\n     * @param {Array} events - Events to filter\n     * @returns {Array} - Filtered events\n     */\n    applyToolsFilters(events) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return events.filter(event => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    event.tool_name || '',\n                    event.agent_type || '',\n                    event.type || '',\n                    event.subtype || ''\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = event.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply tools tab filtering for tool calls\n     * @param {Array} toolCallsArray - Tool calls array to filter\n     * @returns {Array} - Filtered tool calls\n     */\n    applyToolCallFilters(toolCallsArray) {\n        const searchInput = document.getElementById('tools-search-input');\n        const typeFilter = document.getElementById('tools-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return toolCallsArray.filter(([key, toolCall]) => {\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    toolCall.tool_name || '',\n                    toolCall.agent_type || '',\n                    'tool_call'\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const toolName = toolCall.tool_name || '';\n                if (toolName !== typeValue) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Apply files tab filtering\n     * @param {Array} fileOperations - File operations to filter\n     * @returns {Array} - Filtered file operations\n     */\n    applyFilesFilters(fileOperations) {\n        const searchInput = document.getElementById('files-search-input');\n        const typeFilter = document.getElementById('files-type-filter');\n\n        const searchText = searchInput ? searchInput.value.toLowerCase() : '';\n        const typeValue = typeFilter ? typeFilter.value : '';\n\n        return fileOperations.filter(([filePath, fileData]) => {\n            // Session filter - filter operations within each file\n            if (this.selectedSessionId) {\n                // Filter operations for this file by session\n                const sessionOperations = fileData.operations.filter(op =>\n                    op.sessionId === this.selectedSessionId\n                );\n\n                // If no operations from this session, exclude the file\n                if (sessionOperations.length === 0) {\n                    return false;\n                }\n\n                // Update the fileData to only include session-specific operations\n                // (Note: This creates a filtered view without modifying the original)\n                fileData = {\n                    ...fileData,\n                    operations: sessionOperations,\n                    lastOperation: sessionOperations[sessionOperations.length - 1]?.timestamp || fileData.lastOperation\n                };\n            }\n\n            // Search filter\n            if (searchText) {\n                const searchableText = [\n                    filePath,\n                    ...fileData.operations.map(op => op.operation),\n                    ...fileData.operations.map(op => op.agent)\n                ].join(' ').toLowerCase();\n\n                if (!searchableText.includes(searchText)) {\n                    return false;\n                }\n            }\n\n            // Type filter\n            if (typeValue) {\n                const operations = fileData.operations.map(op => op.operation);\n                if (!operations.includes(typeValue)) {\n                    return false;\n                }\n            }\n\n            return true;\n        });\n    }\n\n    /**\n     * Extract operation type from event type\n     * @param {string} eventType - Event type string\n     * @returns {string} - Operation type\n     */\n    extractOperation(eventType) {\n        if (!eventType) return 'unknown';\n\n        const type = eventType.toLowerCase();\n        if (type.includes('read')) return 'read';\n        if (type.includes('write')) return 'write';\n        if (type.includes('edit')) return 'edit';\n        if (type.includes('create')) return 'create';\n        if (type.includes('delete')) return 'delete';\n        if (type.includes('move') || type.includes('rename')) return 'move';\n\n        return 'other';\n    }\n\n    /**\n     * Extract tool name from hook event type\n     * @param {string} eventType - Hook event type\n     * @returns {string} - Tool name\n     */\n    extractToolFromHook(eventType) {\n        if (!eventType) return '';\n\n        // Pattern: Pre{ToolName}Use or Post{ToolName}Use\n        const match = eventType.match(/^(?:Pre|Post)(.+)Use$/);\n        return match ? match[1] : '';\n    }\n\n    /**\n     * Extract tool name from subtype\n     * @param {string} subtype - Event subtype\n     * @returns {string} - Tool name\n     */\n    extractToolFromSubtype(subtype) {\n        if (!subtype) return '';\n\n        // Handle various subtype patterns\n        if (subtype.includes('_')) {\n            const parts = subtype.split('_');\n            return parts[0] || '';\n        }\n\n        return subtype;\n    }\n\n    /**\n     * Extract target information from tool parameters\n     * @param {string} toolName - Tool name\n     * @param {Object} params - Tool parameters\n     * @param {Object} toolParameters - Alternative tool parameters\n     * @returns {string} - Target information\n     */\n    extractToolTarget(toolName, params, toolParameters) {\n        const parameters = params || toolParameters || {};\n\n        switch (toolName?.toLowerCase()) {\n            case 'read':\n            case 'write':\n            case 'edit':\n                return parameters.file_path || parameters.path || '';\n            case 'bash':\n                return parameters.command || '';\n            case 'grep':\n                return parameters.pattern || '';\n            case 'task':\n                return parameters.subagent_type || parameters.agent_type || '';\n            default:\n                // Try to find a meaningful parameter\n                const keys = Object.keys(parameters);\n                const meaningfulKeys = ['path', 'file_path', 'command', 'pattern', 'query', 'target'];\n                for (const key of meaningfulKeys) {\n                    if (parameters[key]) {\n                        return parameters[key];\n                    }\n                }\n                return keys.length > 0 ? `${keys[0]}: ${parameters[keys[0]]}` : '';\n        }\n    }\n\n    /**\n     * Generate HTML for unique agent instances (one row per PM delegation)\n     * @param {Array} events - Agent events to render (not used, kept for compatibility)\n     * @returns {string} - HTML string\n     */\n    generateAgentHTML(events) {\n        // Get unique agent instances from agent inference\n        const uniqueInstances = this.agentInference.getUniqueAgentInstances();\n\n        // Apply filtering\n        const filteredInstances = this.applyAgentsFilters(uniqueInstances);\n\n        return filteredInstances.map((instance, index) => {\n            const agentName = instance.agentName;\n            const timestamp = this.formatTimestamp(instance.firstTimestamp || instance.timestamp);\n            const delegationType = instance.isImplied ? 'implied' : 'explicit';\n            // Fix: Use totalEventCount which is the actual property name from getUniqueAgentInstances()\n            const eventCount = instance.totalEventCount || instance.eventCount || 0;\n\n            const onclickString = `dashboard.selectCard('agents', ${index}, 'agent_instance', '${instance.id}'); dashboard.showAgentInstanceDetails('${instance.id}');`;\n\n            // Format: \"[Agent Name] (delegationType, eventCount events)\" with separate timestamp\n            const agentMainContent = `${agentName} (${delegationType}, ${eventCount} events)`;\n\n            return `\n                <div class=\"event-item single-row event-agent\" onclick=\"${onclickString}\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${agentMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for tool events\n     * @param {Array} toolCalls - Tool calls to render\n     * @returns {string} - HTML string\n     */\n    generateToolHTML(toolCalls) {\n        const filteredToolCalls = this.applyToolCallFilters(toolCalls);\n\n        return filteredToolCalls.map(([key, toolCall], index) => {\n            const toolName = toolCall.tool_name || 'Unknown';\n            const rawAgent = toolCall.agent_type || 'Unknown';\n            const timestamp = this.formatTimestamp(toolCall.timestamp);\n            const status = toolCall.post_event ? 'completed' : 'pending';\n            const statusClass = status === 'completed' ? 'status-success' : 'status-pending';\n\n            // Convert agent name: show \"pm\" for PM agent, otherwise show actual agent name\n            const agentName = rawAgent.toLowerCase() === 'pm' ? 'pm' : rawAgent;\n\n            // Format: \"Tool Name (Agent Name)\" - removed duration from main display\n            const toolMainContent = `${toolName} (${agentName})`;\n\n            return `\n                <div class=\"event-item single-row event-tool ${statusClass}\" onclick=\"dashboard.selectCard('tools', ${index}, 'toolCall', '${key}'); dashboard.showToolCallDetails('${key}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${toolMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Generate HTML for file operations\n     * @param {Array} fileOperations - File operations to render\n     * @returns {string} - HTML string\n     */\n    generateFileHTML(fileOperations) {\n        const filteredFiles = this.applyFilesFilters(fileOperations);\n\n        return filteredFiles.map(([filePath, fileData], index) => {\n            const operations = fileData.operations.map(op => op.operation);\n            const timestamp = this.formatTimestamp(fileData.lastOperation);\n\n            // Count operations by type for display: \"read(2), write(1)\"\n            const operationCounts = {};\n            operations.forEach(op => {\n                operationCounts[op] = (operationCounts[op] || 0) + 1;\n            });\n\n            const operationSummary = Object.entries(operationCounts)\n                .map(([op, count]) => `${op}(${count})`)\n                .join(', ');\n\n            // Get unique agents that worked on this file\n            const uniqueAgents = [...new Set(fileData.operations.map(op => op.agent))];\n            const agentSummary = uniqueAgents.length > 1 ? `by ${uniqueAgents.length} agents` : `by ${uniqueAgents[0] || 'unknown'}`;\n\n            // Format: \"[file path] read(2), write(1) by agent\" with separate timestamp\n            const fileName = this.getRelativeFilePath(filePath);\n            const fileMainContent = `${fileName} ${operationSummary} ${agentSummary}`;\n\n            return `\n                <div class=\"event-item single-row file-item\" onclick=\"dashboard.selectCard('files', ${index}, 'file', '${filePath}'); dashboard.showFileDetails('${filePath}')\">\n                    <span class=\"event-single-row-content\">\n                        <span class=\"event-content-main\">${fileMainContent}</span>\n                        <span class=\"event-timestamp\">${timestamp}</span>\n                    </span>\n                </div>\n            `;\n        }).join('');\n    }\n\n    /**\n     * Get icon for file operations\n     * @param {Array} operations - Array of operations\n     * @returns {string} - Icon representation\n     */\n    getFileOperationIcon(operations) {\n        if (operations.includes('write') || operations.includes('create')) return '📝';\n        if (operations.includes('edit')) return '✏️';\n        if (operations.includes('read')) return '👁️';\n        if (operations.includes('delete')) return '🗑️';\n        if (operations.includes('move')) return '📦';\n        return '📄';\n    }\n\n    /**\n     * Get relative file path\n     * @param {string} filePath - Full file path\n     * @returns {string} - Relative path\n     */\n    getRelativeFilePath(filePath) {\n        if (!filePath) return '';\n\n        // Simple relative path logic - can be enhanced\n        const parts = filePath.split('/');\n        if (parts.length > 3) {\n            return '.../' + parts.slice(-2).join('/');\n        }\n        return filePath;\n    }\n\n    /**\n     * Format timestamp for display\n     * @param {string|number} timestamp - Timestamp to format\n     * @returns {string} - Formatted timestamp\n     */\n    formatTimestamp(timestamp) {\n        if (!timestamp) return '';\n\n        const date = new Date(timestamp);\n        return date.toLocaleTimeString();\n    }\n\n    /**\n     * Set selected session ID for filtering\n     * @param {string} sessionId - Session ID to filter by\n     */\n    setSelectedSessionId(sessionId) {\n        this.selectedSessionId = sessionId;\n    }\n\n    /**\n     * Get selected session ID\n     * @returns {string|null} - Current session ID\n     */\n    getSelectedSessionId() {\n        return this.selectedSessionId;\n    }\n\n    /**\n     * Get unique tool instances (one row per unique tool call)\n     * This deduplicates tool calls to show unique instances only\n     * @param {Array} toolCallsArray - Tool calls array\n     * @returns {Array} - Unique tool instances\n     */\n    getUniqueToolInstances(toolCallsArray) {\n        // The toolCallsArray already represents unique tool calls\n        // since it's generated from paired pre/post events in FileToolTracker\n        // Just apply filtering and return\n        return this.applyToolCallFilters(toolCallsArray);\n    }\n\n    /**\n     * Get unique file instances (one row per unique file)\n     * This aggregates all operations on each file\n     * @param {Array} fileOperations - File operations array\n     * @returns {Array} - Unique file instances (same as input since already unique per file)\n     */\n    getUniqueFileInstances(fileOperations) {\n        // The fileOperations array already represents unique files\n        // since it's keyed by file path in FileToolTracker\n        // Just apply filtering and return\n        return this.applyFilesFilters(fileOperations);\n    }\n\n    /**\n     * Check if a file is tracked by git (with caching)\n     * @param {string} filePath - Path to the file\n     * @param {string} workingDir - Working directory\n     * @returns {Promise<boolean>} - Promise resolving to tracking status\n     */\n    async isFileTracked(filePath, workingDir) {\n        const cacheKey = `${workingDir}:${filePath}`;\n        const now = Date.now();\n\n        // Check cache first\n        const cached = this.fileTrackingCache.get(cacheKey);\n        if (cached && (now - cached.timestamp) < this.trackingCheckTimeout) {\n            return cached.is_tracked;\n        }\n\n        try {\n            // Use the socketio connection to check tracking status\n            const socket = window.socket;\n            if (!socket) {\n                console.warn('No socket connection available for git tracking check');\n                return false;\n            }\n\n            return new Promise((resolve) => {\n                // Set up one-time listener for response\n                const responseHandler = (data) => {\n                    if (data.file_path === filePath) {\n                        const isTracked = data.success && data.is_tracked;\n\n                        // Cache the result\n                        this.fileTrackingCache.set(cacheKey, {\n                            is_tracked: isTracked,\n                            timestamp: now\n                        });\n\n                        socket.off('file_tracked_response', responseHandler);\n                        resolve(isTracked);\n                    }\n                };\n\n                socket.on('file_tracked_response', responseHandler);\n\n                // Send request\n                socket.emit('check_file_tracked', {\n                    file_path: filePath,\n                    working_dir: workingDir\n                });\n\n                // Timeout after 5 seconds\n                setTimeout(() => {\n                    socket.off('file_tracked_response', responseHandler);\n                    resolve(false); // Default to not tracked on timeout\n                }, 5000);\n            });\n\n        } catch (error) {\n            console.error('Error checking file tracking status:', error);\n            return false;\n        }\n    }\n\n    /**\n     * Generate git diff icon with tracking status\n     * @param {string} filePath - Path to the file\n     * @param {string} timestamp - Operation timestamp\n     * @param {string} workingDir - Working directory\n     * @returns {string} - HTML for git diff icon\n     */\n    generateGitDiffIcon(filePath, timestamp, workingDir) {\n        const iconId = `git-icon-${filePath.replace(/[^a-zA-Z0-9]/g, '-')}-${timestamp}`;\n\n        // Initially show default icon\n        const iconHtml = `\n            <span id=\"${iconId}\" class=\"git-diff-icon\"\n                  onclick=\"event.stopPropagation(); showGitDiffModal('${filePath}', '${timestamp}')\"\n                  title=\"View git diff for this file operation\"\n                  style=\"margin-left: 8px; cursor: pointer; font-size: 16px;\">\n                📋\n            </span>\n        `;\n\n        // Asynchronously check tracking status and update icon\n        this.isFileTracked(filePath, workingDir).then(isTracked => {\n            const iconElement = document.getElementById(iconId);\n            if (iconElement) {\n                if (!isTracked) {\n                    // File is not tracked - show crossed out icon\n                    iconElement.innerHTML = '📋❌';\n                    iconElement.title = 'File not tracked by git - click to see details';\n                    iconElement.classList.add('untracked-file');\n                } else {\n                    // File is tracked - keep normal icon\n                    iconElement.innerHTML = '📋';\n                    iconElement.title = 'View git diff for this file operation';\n                    iconElement.classList.add('tracked-file');\n                }\n            }\n        }).catch(error => {\n            console.error('Error updating git diff icon:', error);\n        });\n\n        return iconHtml;\n    }\n\n    /**\n     * Show agent instance details for unique instance view\n     * @param {string} instanceId - Agent instance ID\n     */\n    showAgentInstanceDetails(instanceId) {\n        const pmDelegations = this.agentInference.getPMDelegations();\n        const instance = pmDelegations.get(instanceId);\n\n        if (!instance) {\n            console.error('Agent instance not found:', instanceId);\n            return;\n        }\n\n        // Show details about this PM delegation and its events\n        console.log('Showing agent instance details for:', instanceId, instance);\n\n        // This would integrate with the existing detail view system\n        // For now, just log the details - can be expanded to show in a modal/sidebar\n        const detailsHtml = `\n            <div class=\"agent-instance-details\">\n                <h3>Agent Instance: ${instance.agentName}</h3>\n                <p><strong>Type:</strong> ${instance.isImplied ? 'Implied PM Delegation' : 'Explicit PM Delegation'}</p>\n                <p><strong>Start Time:</strong> ${this.formatTimestamp(instance.timestamp)}</p>\n                <p><strong>Event Count:</strong> ${instance.agentEvents.length}</p>\n                <p><strong>Session:</strong> ${instance.sessionId}</p>\n                ${instance.pmCall ? `<p><strong>PM Call:</strong> Task delegation to ${instance.agentName}</p>` : '<p><strong>Note:</strong> Implied delegation (no explicit PM call found)</p>'}\n            </div>\n        `;\n\n        // You would integrate this with your existing detail display system\n        console.log('Agent instance details HTML:', detailsHtml);\n    }\n}\n\n// ES6 Module export\nexport { EventProcessor };\nexport default EventProcessor;\n"],"names":["EventViewer","constructor","containerId","socketClient","this","container","document","getElementById","events","filteredEvents","selectedEventIndex","filteredEventElements","autoScroll","searchFilter","typeFilter","sessionFilter","eventTypeCount","availableEventTypes","Set","errorCount","eventsThisMinute","lastMinute","Date","getMinutes","init","setupEventHandlers","setupKeyboardNavigation","onEventUpdate","sessions","Array","isArray","updateDisplay","searchInput","addEventListener","e","target","value","toLowerCase","applyFilters","handleArrowNavigation","direction","length","newIndex","showEventDetails","console","warn","filter","event","type","subtype","JSON","stringify","data","join","includes","eventType","trim","session_id","renderEvents","updateMetrics","updateEventTypeDropdown","dropdown","eventTypes","forEach","fullType","add","currentTypes","from","sort","previousTypes","currentSelection","innerHTML","option","createElement","textContent","appendChild","has","eventsList","wasAtBottom","scrollTop","clientHeight","scrollHeight","html","map","index","timestamp","toLocaleTimeString","formatSingleRowEventContent","createInlineEditDiffViewer","querySelectorAll","window","dashboard","currentTab","tabNavigation","items","requestAnimationFrame","formatEventType","originalEventName","formatEventData","formatSessionEvent","formatClaudeEvent","formatAgentEvent","formatHookEvent","formatTodoEvent","formatMemoryEvent","formatLogEvent","formatCodeEvent","formatGenericEvent","prompt","message","substring","response","content","agent_type","name","event_type","prompt_text","prompt_preview","toolName","tool_name","operation_type","postToolName","success","status","duration_ms","notification_type","message_preview","reason","stop_type","startAgentType","agent","subagent_type","startPrompt","description","task","startTruncated","formatAgentType","agentType","stopReason","stop_reason","stopAgentDisplay","isCompleted","structured_response","task_completed","hookName","hook_name","todos","count","operation","key","level","truncated","toUpperCase","percentage","Math","round","path","duration","toFixed","file","nodes","nodes_count","node_type","error","json","agentTypeMap","research","architect","engineer","qa","pm","project_manager","research_agent","architect_agent","engineer_agent","qa_agent","unknown","lowerType","match","charAt","slice","sourcePrefix","source","dataDetails","hookType","agentDisplay","agentName","t","test_name","Object","keys","firstKey","find","k","getHookDisplayName","hookNames","pre_tool","post_tool","user_prompt","stop","subagent_start","subagent_stop","notification","String","replace","getEventCategory","selectedIndex","selectCard","el","i","classList","toggle","dispatchEvent","CustomEvent","detail","selectedElement","scrollIntoView","behavior","block","clearSelection","remove","clearCardSelection","currentMinute","oneMinuteAgo","now","updateMetricsUI","totalEventsEl","eventsPerMinuteEl","uniqueTypesEl","errorCountEl","exportEvents","dataStr","dataBlob","Blob","url","URL","createObjectURL","link","href","download","toISOString","split","click","revokeObjectURL","clearEvents","setSessionFilter","sessionId","getFilters","search","session","getFilteredEvents","getAllEvents","edits","parameters","tool_parameters","old_string","new_string","push","file_path","edit","diffId","isMultiEdit","diffContent","editIndex","diffHtml","createDiffHtml","oldText","newText","oldLines","newLines","j","oldLine","newLine","escapeHtml","toggleEditDiff","stopPropagation","diffContainer","arrow","currentTarget","querySelector","isVisible","style","display","text","div","EventProcessor","eventViewer","agentInference","agentEvents","filteredAgentEvents","filteredToolEvents","filteredFileEvents","selectedSessionId","fileTrackingCache","Map","trackingCheckTimeout","log","getFilteredEventsForTab","tabName","sessionManager","sessionEvents","getEventsForSession","applyAgentsFilters","uniqueInstances","searchText","typeValue","instance","isImplied","applyToolsFilters","applyToolCallFilters","toolCallsArray","toolCall","applyFilesFilters","fileOperations","filePath","fileData","sessionOperations","operations","op","lastOperation","extractOperation","extractToolFromHook","extractToolFromSubtype","extractToolTarget","params","toolParameters","command","pattern","meaningfulKeys","generateAgentHTML","getUniqueAgentInstances","formatTimestamp","firstTimestamp","delegationType","eventCount","totalEventCount","id","generateToolHTML","toolCalls","rawAgent","post_event","generateFileHTML","operationCounts","operationSummary","entries","uniqueAgents","agentSummary","getRelativeFilePath","getFileOperationIcon","parts","setSelectedSessionId","getSelectedSessionId","getUniqueToolInstances","getUniqueFileInstances","isFileTracked","workingDir","cacheKey","cached","get","is_tracked","socket","Promise","resolve","responseHandler","isTracked","set","off","on","emit","working_dir","setTimeout","generateGitDiffIcon","iconId","iconHtml","then","iconElement","title","catch","showAgentInstanceDetails","instanceId","getPMDelegations","detailsHtml","pmCall"],"mappings":"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"}