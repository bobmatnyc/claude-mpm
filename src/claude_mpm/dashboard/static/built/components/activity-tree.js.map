{"version":3,"file":"activity-tree.js","sources":["../../js/components/activity-tree.js"],"sourcesContent":["/**\n * Activity Tree Component - Linear Tree View\n * \n * HTML/CSS-based linear tree visualization for showing PM activity hierarchy.\n * Replaces D3.js with simpler, cleaner linear tree structure.\n * Uses UnifiedDataViewer for consistent data display with Tools viewer.\n */\n\n// Import UnifiedDataViewer for consistent data display\nimport { UnifiedDataViewer } from './unified-data-viewer.js';\n\nclass ActivityTree {\n    constructor() {\n        this.container = null;\n        this.events = [];\n        this.processedEventIds = new Set(); // Track which events we've already processed\n        this.sessions = new Map();\n        this.currentSession = null;\n        this.selectedSessionFilter = 'all';\n        this.timeRange = '30min';\n        this.searchTerm = '';\n        this.initialized = false;\n        this.expandedSessions = new Set();\n        this.expandedAgents = new Set();\n        this.expandedTools = new Set();\n        this.selectedItem = null;\n        this.sessionFilterInitialized = false; // Flag to prevent initialization loop\n        \n        // Add debounce for renderTree to prevent excessive DOM rebuilds\n        this.renderTreeDebounced = this.debounce(() => this.renderTree(), 100);\n    }\n    \n    /**\n     * Debounce helper to prevent excessive DOM updates\n     */\n    debounce(func, wait) {\n        let timeout;\n        return function executedFunction(...args) {\n            const later = () => {\n                clearTimeout(timeout);\n                func(...args);\n            };\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n        };\n    }\n\n    /**\n     * Initialize the activity tree\n     */\n    initialize() {\n        console.log('ActivityTree.initialize() called, initialized:', this.initialized);\n        \n        if (this.initialized) {\n            console.log('Activity tree already initialized, skipping');\n            return;\n        }\n        \n        this.container = document.getElementById('activity-tree-container');\n        if (!this.container) {\n            this.container = document.getElementById('activity-tree');\n            if (!this.container) {\n                console.error('Activity tree container not found in DOM');\n                return;\n            }\n        }\n        \n        // Check if the container is visible before initializing\n        const tabPanel = document.getElementById('activity-tab');\n        if (!tabPanel) {\n            console.error('Activity tab panel (#activity-tab) not found in DOM');\n            return;\n        }\n        \n        // Initialize even if tab is not active\n        if (!tabPanel.classList.contains('active')) {\n            console.log('Activity tab not active, initializing but deferring render');\n            this.setupControls();\n            this.subscribeToEvents();\n            this.initialized = true;\n            return;\n        }\n\n        this.setupControls();\n        this.createLinearTreeView();\n        this.subscribeToEvents();\n        \n        this.initialized = true;\n        console.log('Activity tree initialization complete');\n    }\n\n    /**\n     * Force show the tree visualization\n     */\n    forceShow() {\n        console.log('ActivityTree.forceShow() called');\n        \n        if (!this.container) {\n            this.container = document.getElementById('activity-tree-container') || document.getElementById('activity-tree');\n            if (!this.container) {\n                console.error('Cannot find activity tree container');\n                return;\n            }\n        }\n        \n        this.createLinearTreeView();\n        this.renderTree();\n    }\n    \n    /**\n     * Render the visualization when tab becomes visible\n     */\n    renderWhenVisible() {\n        console.log('ActivityTree.renderWhenVisible() called');\n        \n        if (!this.initialized) {\n            console.log('Not initialized yet, calling initialize...');\n            this.initialize();\n            return;\n        }\n        \n        this.createLinearTreeView();\n        this.renderTree();\n    }\n\n    /**\n     * Setup control handlers\n     */\n    setupControls() {\n        // Time range filter dropdown\n        const timeRangeSelect = document.getElementById('time-range');\n        if (timeRangeSelect) {\n            timeRangeSelect.addEventListener('change', (e) => {\n                this.timeRange = e.target.value;\n                console.log(`ActivityTree: Time range changed to: ${this.timeRange}`);\n                this.renderTree();\n            });\n        }\n\n        // Listen for session filter changes from SessionManager\n        document.addEventListener('sessionFilterChanged', (e) => {\n            this.selectedSessionFilter = e.detail.sessionId || 'all';\n            console.log(`ActivityTree: Session filter changed to: ${this.selectedSessionFilter} (from SessionManager)`);\n            this.renderTree();\n        });\n\n        // Also listen for sessionChanged for backward compatibility\n        document.addEventListener('sessionChanged', (e) => {\n            this.selectedSessionFilter = e.detail.sessionId || 'all';\n            console.log(`ActivityTree: Session changed to: ${this.selectedSessionFilter} (from SessionManager - backward compat)`);\n            this.renderTree();\n        });\n\n        // Initialize with current session filter from SessionManager (prevent loop)\n        setTimeout(() => {\n            if (window.sessionManager && !this.sessionFilterInitialized) {\n                const currentFilter = window.sessionManager.getCurrentFilter();\n                if (currentFilter !== this.selectedSessionFilter) {\n                    this.selectedSessionFilter = currentFilter || 'all';\n                    console.log(`ActivityTree: Initialized with current session filter: ${this.selectedSessionFilter}`);\n                    this.sessionFilterInitialized = true; // Prevent re-initialization\n                    this.renderTree();\n                }\n            }\n        }, 100); // Small delay to ensure SessionManager is initialized\n\n        // Expand all button - expand all sessions\n        const expandAllBtn = document.getElementById('expand-all');\n        if (expandAllBtn) {\n            expandAllBtn.addEventListener('click', () => this.expandAllSessions());\n        }\n\n        // Collapse all button - collapse all sessions\n        const collapseAllBtn = document.getElementById('collapse-all');\n        if (collapseAllBtn) {\n            collapseAllBtn.addEventListener('click', () => this.collapseAllSessions());\n        }\n\n        // Reset zoom button functionality\n        const resetZoomBtn = document.getElementById('reset-zoom');\n        if (resetZoomBtn) {\n            resetZoomBtn.style.display = 'inline-block';\n            resetZoomBtn.addEventListener('click', () => this.resetZoom());\n        }\n\n        // Search input\n        const searchInput = document.getElementById('activity-search');\n        if (searchInput) {\n            searchInput.addEventListener('input', (e) => {\n                this.searchTerm = e.target.value.toLowerCase();\n                this.renderTree();\n            });\n        }\n    }\n\n    /**\n     * Create the linear tree view container\n     */\n    createLinearTreeView() {\n        console.log('Creating linear tree view');\n        \n        // Clear container\n        this.container.innerHTML = '';\n        \n        // Create main tree container\n        const treeContainer = document.createElement('div');\n        treeContainer.id = 'linear-tree';\n        treeContainer.className = 'linear-tree';\n        \n        this.container.appendChild(treeContainer);\n        \n        console.log('Linear tree view created');\n    }\n\n    /**\n     * Subscribe to socket events\n     */\n    subscribeToEvents() {\n        if (!window.socketClient) {\n            console.warn('Socket client not available for activity tree');\n            setTimeout(() => this.subscribeToEvents(), 1000);\n            return;\n        }\n\n        console.log('ActivityTree: Setting up event subscription');\n\n        // Subscribe to event updates from the socket client\n        // FIXED: Now correctly receives both events AND sessions from socket client\n        window.socketClient.onEventUpdate((events, sessions) => {\n            console.log(`ActivityTree: onEventUpdate called with ${events.length} total events and ${sessions.size} sessions`);\n            \n            // IMPORTANT: Don't clear sessions! We need to preserve the accumulated agent data\n            // Only create new sessions if they don't exist yet\n            for (const [sessionId, sessionData] of sessions.entries()) {\n                if (!this.sessions.has(sessionId)) {\n                    // Create new session only if it doesn't exist\n                    const activitySession = {\n                        id: sessionId,\n                        timestamp: new Date(sessionData.lastActivity || sessionData.startTime || new Date()),\n                        expanded: this.expandedSessions.has(sessionId) || true, // Preserve expansion state\n                        agents: new Map(),\n                        todos: [],\n                        userInstructions: [],\n                        tools: [],\n                        toolsMap: new Map(),\n                        status: 'active',\n                        currentTodoTool: null,\n                        // Preserve additional session metadata\n                        working_directory: sessionData.working_directory,\n                        git_branch: sessionData.git_branch,\n                        eventCount: sessionData.eventCount\n                    };\n                    this.sessions.set(sessionId, activitySession);\n                } else {\n                    // Update existing session metadata without clearing accumulated data\n                    // CRITICAL: Preserve all accumulated data (tools, agents, todos, etc.)\n                    const existingSession = this.sessions.get(sessionId);\n                    existingSession.timestamp = new Date(sessionData.lastActivity || sessionData.startTime || existingSession.timestamp);\n                    existingSession.eventCount = sessionData.eventCount;\n                    existingSession.status = sessionData.status || existingSession.status;\n                    // Update metadata without losing accumulated data\n                    existingSession.working_directory = sessionData.working_directory || existingSession.working_directory;\n                    existingSession.git_branch = sessionData.git_branch || existingSession.git_branch;\n                    // DO NOT reset tools, agents, todos, userInstructions, toolsMap, etc.\n                    // These are built up from events and must be preserved!\n                }\n            }\n            \n            // Process only events we haven't seen before\n            const newEvents = events.filter(event => {\n                const eventId = event.id || `${event.type}-${event.timestamp}-${Math.random()}`;\n                return !this.processedEventIds.has(eventId);\n            });\n            \n            if (newEvents.length > 0) {\n                console.log(`ActivityTree: Processing ${newEvents.length} new events`, newEvents);\n                \n                newEvents.forEach(event => {\n                    const eventId = event.id || `${event.type}-${event.timestamp}-${Math.random()}`;\n                    this.processedEventIds.add(eventId);\n                    this.processEvent(event);\n                });\n            }\n                \n            this.events = [...events];\n            // Use debounced render to prevent excessive DOM rebuilds\n            this.renderTreeDebounced();\n            \n            // Debug: Log session state after processing\n            console.log(`ActivityTree: Sessions after sync with socket client:`, Array.from(this.sessions.entries()));\n        });\n\n        // Load existing data from socket client\n        const socketState = window.socketClient?.getState();\n        \n        if (socketState && socketState.events.length > 0) {\n            console.log(`ActivityTree: Loading existing data - ${socketState.events.length} events, ${socketState.sessions.size} sessions`);\n            \n            // Initialize from existing socket client data\n            // Don't clear existing sessions - preserve accumulated data\n            \n            // Convert authoritative sessions Map to our format\n            for (const [sessionId, sessionData] of socketState.sessions.entries()) {\n                if (!this.sessions.has(sessionId)) {\n                    const activitySession = {\n                        id: sessionId,\n                        timestamp: new Date(sessionData.lastActivity || sessionData.startTime || new Date()),\n                        expanded: this.expandedSessions.has(sessionId) || true,\n                        agents: new Map(),\n                        todos: [],\n                        userInstructions: [],\n                        tools: [],\n                        toolsMap: new Map(),\n                        status: 'active',\n                        currentTodoTool: null,\n                        working_directory: sessionData.working_directory,\n                        git_branch: sessionData.git_branch,\n                        eventCount: sessionData.eventCount\n                    };\n                    this.sessions.set(sessionId, activitySession);\n                }\n            }\n            \n            // Process only events we haven't seen before\n            const unprocessedEvents = socketState.events.filter(event => {\n                const eventId = event.id || `${event.type}-${event.timestamp}-${Math.random()}`;\n                return !this.processedEventIds.has(eventId);\n            });\n            \n            if (unprocessedEvents.length > 0) {\n                console.log(`ActivityTree: Processing ${unprocessedEvents.length} unprocessed events from initial load`);\n                unprocessedEvents.forEach(event => {\n                    const eventId = event.id || `${event.type}-${event.timestamp}-${Math.random()}`;\n                    this.processedEventIds.add(eventId);\n                    this.processEvent(event);\n                });\n            }\n            \n            this.events = [...socketState.events];\n            // Initial render can be immediate\n            this.renderTree();\n            \n            // Debug: Log initial session state\n            console.log(`ActivityTree: Initial sessions state:`, Array.from(this.sessions.entries()));\n        } else {\n            console.log('ActivityTree: No existing events found');\n            this.events = [];\n            this.sessions.clear();\n            this.renderTree();\n        }\n    }\n\n    /**\n     * Process an event and update the session structure\n     */\n    processEvent(event) {\n        if (!event) {\n            console.log('ActivityTree: Ignoring null event');\n            return;\n        }\n        \n        // Determine event type\n        let eventType = this.getEventType(event);\n        if (!eventType) {\n            return;\n        }\n        \n        console.log(`ActivityTree: Processing event: ${eventType}`, event);\n        \n        // Fix timestamp processing - ensure we get a valid date\n        let timestamp;\n        if (event.timestamp) {\n            // Handle both ISO strings and already parsed dates\n            timestamp = new Date(event.timestamp);\n            // Check if date is valid\n            if (isNaN(timestamp.getTime())) {\n                console.warn('ActivityTree: Invalid timestamp, using current time:', event.timestamp);\n                timestamp = new Date();\n            }\n        } else {\n            console.warn('ActivityTree: No timestamp found, using current time');\n            timestamp = new Date();\n        }\n        \n        // Get session ID from event - this should match the authoritative sessions\n        const sessionId = event.session_id || event.data?.session_id;\n        \n        // Skip events without session ID - they can't be properly categorized\n        if (!sessionId) {\n            console.log(`ActivityTree: Skipping event without session_id: ${eventType}`);\n            return;\n        }\n        \n        // Find the session - it should already exist from authoritative sessions\n        if (!this.sessions.has(sessionId)) {\n            console.warn(`ActivityTree: Session ${sessionId} not found in authoritative sessions - skipping event`);\n            return;\n        }\n        \n        const session = this.sessions.get(sessionId);\n        \n        switch (eventType) {\n            case 'Start':\n                // New PM session started\n                this.currentSession = session;\n                break;\n            case 'user_prompt':\n                this.processUserInstruction(event, session);\n                break;\n            case 'TodoWrite':\n                // TodoWrite is now handled as a tool in 'tool_use' events\n                // Skip separate TodoWrite processing to avoid duplication\n                break;\n            case 'SubagentStart':\n                this.processSubagentStart(event, session);\n                break;\n            case 'SubagentStop':\n                this.processSubagentStop(event, session);\n                break;\n            case 'PreToolUse':\n                this.processToolUse(event, session);\n                break;\n            case 'PostToolUse':\n                this.updateToolStatus(event, session, 'completed');\n                break;\n        }\n        \n        this.updateStats();\n    }\n\n    /**\n     * Get event type from event data\n     */\n    getEventType(event) {\n        if (event.hook_event_name) {\n            return event.hook_event_name;\n        }\n        \n        if (event.type === 'hook' && event.subtype) {\n            const mapping = {\n                'pre_tool': 'PreToolUse',\n                'post_tool': 'PostToolUse',\n                'subagent_start': 'SubagentStart',\n                'subagent_stop': 'SubagentStop',\n                'todo_write': 'TodoWrite'\n            };\n            return mapping[event.subtype];\n        }\n        \n        if (event.type === 'todo' && event.subtype === 'updated') {\n            return 'TodoWrite';\n        }\n        \n        if (event.type === 'subagent') {\n            if (event.subtype === 'started') return 'SubagentStart';\n            if (event.subtype === 'stopped') return 'SubagentStop';\n        }\n        \n        if (event.type === 'start') {\n            return 'Start';\n        }\n        \n        if (event.type === 'user_prompt' || event.subtype === 'user_prompt') {\n            return 'user_prompt';\n        }\n        \n        return null;\n    }\n\n    // getSessionId method removed - now using authoritative session IDs directly from socket client\n\n    /**\n     * Process user instruction/prompt event\n     */\n    processUserInstruction(event, session) {\n        const promptText = event.prompt_text || event.data?.prompt_text || event.prompt || '';\n        if (!promptText) return;\n        \n        const instruction = {\n            id: `instruction-${session.id}-${Date.now()}`,\n            text: promptText,\n            preview: promptText.length > 100 ? promptText.substring(0, 100) + '...' : promptText,\n            timestamp: event.timestamp || new Date().toISOString(),\n            type: 'user_instruction'\n        };\n        \n        // NEW USER PROMPT: Only collapse agents if we have existing ones\n        // Don't clear - we want to keep the history!\n        if (session.agents.size > 0) {\n            console.log('ActivityTree: New user prompt detected, collapsing previous agents');\n            \n            // Mark all existing agents as completed (not active)\n            for (let agent of session.agents.values()) {\n                if (agent.status === 'active') {\n                    agent.status = 'completed';\n                }\n                // Collapse all existing agents\n                this.expandedAgents.delete(agent.id);\n            }\n        }\n        \n        // Reset current active agent for new work\n        session.currentActiveAgent = null;\n        \n        // Add to session's user instructions\n        session.userInstructions.push(instruction);\n        \n        // Keep only last 5 instructions to prevent memory bloat\n        if (session.userInstructions.length > 5) {\n            session.userInstructions = session.userInstructions.slice(-5);\n        }\n    }\n\n    /**\n     * Process TodoWrite event - attach TODOs to session and active agent\n     */\n    processTodoWrite(event, session) {\n        let todos = event.todos || event.data?.todos || event.data || [];\n        \n        if (todos && typeof todos === 'object' && todos.todos) {\n            todos = todos.todos;\n        }\n        \n        if (!Array.isArray(todos) || todos.length === 0) {\n            return;\n        }\n\n        // Update session's current todos for latest state tracking\n        session.currentTodos = todos.map(todo => ({\n            content: todo.content,\n            activeForm: todo.activeForm,\n            status: todo.status,\n            timestamp: event.timestamp\n        }));\n\n        // Find the appropriate agent to attach this TodoWrite to\n        let targetAgent = session.currentActiveAgent;\n        \n        if (!targetAgent) {\n            // Fall back to most recent active agent\n            const activeAgents = this.getAllAgents(session)\n                .filter(agent => agent.status === 'active' || agent.status === 'in_progress')\n                .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n            \n            if (activeAgents.length > 0) {\n                targetAgent = activeAgents[0];\n            } else {\n                // If no active agents, check if this is PM-level\n                const allAgents = this.getAllAgents(session);\n                const pmAgent = allAgents.find(a => a.isPM);\n                if (pmAgent) {\n                    targetAgent = pmAgent;\n                } else if (allAgents.length > 0) {\n                    targetAgent = allAgents[0];\n                }\n            }\n        }\n\n        // Attach or update TodoWrite for the agent\n        if (targetAgent) {\n            if (!targetAgent.todoWritesMap) {\n                targetAgent.todoWritesMap = new Map();\n            }\n            if (!targetAgent.todoWrites) {\n                targetAgent.todoWrites = [];\n            }\n            \n            // Check if we already have a TodoWrite instance\n            const existingTodoWrite = targetAgent.todoWritesMap.get('TodoWrite');\n            \n            if (existingTodoWrite) {\n                // Update existing TodoWrite instance\n                existingTodoWrite.todos = todos;\n                existingTodoWrite.timestamp = event.timestamp;\n                existingTodoWrite.updateCount = (existingTodoWrite.updateCount || 1) + 1;\n            } else {\n                // Create new TodoWrite instance\n                const todoWriteInstance = {\n                    id: `todowrite-${targetAgent.id}-${Date.now()}`,\n                    name: 'TodoWrite',\n                    type: 'todowrite',\n                    icon: '📝',\n                    timestamp: event.timestamp,\n                    status: 'completed',\n                    todos: todos,\n                    params: {\n                        todos: todos\n                    },\n                    updateCount: 1\n                };\n                \n                targetAgent.todoWritesMap.set('TodoWrite', todoWriteInstance);\n                targetAgent.todoWrites = [todoWriteInstance]; // Keep single instance\n            }\n            \n            // Update agent's current todos for display when collapsed\n            targetAgent.currentTodos = todos;\n        } else {\n            // No agent found, attach to session level\n            if (!session.todoWrites) {\n                session.todoWrites = [];\n            }\n            if (!session.todoWritesMap) {\n                session.todoWritesMap = new Map();\n            }\n            \n            const existingTodoWrite = session.todoWritesMap.get('TodoWrite');\n            if (existingTodoWrite) {\n                existingTodoWrite.todos = todos;\n                existingTodoWrite.timestamp = event.timestamp;\n                existingTodoWrite.updateCount = (existingTodoWrite.updateCount || 1) + 1;\n            } else {\n                const todoWriteInstance = {\n                    id: `todowrite-session-${Date.now()}`,\n                    name: 'TodoWrite',\n                    type: 'todowrite',\n                    icon: '📝',\n                    timestamp: event.timestamp,\n                    status: 'completed',\n                    todos: todos,\n                    updateCount: 1\n                };\n                session.todoWritesMap.set('TodoWrite', todoWriteInstance);\n                session.todoWrites = [todoWriteInstance];\n            }\n        }\n    }\n\n    /**\n     * Process SubagentStart event\n     */\n    processSubagentStart(event, session) {\n        const agentName = event.agent_name || event.data?.agent_name || event.data?.agent_type || event.agent_type || event.agent || 'unknown';\n        const agentSessionId = event.session_id || event.data?.session_id;\n        const parentAgent = event.parent_agent || event.data?.parent_agent;\n        \n        // Use a composite key based on agent name and session to find existing instances\n        // This ensures we track unique agent instances per session\n        const agentKey = `${agentName}-${agentSessionId || 'no-session'}`;\n        \n        // Check if this exact agent already exists (same name and session)\n        let existingAgent = null;\n        const allAgents = this.getAllAgents(session);\n        existingAgent = allAgents.find(a => \n            a.name === agentName && \n            a.sessionId === agentSessionId &&\n            a.status === 'active'  // Only reuse if still active\n        );\n        \n        let agent;\n        if (existingAgent) {\n            // Update existing active agent\n            agent = existingAgent;\n            agent.timestamp = event.timestamp;\n            agent.instanceCount = (agent.instanceCount || 1) + 1;\n            // Auto-expand the active agent\n            this.expandedAgents.add(agent.id);\n        } else {\n            // Create new agent instance for first occurrence\n            const agentId = `agent-${agentKey}-${Date.now()}`;\n            agent = {\n                id: agentId,\n                name: agentName,\n                type: 'agent',\n                icon: this.getAgentIcon(agentName),\n                timestamp: event.timestamp,\n                status: 'active',\n                tools: [],\n                subagents: new Map(),  // Store nested subagents\n                sessionId: agentSessionId,\n                parentAgent: parentAgent,\n                isPM: agentName.toLowerCase() === 'pm' || agentName.toLowerCase().includes('project manager'),\n                instanceCount: 1,\n                toolsMap: new Map() // Track unique tools by name\n            };\n            \n            // If this is a subagent, nest it under the parent agent\n            if (parentAgent) {\n                // Find the parent agent in the session\n                let parent = null;\n                for (let [id, ag] of session.agents.entries()) {\n                    if (ag.sessionId === parentAgent || ag.name === parentAgent) {\n                        parent = ag;\n                        break;\n                    }\n                }\n                \n                if (parent) {\n                    // Add as nested subagent\n                    if (!parent.subagents) {\n                        parent.subagents = new Map();\n                    }\n                    parent.subagents.set(agent.id, agent);\n                } else {\n                    // No parent found, add to session level\n                    session.agents.set(agent.id, agent);\n                }\n            } else {\n                // Top-level agent, add to session\n                session.agents.set(agent.id, agent);\n            }\n            \n            // Auto-expand new agents\n            this.expandedAgents.add(agent.id);\n        }\n        \n        // Track the currently active agent for tool/todo association\n        session.currentActiveAgent = agent;\n    }\n\n    /**\n     * Process SubagentStop event\n     */\n    processSubagentStop(event, session) {\n        const agentSessionId = event.session_id || event.data?.session_id;\n        \n        // Find and mark agent as completed\n        if (agentSessionId && session.agents.has(agentSessionId)) {\n            const agent = session.agents.get(agentSessionId);\n            agent.status = 'completed';\n        }\n    }\n\n    /**\n     * Process tool use event\n     * \n     * DISPLAY RULES:\n     * 1. TodoWrite is a privileged tool that ALWAYS appears first under the agent/PM\n     * 2. Each tool appears only once per unique instance (updated in place)\n     * 3. Tools are listed in order of creation (after TodoWrite)\n     * 4. Tool instances are updated with new events as they arrive\n     */\n    processToolUse(event, session) {\n        const toolName = event.tool_name || event.data?.tool_name || event.tool || event.data?.tool || 'unknown';\n        const params = event.tool_parameters || event.data?.tool_parameters || event.parameters || event.data?.parameters || {};\n        const agentSessionId = event.session_id || event.data?.session_id;\n\n        // Find the appropriate agent to attach this tool to\n        let targetAgent = session.currentActiveAgent;\n        \n        if (!targetAgent) {\n            // Fall back to finding by session ID or most recent active\n            const allAgents = this.getAllAgents(session);\n            targetAgent = allAgents.find(a => a.sessionId === agentSessionId) ||\n                         allAgents.find(a => a.status === 'active') ||\n                         allAgents[0];\n        }\n\n        if (targetAgent) {\n            if (!targetAgent.toolsMap) {\n                targetAgent.toolsMap = new Map();\n            }\n            if (!targetAgent.tools) {\n                targetAgent.tools = [];\n            }\n            \n            // Check if we already have this tool instance\n            // Use tool name + params hash for unique identification\n            const toolKey = this.getToolKey(toolName, params);\n            let existingTool = targetAgent.toolsMap.get(toolKey);\n            \n            if (existingTool) {\n                // UPDATE RULE: Update existing tool instance in place\n                existingTool.params = params;\n                existingTool.timestamp = event.timestamp;\n                existingTool.status = 'in_progress';\n                existingTool.eventId = event.id;\n                existingTool.callCount = (existingTool.callCount || 1) + 1;\n                \n                // Update current tool for collapsed display\n                targetAgent.currentTool = existingTool;\n            } else {\n                // CREATE RULE: Create new tool instance\n                const tool = {\n                    id: `tool-${targetAgent.id}-${toolName}-${Date.now()}`,\n                    name: toolName,\n                    type: 'tool',\n                    icon: this.getToolIcon(toolName),\n                    timestamp: event.timestamp,\n                    status: 'in_progress',\n                    params: params,\n                    eventId: event.id,\n                    callCount: 1,\n                    createdAt: event.timestamp  // Track creation order\n                };\n                \n                // Special handling for Task tool (subagent delegation)\n                if (toolName === 'Task' && params.subagent_type) {\n                    tool.isSubagentTask = true;\n                    tool.subagentType = params.subagent_type;\n                }\n                \n                targetAgent.toolsMap.set(toolKey, tool);\n                \n                // ORDERING RULE: TodoWrite always goes first, others in creation order\n                if (toolName === 'TodoWrite') {\n                    // Insert TodoWrite at the beginning\n                    targetAgent.tools.unshift(tool);\n                } else {\n                    // Append other tools in creation order\n                    targetAgent.tools.push(tool);\n                }\n                \n                targetAgent.currentTool = tool;\n            }\n        } else {\n            // No agent found, attach to session (PM level)\n            // PM RULE: Same display rules apply - TodoWrite first, others in creation order\n            if (!session.tools) {\n                session.tools = [];\n            }\n            if (!session.toolsMap) {\n                session.toolsMap = new Map();\n            }\n            \n            const toolKey = this.getToolKey(toolName, params);\n            let existingTool = session.toolsMap.get(toolKey);\n            \n            if (existingTool) {\n                // UPDATE RULE: Update existing tool instance in place\n                existingTool.params = params;\n                existingTool.timestamp = event.timestamp;\n                existingTool.status = 'in_progress';\n                existingTool.eventId = event.id;\n                existingTool.callCount = (existingTool.callCount || 1) + 1;\n                session.currentTool = existingTool;\n            } else {\n                const tool = {\n                    id: `tool-session-${toolName}-${Date.now()}`,\n                    name: toolName,\n                    type: 'tool',\n                    icon: this.getToolIcon(toolName),\n                    timestamp: event.timestamp,\n                    status: 'in_progress',\n                    params: params,\n                    eventId: event.id,\n                    callCount: 1,\n                    createdAt: event.timestamp  // Track creation order\n                };\n                \n                session.toolsMap.set(toolKey, tool);\n                \n                // ORDERING RULE: TodoWrite always goes first for PM too\n                if (toolName === 'TodoWrite') {\n                    session.tools.unshift(tool);\n                } else {\n                    session.tools.push(tool);\n                }\n                \n                session.currentTool = tool;\n            }\n        }\n    }\n\n    /**\n     * Generate unique key for tool instance identification\n     * Tools are unique per name + certain parameter combinations\n     */\n    getToolKey(toolName, params) {\n        // For TodoWrite, we want ONE instance per agent/PM that updates in place\n        // So we use just the tool name as the key\n        if (toolName === 'TodoWrite') {\n            return 'TodoWrite';  // Single instance per agent/PM\n        }\n        \n        // For other tools, we generally want one instance per tool type\n        // that gets updated with each call (not creating new instances)\n        let key = toolName;\n        \n        // Only add distinguishing params if we need multiple instances\n        // For example, multiple files being edited simultaneously\n        if (toolName === 'Edit' || toolName === 'Write' || toolName === 'Read') {\n            if (params.file_path) {\n                key += `-${params.file_path}`;\n            }\n        }\n        \n        // For search tools, we might want separate instances for different searches\n        if ((toolName === 'Grep' || toolName === 'Glob') && params.pattern) {\n            // Only add pattern if significantly different\n            key += `-${params.pattern.substring(0, 20)}`;\n        }\n        \n        // Most tools should have a single instance that updates\n        // This prevents the tool list from growing unbounded\n        return key;\n    }\n\n    /**\n     * Update tool status after completion\n     */\n    updateToolStatus(event, session, status) {\n        const toolName = event.tool_name || event.data?.tool_name || event.tool || 'unknown';\n        const params = event.tool_parameters || event.data?.tool_parameters || event.parameters || event.data?.parameters || {};\n        const agentSessionId = event.session_id || event.data?.session_id;\n        \n        // Generate the same key we used to store the tool\n        const toolKey = this.getToolKey(toolName, params);\n        \n        // Find the appropriate agent\n        let targetAgent = session.currentActiveAgent;\n        \n        if (!targetAgent) {\n            const allAgents = this.getAllAgents(session);\n            targetAgent = allAgents.find(a => a.sessionId === agentSessionId) ||\n                         allAgents.find(a => a.status === 'active');\n        }\n        \n        if (targetAgent && targetAgent.toolsMap) {\n            const tool = targetAgent.toolsMap.get(toolKey);\n            if (tool) {\n                tool.status = status;\n                tool.completedAt = event.timestamp;\n                if (event.data?.result || event.result) {\n                    tool.result = event.data?.result || event.result;\n                }\n                if (event.data?.duration_ms) {\n                    tool.duration = event.data.duration_ms;\n                }\n                return;\n            }\n        }\n        \n        // Check session-level tools\n        if (session.toolsMap) {\n            const tool = session.toolsMap.get(toolKey);\n            if (tool) {\n                tool.status = status;\n                tool.completedAt = event.timestamp;\n                if (event.data?.result || event.result) {\n                    tool.result = event.data?.result || event.result;\n                }\n                if (event.data?.duration_ms) {\n                    tool.duration = event.data.duration_ms;\n                }\n                return;\n            }\n        }\n        \n        console.log(`ActivityTree: Could not find tool to update status for ${toolName} with key ${toolKey} (event ${event.id})`);\n    }\n\n    /**\n     * Render the linear tree view\n     */\n    renderTree() {\n        const treeContainer = document.getElementById('linear-tree');\n        if (!treeContainer) return;\n        \n        // Clear tree\n        treeContainer.innerHTML = '';\n        \n        // Add sessions directly (no project root)\n        const sortedSessions = Array.from(this.sessions.values())\n            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n        \n        for (let session of sortedSessions) {\n            if (this.selectedSessionFilter !== 'all' && this.selectedSessionFilter !== session.id) {\n                continue;\n            }\n            \n            const sessionElement = this.createSessionElement(session);\n            treeContainer.appendChild(sessionElement);\n        }\n        \n        // Session filtering is now handled by the main session selector via event listeners\n    }\n\n\n    /**\n     * Create session element\n     */\n    createSessionElement(session) {\n        const isExpanded = this.expandedSessions.has(session.id) || session.expanded;\n        \n        // Ensure timestamp is valid and format it consistently\n        let sessionTime;\n        try {\n            const sessionDate = session.timestamp instanceof Date ? session.timestamp : new Date(session.timestamp);\n            if (isNaN(sessionDate.getTime())) {\n                sessionTime = 'Invalid Date';\n                console.warn('ActivityTree: Invalid session timestamp:', session.timestamp);\n            } else {\n                sessionTime = sessionDate.toLocaleString();\n            }\n        } catch (error) {\n            sessionTime = 'Invalid Date';\n            console.error('ActivityTree: Error formatting session timestamp:', error, session.timestamp);\n        }\n        \n        const element = document.createElement('div');\n        element.className = 'tree-node session';\n        element.dataset.sessionId = session.id;\n        \n        const expandIcon = isExpanded ? '▼' : '▶';\n        // Count ALL agents including nested ones\n        const agentCount = this.getAllAgents(session).length;\n        const todoCount = session.currentTodos ? session.currentTodos.length : 0;\n        const instructionCount = session.userInstructions ? session.userInstructions.length : 0;\n        \n        console.log(`ActivityTree: Rendering session ${session.id}: ${agentCount} agents, ${instructionCount} instructions, ${todoCount} todos at ${sessionTime}`);\n        \n        element.innerHTML = `\n            <div class=\"tree-node-content\" onclick=\"window.activityTreeInstance.toggleSession('${session.id}')\">\n                <span class=\"tree-expand-icon\">${expandIcon}</span>\n                <span class=\"tree-icon\">🎯</span>\n                <span class=\"tree-label\">PM Session</span>\n                <span class=\"tree-meta\">${sessionTime} • ${agentCount} agent(s) • ${instructionCount} instruction(s) • ${todoCount} todo(s)</span>\n            </div>\n            <div class=\"tree-children\" style=\"display: ${isExpanded ? 'block' : 'none'}\">\n                ${this.renderSessionContent(session)}\n            </div>\n        `;\n        \n        return element;\n    }\n\n    /**\n     * Render session content (user instructions, todos, agents, tools)\n     * \n     * PM DISPLAY RULES (documented inline):\n     * 1. User instructions appear first (context)\n     * 2. PM-level tools follow the same rules as agent tools:\n     *    - TodoWrite is privileged and appears first\n     *    - Other tools appear in creation order\n     *    - Each unique instance is updated in place\n     * 3. Agents appear after PM tools\n     */\n    renderSessionContent(session) {\n        let html = '';\n        \n        // Render user instructions first\n        if (session.userInstructions && session.userInstructions.length > 0) {\n            for (let instruction of session.userInstructions.slice(-3)) { // Show last 3 instructions\n                html += this.renderUserInstructionElement(instruction, 1);\n            }\n        }\n        \n        // PM TOOL DISPLAY RULES:\n        // Render PM-level tools (TodoWrite first, then others in creation order)\n        // The session.tools array is already properly ordered by processToolUse\n        if (session.tools && session.tools.length > 0) {\n            for (let tool of session.tools) {\n                html += this.renderToolElement(tool, 1);\n            }\n        }\n        \n        // Render agents (they will have their own TodoWrite at the top)\n        const agents = Array.from(session.agents.values())\n            .sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));\n        \n        for (let agent of agents) {\n            html += this.renderAgentElement(agent, 1);\n        }\n        \n        return html;\n    }\n\n    /**\n     * Render user instruction element\n     */\n    renderUserInstructionElement(instruction, level) {\n        const isSelected = this.selectedItem && this.selectedItem.type === 'instruction' && this.selectedItem.data.id === instruction.id;\n        const selectedClass = isSelected ? 'selected' : '';\n        \n        return `\n            <div class=\"tree-node user-instruction ${selectedClass}\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    <span class=\"tree-expand-icon\"></span>\n                    <span class=\"tree-icon\">💬</span>\n                    <span class=\"tree-label clickable\" onclick=\"window.activityTreeInstance.selectItem(${this.escapeJson(instruction)}, 'instruction', event)\">User: \"${this.escapeHtml(instruction.preview)}\"</span>\n                    <span class=\"tree-status status-active\">instruction</span>\n                </div>\n            </div>\n        `;\n    }\n\n    /**\n     * Render TODO checklist element\n     */\n    renderTodoChecklistElement(todos, level) {\n        const checklistId = `checklist-${Date.now()}`;\n        const isExpanded = this.expandedTools.has(checklistId) !== false; // Default to expanded\n        const expandIcon = isExpanded ? '▼' : '▶';\n        \n        // Calculate status summary\n        let completedCount = 0;\n        let inProgressCount = 0;\n        let pendingCount = 0;\n        \n        todos.forEach(todo => {\n            if (todo.status === 'completed') completedCount++;\n            else if (todo.status === 'in_progress') inProgressCount++;\n            else pendingCount++;\n        });\n        \n        let statusSummary = '';\n        if (inProgressCount > 0) {\n            statusSummary = `${inProgressCount} in progress, ${completedCount} completed`;\n        } else if (completedCount === todos.length && todos.length > 0) {\n            statusSummary = `All ${todos.length} completed`;\n        } else {\n            statusSummary = `${todos.length} todo(s)`;\n        }\n        \n        let html = `\n            <div class=\"tree-node todo-checklist\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    <span class=\"tree-expand-icon\" onclick=\"window.activityTreeInstance.toggleTodoChecklist('${checklistId}'); event.stopPropagation();\">${expandIcon}</span>\n                    <span class=\"tree-icon\">☑️</span>\n                    <span class=\"tree-label\">TODOs</span>\n                    <span class=\"tree-params\">${statusSummary}</span>\n                    <span class=\"tree-status status-active\">checklist</span>\n                </div>\n        `;\n        \n        // Show expanded todo items if expanded\n        if (isExpanded) {\n            html += '<div class=\"tree-children\">';\n            for (let todo of todos) {\n                const statusIcon = this.getCheckboxIcon(todo.status);\n                const statusClass = `status-${todo.status}`;\n                const displayText = todo.status === 'in_progress' ? todo.activeForm : todo.content;\n                \n                html += `\n                    <div class=\"tree-node todo-item ${statusClass}\" data-level=\"${level + 1}\">\n                        <div class=\"tree-node-content\">\n                            <span class=\"tree-expand-icon\"></span>\n                            <span class=\"tree-icon\">${statusIcon}</span>\n                            <span class=\"tree-label\">${this.escapeHtml(displayText)}</span>\n                            <span class=\"tree-status ${statusClass}\">${todo.status.replace('_', ' ')}</span>\n                        </div>\n                    </div>\n                `;\n            }\n            html += '</div>';\n        }\n        \n        html += '</div>';\n        return html;\n    }\n\n    /**\n     * Render agent element with proper nesting\n     */\n    renderAgentElement(agent, level) {\n        const statusClass = agent.status === 'active' ? 'status-active' : 'status-completed';\n        const isExpanded = this.expandedAgents.has(agent.id);\n        const hasTools = agent.tools && agent.tools.length > 0;\n        const hasSubagents = agent.subagents && agent.subagents.size > 0;\n        const hasContent = hasTools || hasSubagents;\n        const isSelected = this.selectedItem && this.selectedItem.type === 'agent' && this.selectedItem.data.id === agent.id;\n        \n        const expandIcon = hasContent ? (isExpanded ? '▼' : '▶') : '';\n        const selectedClass = isSelected ? 'selected' : '';\n        \n        // Add instance count if called multiple times\n        const instanceIndicator = agent.instanceCount > 1 ? ` (${agent.instanceCount}x)` : '';\n        \n        // Build status display for collapsed state\n        let collapsedStatus = '';\n        if (!isExpanded && hasContent) {\n            const parts = [];\n            if (agent.currentTodos && agent.currentTodos.length > 0) {\n                const inProgress = agent.currentTodos.find(t => t.status === 'in_progress');\n                if (inProgress) {\n                    parts.push(`📝 ${inProgress.activeForm || inProgress.content}`);\n                }\n            }\n            if (agent.currentTool) {\n                parts.push(`${agent.currentTool.icon} ${agent.currentTool.name}`);\n            }\n            if (parts.length > 0) {\n                collapsedStatus = ` • ${parts.join(' • ')}`;\n            }\n        }\n        \n        let html = `\n            <div class=\"tree-node agent ${statusClass} ${selectedClass}\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    ${expandIcon ? `<span class=\"tree-expand-icon\" onclick=\"window.activityTreeInstance.toggleAgent('${agent.id}'); event.stopPropagation();\">${expandIcon}</span>` : '<span class=\"tree-expand-icon\"></span>'}\n                    <span class=\"tree-icon\">${agent.icon}</span>\n                    <span class=\"tree-label clickable\" onclick=\"window.activityTreeInstance.selectItem(${this.escapeJson(agent)}, 'agent', event)\">${agent.name}${instanceIndicator}${collapsedStatus}</span>\n                    <span class=\"tree-status ${statusClass}\">${agent.status}</span>\n                </div>\n        `;\n        \n        // Render nested content when expanded\n        if (hasContent && isExpanded) {\n            html += '<div class=\"tree-children\">';\n            \n            // DISPLAY ORDER RULES (documented inline):\n            // 1. TodoWrite is a privileged tool - ALWAYS appears first\n            // 2. Each tool appears only once per unique instance\n            // 3. Tools are displayed in order of creation (after TodoWrite)\n            // 4. Tool instances are updated in place as new events arrive\n            \n            // Render all tools in their proper order\n            // The tools array is already ordered: TodoWrite first, then others by creation\n            if (hasTools) {\n                for (let tool of agent.tools) {\n                    html += this.renderToolElement(tool, level + 1);\n                }\n            }\n            \n            // Then render subagents (they will have their own TodoWrite at the top)\n            if (hasSubagents) {\n                const subagents = Array.from(agent.subagents.values());\n                for (let subagent of subagents) {\n                    html += this.renderAgentElement(subagent, level + 1);\n                }\n            }\n            \n            html += '</div>';\n        }\n        \n        html += '</div>';\n        return html;\n    }\n\n    /**\n     * Render tool element (non-expandable, clickable to show data)\n     */\n    renderToolElement(tool, level) {\n        const statusClass = `status-${tool.status}`;\n        const params = this.getToolParams(tool);\n        const isSelected = this.selectedItem && this.selectedItem.type === 'tool' && this.selectedItem.data.id === tool.id;\n        const selectedClass = isSelected ? 'selected' : '';\n        \n        // Add visual status indicators\n        const statusIcon = this.getToolStatusIcon(tool.status);\n        const statusLabel = this.getToolStatusLabel(tool.status);\n        \n        // Add call count if more than 1\n        const callIndicator = tool.callCount > 1 ? ` (${tool.callCount} calls)` : '';\n        \n        let html = `\n            <div class=\"tree-node tool ${statusClass} ${selectedClass}\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    <span class=\"tree-expand-icon\"></span>\n                    <span class=\"tree-icon\">${tool.icon}</span>\n                    <span class=\"tree-status-icon\">${statusIcon}</span>\n                    <span class=\"tree-label clickable\" onclick=\"window.activityTreeInstance.selectItem(${this.escapeJson(tool)}, 'tool', event)\">${tool.name}${callIndicator}</span>\n                    <span class=\"tree-params\">${params}</span>\n                    <span class=\"tree-status ${statusClass}\">${statusLabel}</span>\n                </div>\n            </div>\n        `;\n        \n        return html;\n    }\n\n    /**\n     * Get formatted tool parameters\n     */\n    getToolParams(tool) {\n        if (!tool.params) return '';\n        \n        if (tool.name === 'Read' && tool.params.file_path) {\n            return tool.params.file_path;\n        }\n        if (tool.name === 'Edit' && tool.params.file_path) {\n            return tool.params.file_path;\n        }\n        if (tool.name === 'Write' && tool.params.file_path) {\n            return tool.params.file_path;\n        }\n        if (tool.name === 'Bash' && tool.params.command) {\n            const cmd = tool.params.command;\n            return cmd.length > 50 ? cmd.substring(0, 50) + '...' : cmd;\n        }\n        if (tool.name === 'WebFetch' && tool.params.url) {\n            return tool.params.url;\n        }\n        \n        return '';\n    }\n\n    /**\n     * Get status icon for todo status\n     */\n    getStatusIcon(status) {\n        const icons = {\n            'pending': '⏸️',\n            'in_progress': '🔄',\n            'completed': '✅'\n        };\n        return icons[status] || '❓';\n    }\n\n    /**\n     * Get checkbox icon for todo checklist items\n     */\n    getCheckboxIcon(status) {\n        const icons = {\n            'pending': '⏳',\n            'in_progress': '🔄',\n            'completed': '✅'\n        };\n        return icons[status] || '❓';\n    }\n\n    /**\n     * Get agent icon based on name\n     */\n    getAgentIcon(agentName) {\n        const icons = {\n            'engineer': '👷',\n            'research': '🔬',\n            'qa': '🧪',\n            'ops': '⚙️',\n            'pm': '📊',\n            'architect': '🏗️',\n            'project manager': '📊'\n        };\n        return icons[agentName.toLowerCase()] || '🤖';\n    }\n\n    /**\n     * Helper to get all agents including nested subagents\n     */\n    getAllAgents(session) {\n        const agents = [];\n        \n        const collectAgents = (agentMap) => {\n            if (!agentMap) return;\n            \n            for (let agent of agentMap.values()) {\n                agents.push(agent);\n                if (agent.subagents && agent.subagents.size > 0) {\n                    collectAgents(agent.subagents);\n                }\n            }\n        };\n        \n        collectAgents(session.agents);\n        return agents;\n    }\n\n    /**\n     * Render TodoWrite element\n     */\n    renderTodoWriteElement(todoWrite, level) {\n        const todoWriteId = todoWrite.id;\n        const isExpanded = this.expandedTools.has(todoWriteId);\n        const expandIcon = isExpanded ? '▼' : '▶';\n        const todos = todoWrite.todos || [];\n        \n        // Calculate status summary\n        let completedCount = 0;\n        let inProgressCount = 0;\n        let pendingCount = 0;\n        \n        todos.forEach(todo => {\n            if (todo.status === 'completed') completedCount++;\n            else if (todo.status === 'in_progress') inProgressCount++;\n            else pendingCount++;\n        });\n        \n        // Find current in-progress todo for highlighting\n        const currentTodo = todos.find(t => t.status === 'in_progress');\n        const currentIndicator = currentTodo ? ` • 🔄 ${currentTodo.activeForm || currentTodo.content}` : '';\n        \n        let statusSummary = '';\n        if (inProgressCount > 0) {\n            statusSummary = `${inProgressCount} in progress, ${completedCount}/${todos.length} done`;\n        } else if (completedCount === todos.length && todos.length > 0) {\n            statusSummary = `All ${todos.length} completed ✅`;\n        } else {\n            statusSummary = `${completedCount}/${todos.length} done`;\n        }\n        \n        // Add update count if more than 1\n        const updateIndicator = todoWrite.updateCount > 1 ? ` (${todoWrite.updateCount} updates)` : '';\n        \n        let html = `\n            <div class=\"tree-node todowrite ${currentTodo ? 'has-active' : ''}\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    <span class=\"tree-expand-icon\" onclick=\"window.activityTreeInstance.toggleTodoWrite('${todoWriteId}'); event.stopPropagation();\">${expandIcon}</span>\n                    <span class=\"tree-icon\">📝</span>\n                    <span class=\"tree-label\">TodoWrite${updateIndicator}${!isExpanded ? currentIndicator : ''}</span>\n                    <span class=\"tree-params\">${statusSummary}</span>\n                    <span class=\"tree-status status-active\">todos</span>\n                </div>\n        `;\n        \n        // Show expanded todo items if expanded\n        if (isExpanded && todos.length > 0) {\n            html += '<div class=\"tree-children\">';\n            for (let todo of todos) {\n                const statusIcon = this.getCheckboxIcon(todo.status);\n                const statusClass = `status-${todo.status}`;\n                const displayText = todo.status === 'in_progress' ? todo.activeForm : todo.content;\n                const isCurrentTodo = todo === currentTodo;\n                \n                html += `\n                    <div class=\"tree-node todo-item ${statusClass} ${isCurrentTodo ? 'current-active' : ''}\" data-level=\"${level + 1}\">\n                        <div class=\"tree-node-content\">\n                            <span class=\"tree-expand-icon\"></span>\n                            <span class=\"tree-icon\">${statusIcon}</span>\n                            <span class=\"tree-label\">${this.escapeHtml(displayText)}</span>\n                            <span class=\"tree-status ${statusClass}\">${todo.status.replace('_', ' ')}</span>\n                        </div>\n                    </div>\n                `;\n            }\n            html += '</div>';\n        }\n        \n        html += '</div>';\n        return html;\n    }\n\n    /**\n     * Toggle TodoWrite expansion\n     */\n    toggleTodoWrite(todoWriteId) {\n        if (this.expandedTools.has(todoWriteId)) {\n            this.expandedTools.delete(todoWriteId);\n        } else {\n            this.expandedTools.add(todoWriteId);\n        }\n        this.renderTree();\n    }\n\n    /**\n     * Get tool icon based on name\n     */\n    getToolIcon(toolName) {\n        const icons = {\n            'read': '👁️',\n            'write': '✍️',\n            'edit': '✏️',\n            'bash': '💻',\n            'webfetch': '🌐',\n            'grep': '🔍',\n            'glob': '📂',\n            'todowrite': '📝'\n        };\n        return icons[toolName.toLowerCase()] || '🔧';\n    }\n\n    /**\n     * Get status icon for tool status\n     */\n    getToolStatusIcon(status) {\n        const icons = {\n            'in_progress': '⏳',\n            'completed': '✅',\n            'failed': '❌',\n            'error': '❌',\n            'pending': '⏸️',\n            'active': '🔄'\n        };\n        return icons[status] || '❓';\n    }\n\n    /**\n     * Get formatted status label for tool\n     */\n    getToolStatusLabel(status) {\n        const labels = {\n            'in_progress': 'in progress',\n            'completed': 'completed',\n            'failed': 'failed',\n            'error': 'error',\n            'pending': 'pending',\n            'active': 'active'\n        };\n        return labels[status] || status;\n    }\n\n    /**\n     * Toggle session expansion\n     */\n    toggleSession(sessionId) {\n        if (this.expandedSessions.has(sessionId)) {\n            this.expandedSessions.delete(sessionId);\n        } else {\n            this.expandedSessions.add(sessionId);\n        }\n        \n        // Update the session in the data structure\n        const session = this.sessions.get(sessionId);\n        if (session) {\n            session.expanded = this.expandedSessions.has(sessionId);\n        }\n        \n        this.renderTree();\n    }\n\n    /**\n     * Expand all sessions\n     */\n    expandAllSessions() {\n        for (let sessionId of this.sessions.keys()) {\n            this.expandedSessions.add(sessionId);\n            const session = this.sessions.get(sessionId);\n            if (session) session.expanded = true;\n        }\n        this.renderTree();\n    }\n\n    /**\n     * Collapse all sessions\n     */\n    collapseAllSessions() {\n        this.expandedSessions.clear();\n        for (let session of this.sessions.values()) {\n            session.expanded = false;\n        }\n        this.renderTree();\n    }\n\n\n    /**\n     * Update statistics\n     */\n    updateStats() {\n        const totalNodes = this.countTotalNodes();\n        const activeNodes = this.countActiveNodes();\n        const maxDepth = this.calculateMaxDepth();\n\n        const nodeCountEl = document.getElementById('node-count');\n        const activeCountEl = document.getElementById('active-count');\n        const depthEl = document.getElementById('tree-depth');\n        \n        if (nodeCountEl) nodeCountEl.textContent = totalNodes;\n        if (activeCountEl) activeCountEl.textContent = activeNodes;\n        if (depthEl) depthEl.textContent = maxDepth;\n        \n        console.log(`ActivityTree: Stats updated - Nodes: ${totalNodes}, Active: ${activeNodes}, Depth: ${maxDepth}`);\n    }\n\n    /**\n     * Count total nodes across all sessions\n     */\n    countTotalNodes() {\n        let count = 0; // No project root anymore\n        for (let session of this.sessions.values()) {\n            count += 1; // Session\n            count += session.agents.size; // Agents\n            \n            // Count user instructions\n            if (session.userInstructions) {\n                count += session.userInstructions.length;\n            }\n            \n            // Count todos\n            if (session.todos) {\n                count += session.todos.length;\n            }\n            \n            // Count session-level tools\n            if (session.tools) {\n                count += session.tools.length;\n            }\n            \n            // Count tools in agents\n            for (let agent of session.agents.values()) {\n                if (agent.tools) {\n                    count += agent.tools.length;\n                }\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Count active nodes (in progress)\n     */\n    countActiveNodes() {\n        let count = 0;\n        for (let session of this.sessions.values()) {\n            // Count active session\n            if (session.status === 'active') count++;\n            \n            // Count active todos\n            if (session.todos) {\n                for (let todo of session.todos) {\n                    if (todo.status === 'in_progress') count++;\n                }\n            }\n            \n            // Count session-level tools\n            if (session.tools) {\n                for (let tool of session.tools) {\n                    if (tool.status === 'in_progress') count++;\n                }\n            }\n            \n            // Count agents and their tools\n            for (let agent of session.agents.values()) {\n                if (agent.status === 'active') count++;\n                if (agent.tools) {\n                    for (let tool of agent.tools) {\n                        if (tool.status === 'in_progress') count++;\n                    }\n                }\n            }\n        }\n        return count;\n    }\n\n    /**\n     * Calculate maximum depth\n     */\n    calculateMaxDepth() {\n        let maxDepth = 0; // No project root anymore\n        for (let session of this.sessions.values()) {\n            let sessionDepth = 1; // Session level (now root level)\n            \n            // Check session content (instructions, todos, tools)\n            if (session.userInstructions && session.userInstructions.length > 0) {\n                sessionDepth = Math.max(sessionDepth, 2); // Instruction level\n            }\n            \n            if (session.todos && session.todos.length > 0) {\n                sessionDepth = Math.max(sessionDepth, 3); // Todo checklist -> todo items\n            }\n            \n            if (session.tools && session.tools.length > 0) {\n                sessionDepth = Math.max(sessionDepth, 2); // Tool level\n            }\n            \n            // Check agents\n            for (let agent of session.agents.values()) {\n                if (agent.tools && agent.tools.length > 0) {\n                    sessionDepth = Math.max(sessionDepth, 3); // Tool level under agents\n                }\n            }\n            \n            maxDepth = Math.max(maxDepth, sessionDepth);\n        }\n        return maxDepth;\n    }\n\n    /**\n     * Toggle agent expansion\n     */\n    toggleAgent(agentId) {\n        if (this.expandedAgents.has(agentId)) {\n            this.expandedAgents.delete(agentId);\n        } else {\n            this.expandedAgents.add(agentId);\n        }\n        this.renderTree();\n    }\n    \n    /**\n     * Toggle tool expansion (deprecated - tools are no longer expandable)\n     */\n    toggleTool(toolId) {\n        // Tools are no longer expandable - this method is kept for compatibility\n        console.log('Tool expansion is disabled. Tools now show data in the left pane when clicked.');\n    }\n\n    /**\n     * Toggle TODO checklist expansion\n     */\n    toggleTodoChecklist(checklistId) {\n        if (this.expandedTools.has(checklistId)) {\n            this.expandedTools.delete(checklistId);\n        } else {\n            this.expandedTools.add(checklistId);\n        }\n        this.renderTree();\n    }\n\n    /**\n     * Render pinned TODOs element under agent\n     */\n    renderPinnedTodosElement(pinnedTodos, level) {\n        const checklistId = `pinned-todos-${Date.now()}`;\n        const isExpanded = this.expandedTools.has(checklistId) !== false; // Default to expanded\n        const expandIcon = isExpanded ? '▼' : '▶';\n        const todos = pinnedTodos.todos || [];\n        \n        // Calculate status summary\n        let completedCount = 0;\n        let inProgressCount = 0;\n        let pendingCount = 0;\n        \n        todos.forEach(todo => {\n            if (todo.status === 'completed') completedCount++;\n            else if (todo.status === 'in_progress') inProgressCount++;\n            else pendingCount++;\n        });\n        \n        let statusSummary = '';\n        if (inProgressCount > 0) {\n            statusSummary = `${inProgressCount} in progress, ${completedCount} completed`;\n        } else if (completedCount === todos.length && todos.length > 0) {\n            statusSummary = `All ${todos.length} completed`;\n        } else {\n            statusSummary = `${todos.length} todo(s)`;\n        }\n        \n        let html = `\n            <div class=\"tree-node pinned-todos\" data-level=\"${level}\">\n                <div class=\"tree-node-content\">\n                    <span class=\"tree-expand-icon\" onclick=\"window.activityTreeInstance.toggleTodoChecklist('${checklistId}'); event.stopPropagation();\">${expandIcon}</span>\n                    <span class=\"tree-icon\">📌</span>\n                    <span class=\"tree-label\">Pinned TODOs</span>\n                    <span class=\"tree-params\">${statusSummary}</span>\n                    <span class=\"tree-status status-active\">pinned</span>\n                </div>\n        `;\n        \n        // Show expanded todo items if expanded\n        if (isExpanded) {\n            html += '<div class=\"tree-children\">';\n            for (let todo of todos) {\n                const statusIcon = this.getCheckboxIcon(todo.status);\n                const statusClass = `status-${todo.status}`;\n                const displayText = todo.status === 'in_progress' ? todo.activeForm : todo.content;\n                \n                html += `\n                    <div class=\"tree-node todo-item ${statusClass}\" data-level=\"${level + 1}\">\n                        <div class=\"tree-node-content\">\n                            <span class=\"tree-expand-icon\"></span>\n                            <span class=\"tree-icon\">${statusIcon}</span>\n                            <span class=\"tree-label\">${this.escapeHtml(displayText)}</span>\n                            <span class=\"tree-status ${statusClass}\">${todo.status.replace('_', ' ')}</span>\n                        </div>\n                    </div>\n                `;\n            }\n            html += '</div>';\n        }\n        \n        html += '</div>';\n        return html;\n    }\n\n    /**\n     * Handle item click to show data in left pane\n     */\n    selectItem(item, itemType, event) {\n        // Stop event propagation to prevent expand/collapse when clicking on label\n        if (event) {\n            event.stopPropagation();\n        }\n        \n        this.selectedItem = { data: item, type: itemType };\n        this.displayItemData(item, itemType);\n        this.renderTree(); // Re-render to show selection highlight\n    }\n\n    /**\n     * Display item data in left pane using UnifiedDataViewer for consistency with Tools viewer\n     */\n    displayItemData(item, itemType) {\n        // Initialize UnifiedDataViewer if not already available\n        if (!this.unifiedViewer) {\n            this.unifiedViewer = new UnifiedDataViewer('module-data-content');\n        }\n        \n        // Use the same UnifiedDataViewer as Tools viewer for consistent display\n        this.unifiedViewer.display(item, itemType);\n        \n        // Update module header for consistency\n        const moduleHeader = document.querySelector('.module-data-header h5');\n        if (moduleHeader) {\n            const icons = {\n                'agent': '🤖',\n                'tool': '🔧', \n                'instruction': '💬',\n                'session': '🎯',\n                'todo': '📝'\n            };\n            const icon = icons[itemType] || '📊';\n            const name = item.name || item.agentName || item.tool_name || 'Item';\n            moduleHeader.textContent = `${icon} ${itemType}: ${name}`;\n        }\n    }\n\n    // Display methods removed - now using UnifiedDataViewer for consistency\n\n    /**\n     * Escape HTML for safe display\n     */\n    escapeHtml(text) {\n        const div = document.createElement('div');\n        div.textContent = text;\n        return div.innerHTML;\n    }\n\n    /**\n     * Reset zoom and pan to initial state\n     */\n    resetZoom() {\n        if (this.svg && this.zoom) {\n            this.svg.transition()\n                .duration(this.duration)\n                .call(this.zoom.transform, d3.zoomIdentity);\n        }\n    }\n    \n    /**\n     * Escape JSON for safe inclusion in HTML attributes\n     */\n    escapeJson(obj) {\n        return JSON.stringify(obj).replace(/'/g, '&apos;').replace(/\"/g, '&quot;');\n    }\n}\n\n// Make ActivityTree globally available\nwindow.ActivityTree = ActivityTree;\n\n// Initialize when the Activity tab is selected\nconst setupActivityTreeListeners = () => {\n    let activityTree = null;\n\n    const initializeActivityTree = () => {\n        if (!activityTree) {\n            console.log('Creating new Activity Tree instance...');\n            activityTree = new ActivityTree();\n            window.activityTreeInstance = activityTree;\n            window.activityTree = () => activityTree; // For debugging\n        }\n        \n        setTimeout(() => {\n            console.log('Attempting to initialize Activity Tree visualization...');\n            activityTree.initialize();\n        }, 100);\n    };\n\n    // REMOVED: Conflicting tab click handlers that were interfering with UIStateManager\n    // Tab switching is now handled entirely through the 'tabChanged' event listener below\n    // This prevents conflicts with the UIStateManager's hash-based navigation system\n\n    // Listen for custom tab change events\n    document.addEventListener('tabChanged', (e) => {\n        if (e.detail && e.detail.newTab === 'activity') {\n            console.log('Tab changed to activity, initializing tree...');\n            initializeActivityTree();\n            if (activityTree) {\n                setTimeout(() => {\n                    activityTree.renderWhenVisible();\n                    activityTree.forceShow();\n                }, 150);\n            }\n        }\n    });\n\n    // Check if activity tab is already active on load\n    const activeTab = document.querySelector('.tab-button.active');\n    if (activeTab && activeTab.getAttribute('data-tab') === 'activity') {\n        console.log('Activity tab is active on load, initializing tree...');\n        initializeActivityTree();\n    }\n    \n    const activityPanel = document.getElementById('activity-tab');\n    if (activityPanel && activityPanel.classList.contains('active')) {\n        console.log('Activity panel is active on load, initializing tree...');\n        if (!activityTree) {\n            initializeActivityTree();\n        }\n    }\n};\n\n// Set up listeners when DOM is ready\nif (document.readyState === 'loading') {\n    document.addEventListener('DOMContentLoaded', setupActivityTreeListeners);\n} else {\n    setupActivityTreeListeners();\n}\n\nexport { ActivityTree };\nexport default ActivityTree;"],"names":["ActivityTree","constructor","this","container","events","processedEventIds","Set","sessions","Map","currentSession","selectedSessionFilter","timeRange","searchTerm","initialized","expandedSessions","expandedAgents","expandedTools","selectedItem","sessionFilterInitialized","renderTreeDebounced","debounce","renderTree","func","wait","timeout","args","clearTimeout","setTimeout","initialize","console","log","document","getElementById","error","tabPanel","classList","contains","setupControls","subscribeToEvents","createLinearTreeView","forceShow","renderWhenVisible","timeRangeSelect","addEventListener","e","target","value","detail","sessionId","window","sessionManager","currentFilter","getCurrentFilter","expandAllBtn","expandAllSessions","collapseAllBtn","collapseAllSessions","resetZoomBtn","style","display","resetZoom","searchInput","toLowerCase","innerHTML","treeContainer","createElement","id","className","appendChild","socketClient","warn","onEventUpdate","length","size","sessionData","entries","has","existingSession","get","timestamp","Date","lastActivity","startTime","eventCount","status","working_directory","git_branch","activitySession","expanded","agents","todos","userInstructions","tools","toolsMap","currentTodoTool","set","newEvents","filter","event","eventId","type","Math","random","forEach","add","processEvent","Array","from","socketState","getState","unprocessedEvents","clear","eventType","getEventType","isNaN","getTime","session_id","data","session","processUserInstruction","processSubagentStart","processSubagentStop","processToolUse","updateToolStatus","updateStats","hook_event_name","subtype","pre_tool","post_tool","subagent_start","subagent_stop","todo_write","promptText","prompt_text","prompt","instruction","now","text","preview","substring","toISOString","agent","values","delete","currentActiveAgent","push","slice","processTodoWrite","isArray","currentTodos","map","todo","content","activeForm","targetAgent","activeAgents","getAllAgents","sort","a","b","allAgents","pmAgent","find","isPM","todoWritesMap","todoWrites","existingTodoWrite","updateCount","todoWriteInstance","name","icon","params","agentName","agent_name","agent_type","agentSessionId","parentAgent","parent_agent","agentKey","existingAgent","instanceCount","getAgentIcon","subagents","includes","parent","ag","toolName","tool_name","tool","tool_parameters","parameters","toolKey","getToolKey","existingTool","callCount","currentTool","getToolIcon","createdAt","subagent_type","isSubagentTask","subagentType","unshift","key","file_path","pattern","completedAt","result","duration_ms","duration","sortedSessions","sessionElement","createSessionElement","isExpanded","sessionTime","sessionDate","toLocaleString","element","dataset","expandIcon","agentCount","todoCount","instructionCount","renderSessionContent","html","renderUserInstructionElement","renderToolElement","renderAgentElement","level","escapeJson","escapeHtml","renderTodoChecklistElement","checklistId","completedCount","inProgressCount","statusSummary","statusIcon","getCheckboxIcon","statusClass","displayText","replace","hasTools","hasSubagents","hasContent","selectedClass","instanceIndicator","collapsedStatus","parts","inProgress","t","join","subagent","getToolParams","getToolStatusIcon","statusLabel","getToolStatusLabel","callIndicator","command","cmd","url","getStatusIcon","pending","in_progress","completed","engineer","research","qa","ops","pm","architect","collectAgents","agentMap","renderTodoWriteElement","todoWrite","todoWriteId","currentTodo","currentIndicator","toggleTodoWrite","read","write","edit","bash","webfetch","grep","glob","todowrite","failed","active","toggleSession","keys","totalNodes","countTotalNodes","activeNodes","countActiveNodes","maxDepth","calculateMaxDepth","nodeCountEl","activeCountEl","depthEl","textContent","count","sessionDepth","max","toggleAgent","agentId","toggleTool","toolId","toggleTodoChecklist","renderPinnedTodosElement","pinnedTodos","selectItem","item","itemType","stopPropagation","displayItemData","unifiedViewer","UnifiedDataViewer","moduleHeader","querySelector","div","svg","zoom","transition","call","transform","d3","zoomIdentity","obj","JSON","stringify","setupActivityTreeListeners","activityTree","initializeActivityTree","activityTreeInstance","newTab","activeTab","getAttribute","activityPanel","readyState"],"mappings":"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"}